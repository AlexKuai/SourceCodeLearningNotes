# 路由

## 源码涉及的核心类型

- RoutePatternPartKind  
- RoutePatternPart  
- RoutePatternLiteralPart  
- RoutePatternSeparatorPart  
- RoutePatternParameterKind  
- RoutePatternParameterPart  
- RoutePatternParameterPolicyReference  
- RoutePatternPathSegment  
- RotePattern  
- EndpointMetadataCollection  
- Endpoint  
- EndpointBuilder  
- RouteEndpoint  
- RouteEndpointBuilder  
- EndpointDataSource  
- DefaultEndpointDataSource  
- IEndpointConventionBuilder  
- RoutingEndpointConventionBuilderExtensions  
- DefaultEndpointConventionBuilder  
- ModelEndpointDataSource  
- CompositeEndpointDataSource  
- RouteHandlerBuilder  
- RouteEndpointDataSource  
- IEndpointRouteBuilder  
- DefaultEndpointRouteBuilder  
- IEndpointFeature  
- EndpointHttpContextExtensions  
- EndpointRoutingApplicationBuilderExtensions  
- EndpointRoutingMiddleware  
- EndpointMiddleware  
- EndpointRouteBuilderExtensions  

## 路由模式

- RoutePatternPartKind

```C#
// 路由模式组成部分枚举
public enum RoutePatternPartKind
{
    // 静态文本部分
    Literal,
    // 参数部分，以 {参数名} 形式表示
    Parameter,
    // 分隔符部分
    Separator
}
```

- RoutePatternPart

```C#
// 表示路由模式组成部分的抽象类
// 每个组成部分枚举对应一个子类
public abstract class RoutePatternPart
{
    private protected RoutePatternPart(RoutePatternPartKind partKind)
    {
        PartKind = partKind;
    }

    public RoutePatternPartKind PartKind { get; }
 
    public bool IsLiteral => PartKind == RoutePatternPartKind.Literal;
 
    public bool IsParameter => PartKind == RoutePatternPartKind.Parameter;
 
    public bool IsSeparator => PartKind == RoutePatternPartKind.Separator;
}
```

- RoutePatternLiteralPart

```C#
// 表示路由模式中的静态文本部分
public sealed class RoutePatternLiteralPart : RoutePatternPart
{
    internal RoutePatternLiteralPart(string content)
        : base(RoutePatternPartKind.Literal)
    {
        Debug.Assert(!string.IsNullOrEmpty(content));
        Content = content;
    }
    
    // 静态文本内容
    public string Content { get; }
}
```

- RoutePatternSeparatorPart

```C#
// 表示路由模式中的分隔符部分
public sealed class RoutePatternSeparatorPart : RoutePatternPart
{
    internal RoutePatternSeparatorPart(string content)
        : base(RoutePatternPartKind.Separator)
    {
        Debug.Assert(!string.IsNullOrEmpty(content));
 
        Content = content;
    }
 
    // 分隔符
    public string Content { get; }
}
```

- RoutePatternParameterKind

```C#
// 路由模式参数形式枚举
public enum RoutePatternParameterKind
{
    // 标准形式
    // 比如 {parameter}
    Standard,
    // 可选形式
    // 比如 {parameter?}
    Optional,
    // 捕获所有形式
    // 比如 {*parameter} 或 {**parameter}
    // 其中 {*parameter} 这种形式会对 "/" 分隔符进行编码（编码为 "%2"），而 {**parameter} 则不会
    CatchAll
}
```

- RoutePatternParameterPart

```C#
// 表示路由模式中的参数部分
public sealed class RoutePatternParameterPart : RoutePatternPart
{
    internal RoutePatternParameterPart(
        string parameterName,
        object? @default,
        RoutePatternParameterKind parameterKind,
        RoutePatternParameterPolicyReference[] parameterPolicies)
        : this(parameterName, @default, parameterKind, parameterPolicies, encodeSlashes: true)
    {
    }
 
    internal RoutePatternParameterPart(
        string parameterName,
        object? @default,
        RoutePatternParameterKind parameterKind,
        RoutePatternParameterPolicyReference[] parameterPolicies,
        bool encodeSlashes)
        : base(RoutePatternPartKind.Parameter)
    {
        Name = parameterName;
        Default = @default;
        ParameterKind = parameterKind;
        ParameterPolicies = parameterPolicies;
        EncodeSlashes = encodeSlashes;
    }
 
    // 针对实际参数的策略集合
    // 每个参数可以应用多个策略（约束）
    public IReadOnlyList<RoutePatternParameterPolicyReference> ParameterPolicies { get; }
 
    // 是否对 "/" 分隔符进行编码
    public bool EncodeSlashes { get; }
 
    // 参数的默认值
    public object? Default { get; }
 
    // 是否捕获所有
    public bool IsCatchAll => ParameterKind == RoutePatternParameterKind.CatchAll;
 
    // 是否可选
    public bool IsOptional => ParameterKind == RoutePatternParameterKind.Optional;
 
    // 参数形式
    public RoutePatternParameterKind ParameterKind { get; }
 
    // 参数名
    public string Name { get; }
}
```

- RoutePatternParameterPolicyReference

```C#
// 路由模式参数策略引用
// 每个参数策略就是一个参数约束
public sealed class RoutePatternParameterPolicyReference
{
    internal RoutePatternParameterPolicyReference(string content)
    {
        Content = content;
    }
 
    internal RoutePatternParameterPolicyReference(IParameterPolicy parameterPolicy)
    {
        ParameterPolicy = parameterPolicy;
    }
 
    // 参数约束的原始字符串内容
    public string? Content { get; }
 
    // 实际的参数策略
    // IParameterPolicy 是一个空的标记接口
    public IParameterPolicy? ParameterPolicy { get; }
}
```

- RoutePatternPathSegment

```C#
// 表示路由模板中的路径段
public sealed class RoutePatternPathSegment
{
    internal RoutePatternPathSegment(IReadOnlyList<RoutePatternPart> parts)
    {
        Parts = parts;
    }
 
    // 如果路径段只包含一个路由模式组成部分则返回 true
    public bool IsSimple => Parts.Count == 1;
 
    // 一般每个路径段只包含一个路由模式组成部分
    // 如果是捕获所有部分则会包含多个路由模式组成部分
    public IReadOnlyList<RoutePatternPart> Parts { get; }
}
```

- RotePattern

```C#
// 路由模式
// 每个字符串形式的路由模板最终都会使用 RoutePatternFactory 这个静态类的 Parse 方法解析成一个 RoutePattern
public sealed class RoutePattern
{
    private const string SeparatorString = "/";
 
    internal RoutePattern(
        string? rawText,
        IReadOnlyDictionary<string, object?> defaults,
        IReadOnlyDictionary<string, IReadOnlyList<RoutePatternParameterPolicyReference>> parameterPolicies,
        IReadOnlyDictionary<string, object?> requiredValues,
        IReadOnlyList<RoutePatternParameterPart> parameters,
        IReadOnlyList<RoutePatternPathSegment> pathSegments)
    {
        Debug.Assert(defaults != null);
        Debug.Assert(parameterPolicies != null);
        Debug.Assert(parameters != null);
        Debug.Assert(requiredValues != null);
        Debug.Assert(pathSegments != null);
 
        RawText = rawText;
        Defaults = defaults;
        ParameterPolicies = parameterPolicies;
        RequiredValues = requiredValues;
        Parameters = parameters;
        PathSegments = pathSegments;
 
        // 计算得到两个方向的路由权重
        // 模式匹配的规则：
        // 入站路由权重越低，优先级越高
        // 出站路由权重越高，优先级越高
        // 入站权重的计算规则：
        // 1. 静态文本部分权重为 1
        // 2. 参数部分权重为 3
        // 3. 带路由约束的参数部分权重为 2
        // 比如 literal/{parameter1}/{parameter2:int} 这个路由模板的入站权重为 1.32
        // 出站权重的计算规则：
        // 1. 静态文本部分权重为 5
        // 2. 参数部分权重为 3
        // 3. 带路由约束的参数部分权重为 4
        InboundPrecedence = RoutePrecedence.ComputeInbound(this);
        OutboundPrecedence = RoutePrecedence.ComputeOutbound(this);
    }
 
    // 路由模板提供的参数默认值
    public IReadOnlyDictionary<string, object?> Defaults { get; }
 
    // 每个参数可能对应多个策略（约束）
    public IReadOnlyDictionary<string, IReadOnlyList<RoutePatternParameterPolicyReference>> ParameterPolicies { get; }
 
    // 作为出站路由生成 Url 时必须存在的参数值
    public IReadOnlyDictionary<string, object?> RequiredValues { get; }
    
    // 入站路由权重
    public decimal InboundPrecedence { get; }
 
    // 出站路由权重
    public decimal OutboundPrecedence { get; }
    
    // 路由模板原始值
    public string? RawText { get; }
    
    // 路由模板中所有的参数组成部分
    public IReadOnlyList<RoutePatternParameterPart> Parameters { get; }
    
    // 路由模板的所有路径段
    public IReadOnlyList<RoutePatternPathSegment> PathSegments { get; }

    // 获取指定名称的参数部分（不区分大小写）
    public RoutePatternParameterPart? GetParameter(string name)
    {
        ArgumentNullException.ThrowIfNull(name);
 
        var parameters = Parameters;
        var parametersCount = parameters.Count;
        for (var i = 0; i < parametersCount; i++)
        {
            var parameter = parameters[i];
            if (string.Equals(parameter.Name, name, StringComparison.OrdinalIgnoreCase))
            {
                return parameter;
            }
        }
 
        return null;
    }
}
```

## 终结点

- EndpointMetadataCollection

```C#
// 终结点元数据集合
// 这是一个只读集合，在创建时初始化
// 所有元数据在开始时都会保存在同一个数组中
// 在获取对应类型的元数据时，内部会将数组中相同类型的元数据分成一组，并以 Type（一般使用接口类型） 作为 Key 缓存
public sealed class EndpointMetadataCollection : IReadOnlyList<object>
{
    public static readonly EndpointMetadataCollection Empty = new EndpointMetadataCollection(Array.Empty<object>());
 
    private readonly object[] _items;
    private readonly ConcurrentDictionary<Type, object[]> _cache;

    public EndpointMetadataCollection(IEnumerable<object> items)
    {
        ArgumentNullException.ThrowIfNull(items);
 
        _items = items.ToArray();
        _cache = new ConcurrentDictionary<Type, object[]>();
    }
 
    public EndpointMetadataCollection(params object[] items)
        : this((IEnumerable<object>)items)
    {
    }
 
    public object this[int index] => _items[index];
 
    public int Count => _items.Length;

    // 返回对应类型的元数据（相同类型中的最后一个）
    // 如果对应类型的元数据不存在则返回该类型的默认值
    public T? GetMetadata<T>() where T : class
    {
        // 尝试从缓存中获取
        if (_cache.TryGetValue(typeof(T), out var obj))
        {
            var result = (T[])obj;
            var length = result.Length;
            return length > 0 ? result[length - 1] : default;
        }

        // 如果没有缓存则需要创建后再返回
        return GetMetadataSlow<T>();
    }
    
    // 先收集对应类型的元数据并缓存
    // 再返回对应类型的元数据（相同类型中的最后一个）
    private T? GetMetadataSlow<T>() where T : class
    {
        var result = GetOrderedMetadataSlow<T>();
        var length = result.Length;
        return length > 0 ? result[length - 1] : default;
    }
    
    // 返回对应类型的所有元数据
    // 顺序是按元数据在初始化集合中的先后顺序
    public IReadOnlyList<T> GetOrderedMetadata<T>() where T : class
    {
        if (_cache.TryGetValue(typeof(T), out var result))
        {
            return (T[])result;
        }
 
        return GetOrderedMetadataSlow<T>();
    }
 
    // 遍历所有元数据，将相同类型的元数据收集起来并缓存
    private T[] GetOrderedMetadataSlow<T>() where T : class
    {
        List<T>? matches = null;
 
        var items = _items;
        for (var i = 0; i < items.Length; i++)
        {
            if (items[i] is T item)
            {
                matches ??= new List<T>();
                matches.Add(item);
            }
        }
 
        var results = matches == null ? Array.Empty<T>() : matches.ToArray();
        _cache.TryAdd(typeof(T), results);
        return results;
    }
 
    // 必须存在对应类型的元数据
    // 否则抛出 InvalidOperationException
    public T GetRequiredMetadata<T>() where T : class
    {
        var metadata = GetMetadata<T>();
        return metadata ?? throw new InvalidOperationException($"Metadata '{typeof(T)}' is not found.");
    }
 
    public Enumerator GetEnumerator() => new Enumerator(this);
 
    IEnumerator<object> IEnumerable<object>.GetEnumerator() => GetEnumerator();
 
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
 
    public struct Enumerator : IEnumerator<object>
    {
#pragma warning disable IDE0044
        private object[] _items;
#pragma warning restore IDE0044
        private int _index;
        private object? _current;
 
        internal Enumerator(EndpointMetadataCollection collection)
        {
            _items = collection._items;
            _index = 0;
            _current = null;
        }
 
        public object Current => _current!;
 
        public void Dispose()
        {
        }
 
        public bool MoveNext()
        {
            if (_index < _items.Length)
            {
                _current = _items[_index++];
                return true;
            }
 
            _current = null;
            return false;
        }

        public void Reset()
        {
            _index = 0;
            _current = null;
        }
    }
}
```

- Endpoint

```C#
// 终结点
// 它由两个核心成员组成
// 一个请求处理器和一个终结点元数据集合
public class Endpoint
{
    public Endpoint(
        RequestDelegate? requestDelegate,
        EndpointMetadataCollection? metadata,
        string? displayName)
    {
        RequestDelegate = requestDelegate;
        Metadata = metadata ?? EndpointMetadataCollection.Empty;
        // 指定终结点的显示名称
        DisplayName = displayName;
    }
 
    public string? DisplayName { get; }
 
    public EndpointMetadataCollection Metadata { get; }
 
    public RequestDelegate? RequestDelegate { get; }
 
    public override string? ToString() => DisplayName ?? base.ToString();
}
```

- EndpointBuilder

```C#
// 终结点建造者的抽象表示
// 子类通过重写 Build 方法完成具体终结点的创建
public abstract class EndpointBuilder
{
    private List<Func<EndpointFilterFactoryContext, EndpointFilterDelegate, EndpointFilterDelegate>>? _filterFactories;
 
    public IList<Func<EndpointFilterFactoryContext, EndpointFilterDelegate, EndpointFilterDelegate>> FilterFactories => _filterFactories ??= new();
 
    // 收集用于创建终结点的请求处理器
    public RequestDelegate? RequestDelegate { get; set; }
 
    // 收集用于创建终结点的显示名称
    public string? DisplayName { get; set; }
    
    // 收集用于创建终结点的元数据
    // 可以利用这个属性添加元数据
    // 在创建终结点时会利用这个初始化集合创建终结点元数据集合
    public IList<object> Metadata { get; } = new List<object>();
 
    // 返回表示根容器的 IServiceProvider
    // 返回的 EmptyServiceProvider 是一个对所有服务返回 null 的 IServiceProvider 的封装
    public IServiceProvider ApplicationServices { get; init; } = EmptyServiceProvider.Instance;
 
    // 构建终结点
    public abstract Endpoint Build();
 
    private sealed class EmptyServiceProvider : IServiceProvider
    {
        public static EmptyServiceProvider Instance { get; } = new EmptyServiceProvider();
        public object? GetService(Type serviceType) => null;
    }
}
```

- RouteEndpoint

```C#
// 表示路由系统终结点，继承 Endpoint
public sealed class RouteEndpoint : Endpoint
{
    public RouteEndpoint(
        RequestDelegate requestDelegate,
        RoutePattern routePattern,
        int order,
        EndpointMetadataCollection? metadata,
        string? displayName)
        : base(requestDelegate, metadata, displayName)
    {
        ArgumentNullException.ThrowIfNull(requestDelegate);
        ArgumentNullException.ThrowIfNull(routePattern);
 
        RoutePattern = routePattern;
        Order = order;
    }
 
    // 注册顺序
    public int Order { get; }
 
    // 路由模式
    public RoutePattern RoutePattern { get; }
}
```

- RouteEndpointBuilder

```C#
// 表示路由系统终结点建造者，继承 EndpointBuilder
public sealed class RouteEndpointBuilder : EndpointBuilder
{
    // 收集用于创建路由系统终结点的路由模式
    public RoutePattern RoutePattern { get; set; }
 
    // 收集用于创建路由系统终结点的注册顺序
    public int Order { get; set; }
 
    public RouteEndpointBuilder(
       RequestDelegate? requestDelegate,
       RoutePattern routePattern,
       int order)
    {
        ArgumentNullException.ThrowIfNull(routePattern);
 
        RequestDelegate = requestDelegate;
        RoutePattern = routePattern;
        Order = order;
    }
 
    // 构建终结点
    public override Endpoint Build()
    {
        // 必须存在请求处理器
        if (RequestDelegate is null)
        {
            throw new InvalidOperationException($"{nameof(RequestDelegate)} must be specified to construct a {nameof(RouteEndpoint)}.");
        }

        // 创建路由系统终结点
        return new RouteEndpoint(
            RequestDelegate,
            RoutePattern,
            Order,
            CreateMetadataCollection(Metadata, RoutePattern),
            DisplayName);
    }
 
    // 创建终结点元数据集合
    private static EndpointMetadataCollection CreateMetadataCollection(IList<object> metadata, RoutePattern routePattern)
    {
        var hasRouteDiagnosticsMetadata = false;
 
        if (metadata.Count > 0)
        {
            var hasCorsMetadata = false;
            IHttpMethodMetadata? httpMethodMetadata = null;

            // 检查初始化集合中是否存在针对跨域的元数据
            for (var i = 0; i < metadata.Count; i++)
            {
                // 查找 IHttpMethodMetadata 元数据
                if (metadata[i] is IHttpMethodMetadata methodMetadata)
                {
                    httpMethodMetadata = methodMetadata;
                }

                // 查找 ICorsMetadata 元数据
                if (!hasCorsMetadata && metadata[i] is ICorsMetadata)
                {
                    hasCorsMetadata = true;
                }

                // 查找 IRouteDiagnosticsMetadata 元数据
                if (!hasRouteDiagnosticsMetadata && metadata[i] is IRouteDiagnosticsMetadata)
                {
                    hasRouteDiagnosticsMetadata = true;
                }
            }
 
            // ICorsMetadata 元数据和 IHttpMethodMetadata 元数据都存在时
            // 如果 IHttpMethodMetadata 元数据的 AcceptCorsPreflight 属性为 false，则更新为 true
            if (hasCorsMetadata && httpMethodMetadata is not null && !httpMethodMetadata.AcceptCorsPreflight)
            {
                // 允许跨域预检请求
                httpMethodMetadata.AcceptCorsPreflight = true;
            }
        }
        
        // 如果不存在针对路由的诊断日志元数据，则创建一个 RouteDiagnosticsMetadata 作为元数据
        if (!hasRouteDiagnosticsMetadata)
        {
            metadata.Add(new RouteDiagnosticsMetadata(routePattern.DebuggerToString()));
        }
 
        return new EndpointMetadataCollection(metadata);
    }
 
    private sealed class RouteDiagnosticsMetadata : IRouteDiagnosticsMetadata
    {
        public string Route { get; }
 
        public RouteDiagnosticsMetadata(string route)
        {
            Route = route;
        }
 
        public override string ToString()
        {
            return DebuggerHelpers.GetDebugText(nameof(Route), Route);
        }
    }
}
```

- EndpointDataSource

```C#
// 终结点数据源抽象类
// 用于保存多个终结点，以及监控终结点集合的变化
public abstract class EndpointDataSource
{
    // 用来监测终结点集合变化的令牌
    public abstract IChangeToken GetChangeToken();
 
    // 终结点集合
    public abstract IReadOnlyList<Endpoint> Endpoints { get; }
}
```

- DefaultEndpointDataSource

```C#
// 默认的终结点数据源，继承 EndpointDataSource
// 只是简单保存初始化时提供的终结点集合
public sealed class DefaultEndpointDataSource : EndpointDataSource
{
    private readonly IReadOnlyList<Endpoint> _endpoints;
 
    public DefaultEndpointDataSource(params Endpoint[] endpoints)
    {
        ArgumentNullException.ThrowIfNull(endpoints);
 
        _endpoints = (Endpoint[])endpoints.Clone();
    }
 
    public DefaultEndpointDataSource(IEnumerable<Endpoint> endpoints)
    {
        ArgumentNullException.ThrowIfNull(endpoints);
 
        _endpoints = new List<Endpoint>(endpoints);
    }
 
    // 返回不具有监测数据源变化能力的 IChangeToken
    public override IChangeToken GetChangeToken() => NullChangeToken.Singleton;
 
    // 终结点集合
    public override IReadOnlyList<Endpoint> Endpoints => _endpoints;
}
```

- IEndpointConventionBuilder

```C#
// 终结点建造者的约定配置接口
public interface IEndpointConventionBuilder
{
    // 用来添加针对终结点建造者的约定配置
    void Add(Action<EndpointBuilder> convention);
 
    // 用来添加针对中间点建造者的约定终结配置
    // 默认不需要实现
    void Finally(Action<EndpointBuilder> finallyConvention) => throw new NotImplementedException();
}
```

- RoutingEndpointConventionBuilderExtensions

```C#
// 提供 IEndpointConventionBuilder 的扩展方法
// 用来收集终结点建造者的约定配置
public static class RoutingEndpointConventionBuilderExtensions
{
    // 使用指定的名称配置终结点建造者
    public static TBuilder WithDisplayName<TBuilder>(this TBuilder builder, string displayName) where TBuilder : IEndpointConventionBuilder
    {
        ArgumentNullException.ThrowIfNull(builder);
 
        builder.Add(b =>
        {
            b.DisplayName = displayName;
        });
 
        return builder;
    }
 
    // 使用指定的 Func<EndpointBuilder, string> 委托配置终结点建造者
    public static TBuilder WithDisplayName<TBuilder>(this TBuilder builder, Func<EndpointBuilder, string> func) where TBuilder : IEndpointConventionBuilder
    {
        ArgumentNullException.ThrowIfNull(builder);
        ArgumentNullException.ThrowIfNull(func);
 
        builder.Add(b =>
        {
            b.DisplayName = func(b);
        });
 
        return builder;
    }
    
    // 使用指定的元数据配置终结点建造者
    public static TBuilder WithMetadata<TBuilder>(this TBuilder builder, params object[] items) where TBuilder : IEndpointConventionBuilder
    {
        ArgumentNullException.ThrowIfNull(builder);
        ArgumentNullException.ThrowIfNull(items);
 
        builder.Add(b =>
        {
            foreach (var item in items)
            {
                b.Metadata.Add(item);
            }
        });
 
        return builder;
    }
}
```

- DefaultEndpointConventionBuilder

```C#
// 与 ModelEndpointDataSource 配套的 IEndpointConventionBuilder 实现
public class DefaultEndpointConventionBuilder : IEndpointConventionBuilder
{
    // 收集终结点建造者的约定配置列表
    private readonly List<Action<EndpointBuilder>> _conventions
    // 终结点建造者
    internal EndpointBuilder EndpointBuilder { get; }

    public DefaultEndpointConventionBuilder(EndpointBuilder endpointBuilder)
    {
        EndpointBuilder = endpointBuilder;
        _conventions = new List<Action<EndpointBuilder>>();
    }

    // 实现 IEndpointConventionBuilder
    public void Add(Action<EndpointBuilder> convention)
    {
        ArgumentNullException.ThrowIfNull(convention);

        _conventions.Add(convention);
    }

    // 构建终结点
    // 先利用约定配置配置终结点建造者
    // 再利用终结点建造者创建终结点
    public Endpoint Build()
    {
        // 遍历所有约定配置
        foreach (var convention in _conventions)
        {
            // 配置终结点建造者
            convention(EndpointBuilder);
        }

        return EndpointBuilder.Build();
    }
}
```

- ModelEndpointDataSource

```C#
// 与 DefaultEndpointConventionBuilder 配套的 EndpointDataSource 子类
public class ModelEndpointDataSource : EndpointDataSource
{
    private List<DefaultEndpointConventionBuilder> _endpointConventionBuilders;

    public ModelEndpointDataSource()
    {
        _endpointConventionBuilders = new List<DefaultEndpointConventionBuilder>();
    }

    // 添加终结点建造者，并为每个终结点建造者创建一个 DefaultEndpointConventionBuilder
    public IEndpointConventionBuilder AddEndpointBuilder(EndpointBuilder endpointBuilder)
    {
        ArgumentNullException.ThrowIfNull(endpointBuilder);

        var builder = new DefaultEndpointConventionBuilder(endpointBuilder);
        _endpointConventionBuilders.Add(builder);
        return builder;
    }

    // 返回不具有监测数据源变化能力的 IChangeToken
    public override IChangeToken GetChangeToken() => NullChangeToken.Singleton;

    // 利用每个 DefaultEndpointConventionBuilder 创建终结点
    public override IReadOnlyList<Endpoint> Endpoints => _endpointConventionBuilders.Select(b => b.Build()).ToArray();
}
```

- CompositeEndpointDataSource

```C#
// 表示混合的 EndpointDataSource，可以保存多个不同的 EndpointDataSource
// EndpointRoutingMiddleware 中间件会将 IEndpointRouteBuilder 中所有注册的 EndpointDataSource 转移到 CompositeEndpointDataSource 中
public sealed class CompositeEndpointDataSource : EndpointDataSource, IDisposable
{
     private readonly ICollection<EndpointDataSource> _dataSources;
 
    private List<Endpoint>? _endpoints;
    private IChangeToken? _consumerChangeToken;
    private CancellationTokenSource? _cts;
    private List<IDisposable>? _changeTokenRegistrations;
    private bool _disposed;

    public CompositeEndpointDataSource(IEnumerable<EndpointDataSource> endpointDataSources)
    {
        _dataSources = new List<EndpointDataSource>();
 
        foreach (var dataSource in endpointDataSources)
        {
            _dataSources.Add(dataSource);
        }
    }

    public IEnumerable<EndpointDataSource> DataSources => _dataSources;

    // 返回终结点集合
    public override IReadOnlyList<Endpoint> Endpoints
    {
        get
        {
            EnsureEndpointsInitialized();
            return _endpoints;
        }
    }

    // 确保终结点集合已经创建
    // 一般终结点的创建是在首次访问 EndpointDataSource.Endpoints 属性时利用终结点建造者创建终结点
    // 并且一般只会创建一次，除非发生 EndpointDataSource 数据源变化才会重新创建
    // 这个过程在 EndpointRoutingMiddleware 中间件中完成
    private void EnsureEndpointsInitialized()
    {
        if (_endpoints is not null)
        {
            return;
        }
 
        lock (_lock)
        {
            if (_endpoints is not null)
            {
                return;
            }
 
            EnsureChangeTokenInitialized();

            CreateEndpointsUnsynchronized();
        }
    }

    // 创建终结点集合
    // 遍历并合并所有终结点的 EndpointDataSource.Endpoints 
    private void CreateEndpointsUnsynchronized()
    {
        var endpoints = new List<Endpoint>();
 
        foreach (var dataSource in _dataSources)
        {
            endpoints.AddRange(dataSource.Endpoints);
        }
 
        _endpoints = endpoints;
    }

    // 返回 IChangeToken
    public override IChangeToken GetChangeToken()
    {
        EnsureChangeTokenInitialized();
        return _consumerChangeToken;
    }

    // 确保 IChangeToken 已经创建
    private void EnsureChangeTokenInitialized()
    {
        if (_consumerChangeToken is not null)
        {
            return;
        }
 
        lock (_lock)
        {
            if (_consumerChangeToken is not null)
            {
                return;
            }
 
            CreateChangeTokenUnsynchronized(collectionChanged: true);
        }
    }

    // 创建新的 IChangeToken
    // 本质是对每个 EndpointDataSource.GetChangeToken 方法返回的 IChangeToken 注册回调
    // 并对外提供 CancellationChangeToken 这个 IChangeToken 提供回调注册
    private void CreateChangeTokenUnsynchronized(bool collectionChanged)
    {
        var cts = new CancellationTokenSource();
 
        if (collectionChanged)
        {
            _changeTokenRegistrations = new();
            foreach (var dataSource in _dataSources)
            {
                _changeTokenRegistrations.Add(ChangeToken.OnChange(
                    dataSource.GetChangeToken,
                    () => HandleChange(collectionChanged: false)));
            }
        }
 
        _cts = cts;
        _consumerChangeToken = new CancellationChangeToken(cts.Token);
    }
}
```

- RouteHandlerBuilder

```C#
// 与 RouteEndpointDataSource 配套的 IEndpointConventionBuilder 实现
public sealed class RouteHandlerBuilder : IEndpointConventionBuilder
{
    private readonly IEnumerable<IEndpointConventionBuilder>? _endpointConventionBuilders;
    private readonly ICollection<Action<EndpointBuilder>>? _conventions;
    private readonly ICollection<Action<EndpointBuilder>>? _finallyConventions;
 
    internal RouteHandlerBuilder(ICollection<Action<EndpointBuilder>> conventions, ICollection<Action<EndpointBuilder>> finallyConventions)
    {
        _conventions = conventions;
        _finallyConventions = finallyConventions;
    }
 
    public RouteHandlerBuilder(IEnumerable<IEndpointConventionBuilder> endpointConventionBuilders)
    {
        _endpointConventionBuilders = endpointConventionBuilders;
    }
 
    public void Add(Action<EndpointBuilder> convention)
    {
        if (_conventions is not null)
        {
            _conventions.Add(convention);
        }
        else
        {
            foreach (var endpointConventionBuilder in _endpointConventionBuilders!)
            {
                endpointConventionBuilder.Add(convention);
            }
        }
    }
 
    public void Finally(Action<EndpointBuilder> finalConvention)
    {
        if (_finallyConventions is not null)
        {
            _finallyConventions.Add(finalConvention);
        }
        else
        {
            foreach (var endpointConventionBuilder in _endpointConventionBuilders!)
            {
                endpointConventionBuilder.Finally(finalConvention);
            }
        }
    }
}
```

- RouteEndpointDataSource

```C#
// 与 RouteHandlerBuilder 配套的 EndpointDataSource 子类
internal sealed class RouteEndpointDataSource : EndpointDataSource
{
    private readonly List<RouteEntry> _routeEntries = new();

    public RouteEndpointDataSource(IServiceProvider applicationServices, bool throwOnBadRequest)
    {
        _applicationServices = applicationServices;
        _throwOnBadRequest = throwOnBadRequest;
    }

    // 利用路由模板、终结点处理器、Http 方法集合以及一个空的终结点建造者约定配置集合构建 RouteEntry
    // 在使用 RequestDelegate 类型参数作为终结点处理器时使用
    public RouteHandlerBuilder AddRequestDelegate(
        RoutePattern pattern,
        RequestDelegate requestDelegate,
        IEnumerable<string>? httpMethods,
        Func<Delegate, RequestDelegateFactoryOptions, RequestDelegateMetadataResult?, RequestDelegateResult> createHandlerRequestDelegateFunc)
    {
        // 创建空的针对终结点建造者的约定配置集合
        // 用于收集针对终结点建造者的约定配置
        var conventions = new ThrowOnAddAfterEndpointBuiltConventionCollection();
        var finallyConventions = new ThrowOnAddAfterEndpointBuiltConventionCollection();
 
        _routeEntries.Add(new()
        {
            RoutePattern = pattern,
            RouteHandler = requestDelegate,
            HttpMethods = httpMethods,
            RouteAttributes = RouteAttributes.None,
            Conventions = conventions,
            FinallyConventions = finallyConventions,
            InferMetadataFunc = null,
            CreateHandlerRequestDelegateFunc = createHandlerRequestDelegateFunc
        });

        // 利用约定配置集合创建 RouteHandlerBuilder 并返回
        return new RouteHandlerBuilder(conventions, finallyConventions);
    }

    // 任意委托类型的终结点处理器最终会被封装为标准的 RequestDelegate 
    // 但在内部涉及到两个核心功能
    // 1. 对任意委托类型原型方法的参数绑定
    // 2. 对任意委托类型原型方法的返回值处理
    //    在处理返回值时，无论返回值是何种类型，最终都会被转换为 ValueTask<IResult>
    //    然后再调用 IResult.ExecuteAsync 方法完成最终的结果响应
    // 参数绑定规则：
    // 1. HttpContext 类型绑定为当前 HttpContext 上下文
    // 2. HttpRequest 类型绑定为当前 HttpContext 上下文的 Request 属性
    // 3. HttpResponse 类型绑定为当前 HttpContext 上下文的 Response 属性
    // 4. ClaimsPrincipal 类型绑定为当前 HttpContext 上下文的 User 属性
    // 5. CancellationToken 类型绑定为当前 HttpContext 上下文的 RequestAborted 属性
    // 6. 基元类型优先绑定同名（忽略大小写）的路由参数值
    //    在 EndpointRoutingMiddleware 中间件匹配出最佳终结点后可以通过 HttpContext.GetRouteData().Values 获取到路由参数值字典
    //    也可以通过为参数显式绑定 FromRouteAttribute（实现 IFromRouteMetadata） 特性的方式指定绑定源
    //    这属于默认绑定策略
    // 7. 如果路由参数中没有匹配到，则绑定同名（忽略大小写）的查询字符串值
    //    也可以通过为参数显式绑定 FromQueryAttribute（实现 IFromQueryMetadata） 特性的方式指定绑定源
    //    这属于默认绑定策略
    // 8. 可以通过为参数显式绑定 FromHeaderAttribute（实现 IFromHeaderMetadata） 特性的方式指定绑定源
    //    这不属于默认绑定策略
    // 9. 可以通过为参数显式绑定 FromServicesAttribute（实现 IFromServicesMetadata） 特性的方式
    //    根据参数类型利用表示每个请求的范围容器创建对应实例
    //    这不属于默认绑定策略
    // 10.复杂类型会使用请求的主体内容（Json 字符串）反序列化为对应类型的实例
    //    也可以通过为参数显式绑定 FromBodyAttribute（实现 IFromBodyMetadata） 特性的方式指定绑定源
    //    这属于默认绑定策略
    // 11.IFormFileCollection 或 IFormFile 类型，则绑定为当前请求的表单文件集合或表单文件
    //    也可以通过为参数显式绑定 FromFormAttribute（实现 IFromFormMetadata） 特性的方式指定绑定源
    //    这属于默认绑定策略
    // 返回值处理规则：
    // 采用类似如下代码转换为 ValueTask<IResult>
    // public ValueTask<IResult> ConvertAsync(object? result)
    // {
    //     if (result == null)
    //     {
    //         // EmptyHttpResult.ExecuteAsync 方法的实现只是简单的返回 Task.CompletedTask
    //         return ValueTask.FromResult<IResult>(EmptyHttpResult.Instance);
    //     }
    //
    //     if (result is Task<IResult> taskOfResult)
    //     {
    //         return new ValueTask<IResult>(taskOfResult);
    //     }
    //
    //     if (result is ValueTask<IResult> valueTaskOfResult)
    //     {
    //         return valueTaskOfResult;
    //     }
    //
    //     if (result is IResult result)
    //     {
    //         return ValueTask.FromResult<IResult>(result);
    //     }
    //     
    //     // 由于 Task<T> 继承 Task，所以此处不能使用 is 操作符
    //     if (result.GetType() == typeof(Task))
    //     {
    //         return Convert((Task)result);
    //     }
    //
    //     if (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition() == typeof(Task<>))
    //     {
    //         // 先将 object 转换为 Task<T>
    //         // 再调用 ConvertFromTask<T> 方法返回 ValueTask<IResult>
    //         // 以上操作可以使用表达式树方式生成动态代码完成
    //     }
    // 
    //     if (result.GetType().IsGenericType && result.GetType().GetGenericTypeDefinition() == typeof(ValueTask<>))
    //     {
    //         // 先将 object 转换为 ValueTask<T>
    //         // 再调用 ConvertFromValueTask<T> 方法返回 ValueTask<IResult>
    //         // 以上操作可以使用表达式树方式生成动态代码完成
    //     }
    //
    //     return ValueTask.FromResult<IResult>(new ObjectResult(result));
    //
    //     private static async ValueTask<IResult> Convert(Task task)
    //     {
    //         await task;
    //         return EmptyHttpResult.Instance;
    //     }
    //
    //     public static async ValueTask<IResult> ConvertFromTask<T>(Task<T> task)
    //     {
    //        T result = await task;
    //        return result is IResult ? result : new ObjectResult(result);
    //     }
    //
    //     public static async ValueTask<IResult> ConvertFromValueTask<T>(ValueTask<T> valueTask)
    //     {
    //        T result = valueTask.IsCompleted ? valueTask.Result : await valueTask;
    //        return result is IResult ? result : new ObjectResult(result);
    //     }
    //     
    //     public class ObjectResult : IResult
    //     {
    //         public ObjectResult(object? value)
    //         {
    //             Value = value;                
    //         }
    //
    //         public object? Value { get; }
    //
    //        public Task ExecuteAsync(HttpContext httpContext)
    //        {  
    //            // 如果是 Value 是 string 类型
    //            // 则将原始字符串直接作为响应主体，并将 Content-Type 设置为 text/plain
    //            // 否则需要先做 Json 序列化处理后再将 Json 字符串作为响应主体，并将 Content-Type 设置为 application/json
    //        }
    //     {
    // }

    // 利用路由模板、任意委托类型表示的终结点处理器、Http 方法集合以及一个空的终结点建造者约定配置集合构建 RouteEntry
    // 在使用任意委托类型参数作为终结点处理器时使用
    public RouteHandlerBuilder AddRouteHandler(
        RoutePattern pattern,
        Delegate routeHandler,
        IEnumerable<string>? httpMethods,
        bool isFallback,
        Func<MethodInfo, RequestDelegateFactoryOptions?, RequestDelegateMetadataResult>? inferMetadataFunc,
        Func<Delegate, RequestDelegateFactoryOptions, RequestDelegateMetadataResult?, RequestDelegateResult> createHandlerRequestDelegateFunc)
    {
        // 创建空的针对终结点建造者的约定配置集合
        // 用于收集针对终结点建造者的约定配置
        var conventions = new ThrowOnAddAfterEndpointBuiltConventionCollection();
        var finallyConventions = new ThrowOnAddAfterEndpointBuiltConventionCollection();
 
        var routeAttributes = RouteAttributes.RouteHandler;
        if (isFallback)
        {
            routeAttributes |= RouteAttributes.Fallback;
        }
 
        _routeEntries.Add(new()
        {
            RoutePattern = pattern,
            RouteHandler = routeHandler,
            HttpMethods = httpMethods,
            RouteAttributes = routeAttributes,
            Conventions = conventions,
            FinallyConventions = finallyConventions,
            InferMetadataFunc = inferMetadataFunc,
            CreateHandlerRequestDelegateFunc = createHandlerRequestDelegateFunc
        });

        // 利用约定配置集合创建 RouteHandlerBuilder 并返回
        return new RouteHandlerBuilder(conventions, finallyConventions);
    }

    // 返回不具有监测功能的 IChangeToken
    public override IChangeToken GetChangeToken() => NullChangeToken.Singleton;

    // 创建并返回终结点集合
    // 此处返回类型不是 IReadOnlyList<Endpoint> 是利用了泛型接口的协变
    public override IReadOnlyList<RouteEndpoint> Endpoints
    {
        get
        {
            var endpoints = new RouteEndpoint[_routeEntries.Count];
            for (int i = 0; i < _routeEntries.Count; i++)
            {
                // 利用路由系统终结点建造者创建路由系统终结点
                endpoints[i] = (RouteEndpoint)CreateRouteEndpointBuilder(_routeEntries[i]).Build();
            }
            return endpoints;
        }
    }

    // 创建路由系统终结点建造者
    private RouteEndpointBuilder CreateRouteEndpointBuilder(
        RouteEntry entry, RoutePattern? groupPrefix = null, IReadOnlyList<Action<EndpointBuilder>>? groupConventions = null, IReadOnlyList<Action<EndpointBuilder>>? groupFinallyConventions = null)
    {
        var pattern = RoutePatternFactory.Combine(groupPrefix, entry.RoutePattern);
        var handler = entry.RouteHandler;
        // 确定是否使用任意委托类型作为终结点处理器
        var isRouteHandler = (entry.RouteAttributes & RouteAttributes.RouteHandler) == RouteAttributes.RouteHandler;
        var isFallback = (entry.RouteAttributes & RouteAttributes.Fallback) == RouteAttributes.Fallback;
 
        var order = isFallback ? int.MaxValue : 0;
        // 使用路由模式中的路有模板原始字符串作为终结点显示名称
        var displayName = pattern.DebuggerToString();

        // 如果使用任意委托类型作为终结点处理器，则在显示名称中添加这个委托原型方法的名称
        if (isRouteHandler && TypeHelper.TryGetNonCompilerGeneratedMethodName(handler.Method, out var methodName))
        {
            displayName = $"{displayName} => {methodName}";
        }

        // 如果 Http 方法集合不为 null
        // 则显示名称尝试添加 "HTTP: {方法谓词}" 作为前缀
        // 如果存在多个 Http 方法，则使用 "," 分隔符拼接显示
        if (entry.HttpMethods is not null)
        {
            displayName = $"HTTP: {string.Join(", ", entry.HttpMethods)} {displayName}";
        }
 
        if (isFallback)
        {
            displayName = $"Fallback {displayName}";
        }
 
        // 确定添加的终结点处理器是否是 RequestDelegate 类型
        RequestDelegate? factoryCreatedRequestDelegate = isRouteHandler ? null : (RequestDelegate)entry.RouteHandler;

        // 包装一个新的 RequestDelegate
        // 用于在内部检查是否真正存在一个终结点处理器
        RequestDelegate redirectRequestDelegate = context =>
        {
            if (factoryCreatedRequestDelegate is null)
            {
                throw new InvalidOperationException(Resources.RouteEndpointDataSource_RequestDelegateCannotBeCalledBeforeBuild);
            }
 
            return factoryCreatedRequestDelegate(context);
        };
 
        // 利用终结点处理器、路由模式、序号创建路由系统终结点建造者
        RouteEndpointBuilder builder = new(redirectRequestDelegate, pattern, order)
        {
            DisplayName = displayName,
            ApplicationServices = _applicationServices,
        };
 
        if (isFallback)
        {
            builder.Metadata.Add(FallbackMetadata.Instance);
        }
        
        // 使用任意委托类型作为终结点处理器时将原型方法的 MethodInfo 添加到终结点建造者的元数据集合中
        if (isRouteHandler)
        {
            builder.Metadata.Add(handler.Method);
        }

        // 使用 HttpMethodMetadata 将 Http 方法集合添加到终结点建造者的元数据集合中
        if (entry.HttpMethods is not null)
        {
            builder.Metadata.Add(new HttpMethodMetadata(entry.HttpMethods));
        }
 
        if (groupConventions is not null)
        {
            foreach (var groupConvention in groupConventions)
            {
                groupConvention(builder);
            }
        }
 
        RequestDelegateFactoryOptions? rdfOptions = null;
        RequestDelegateMetadataResult? rdfMetadataResult = null;
 
        // 如果使用任意委托类型作为终结点处理器
        // 则创建 RequestDelegateFactoryOptions 和 RequestDelegateMetadataResult
        if (isRouteHandler)
        {
            Debug.Assert(entry.InferMetadataFunc != null, "A func to infer metadata must be provided for route handlers.");
 
            rdfOptions = CreateRdfOptions(entry, pattern, builder);
            rdfMetadataResult = entry.InferMetadataFunc(entry.RouteHandler.Method, rdfOptions);
        }
 
        // 尝试从终结点处理器委托的原型方法上获取特性
        // 将特性添加到终结点建造者的元数据集合上
        var attributes = handler.Method.GetCustomAttributes();
        if (attributes is not null)
        {
            foreach (var attribute in attributes)
            {
                builder.Metadata.Add(attribute);
            }
        }
 
        entry.Conventions.IsReadOnly = true;
        // 利用收集到的约定配置配置终结点建造者
        foreach (var entrySpecificConvention in entry.Conventions)
        {
            entrySpecificConvention(builder);
        }
 
        // 约定配置可能修改终结点建造者保存的终结点处理器
        var conventionOverriddenRequestDelegate = ReferenceEquals(builder.RequestDelegate, redirectRequestDelegate) ? null : builder.RequestDelegate;
 
        if (isRouteHandler || builder.FilterFactories.Count > 0)
        {
            rdfOptions ??= CreateRdfOptions(entry, pattern, builder);
 
            // 利用 RequestDelegateFactory 将任意委托类型的终结点处理器转换为标准的 RequestDelegate
            factoryCreatedRequestDelegate = entry.CreateHandlerRequestDelegateFunc(entry.RouteHandler, rdfOptions, rdfMetadataResult).RequestDelegate;
        }
 
        Debug.Assert(factoryCreatedRequestDelegate is not null);
 
        // 更新终结点建造者保存的 RequestDelegate
        builder.RequestDelegate = conventionOverriddenRequestDelegate ?? factoryCreatedRequestDelegate;
 
        entry.FinallyConventions.IsReadOnly = true;
        foreach (var entryFinallyConvention in entry.FinallyConventions)
        {
            entryFinallyConvention(builder);
        }
 
        if (groupFinallyConventions is not null)
        {
            foreach (var groupFinallyConvention in groupFinallyConventions)
            {
                groupFinallyConvention(builder);
            }
        }
 
        return builder;
    }

    // 终结点建造者约定配置集合
    private sealed class ThrowOnAddAfterEndpointBuiltConventionCollection : List<Action<EndpointBuilder>>, ICollection<Action<EndpointBuilder>>
    {
        public bool IsReadOnly { get; set; }
 
        void ICollection<Action<EndpointBuilder>>.Add(Action<EndpointBuilder> convention)
        {
            if (IsReadOnly)
            {
                throw new InvalidOperationException(Resources.RouteEndpointDataSource_ConventionsCannotBeModifiedAfterBuild);
            }
 
            Add(convention);
        }
    }
}
```

- IEndpointRouteBuilder

```C#
// 终结点路由建造者接口
// IEndpointRouteBuilder 的核心功能就是用来注册 EndpointDataSource
public interface IEndpointRouteBuilder
{
    // 创建一个新的 IApplicationBuilder
    // 有些终结点的处理可能涉及一个复杂的过程，需要由多个请求处理器协作完成
    // 这时候就需要利用 IApplicationBuilder 注册中间件并调用 IApplicationBuilder.Build 方法构建请求处理委托链
    // 并返回头部的请求处理器作为终结点处理器
    IApplicationBuilder CreateApplicationBuilder();
    
    // 表示根容器的 IServiceProvider
    IServiceProvider ServiceProvider { get; }
    
    // 注册的所有 EndpointDataSource
    ICollection<EndpointDataSource> DataSources { get; }
}
```

- DefaultEndpointRouteBuilder

```C#
// IEndpointRouteBuilder 的默认实现，也是 IHost/IHostBuilder 编程模型中使用的 IEndpointRouteBuilder 实现
// 而在 Minimal API 编程模型中则使用 WebApplication 作为 IEndpointRouteBuilder 实现
internal sealed class DefaultEndpointRouteBuilder : IEndpointRouteBuilder
{
    public DefaultEndpointRouteBuilder(IApplicationBuilder applicationBuilder)
    {
        ApplicationBuilder = applicationBuilder ?? throw new ArgumentNullException(nameof(applicationBuilder));
        DataSources = new List<EndpointDataSource>();
    }
 
    public IApplicationBuilder ApplicationBuilder { get; }
 
    public IApplicationBuilder CreateApplicationBuilder() => ApplicationBuilder.New();
 
    public ICollection<EndpointDataSource> DataSources { get; }
 
    public IServiceProvider ServiceProvider => ApplicationBuilder.ApplicationServices;
}
```

## 中间件

- IEndpointFeature

```C#
// 表示终结点特性接口
public interface IEndpointFeature
{
    Endpoint? Endpoint { get; set; }
}
```

- EndpointHttpContextExtensions

```C#
public static class EndpointHttpContextExtensions
{
    // 从 HttpContext.Features 特性集合中得到 IEndpointFeature 特性
    // 并从 IEndpointFeature.Endpoint 属性中获取终结点
    public static Endpoint? GetEndpoint(this HttpContext context)
    {
        ArgumentNullException.ThrowIfNull(context);
 
        return context.Features.Get<IEndpointFeature>()?.Endpoint;
    }
 
    // 从 HttpContext.Features 特性集合中得到 IEndpointFeature 特性
    // 并将终结点保存到 IEndpointFeature.Endpoint 属性中
    public static void SetEndpoint(this HttpContext context, Endpoint? endpoint)
    {
        ArgumentNullException.ThrowIfNull(context);
 
        var feature = context.Features.Get<IEndpointFeature>();
 
        if (endpoint != null)
        {
            if (feature == null)
            {
                feature = new EndpointFeature();
                context.Features.Set(feature);
            }
 
            feature.Endpoint = endpoint;
        }
        else
        {
            if (feature == null)
            {
                return;
            }
 
            feature.Endpoint = null;
        }
    }
    
    // IEndpointFeature 默认实现
    private sealed class EndpointFeature : IEndpointFeature
    {
        public Endpoint? Endpoint { get; set; }
    }
}
```

- EndpointRoutingApplicationBuilderExtensions

```C#
// 提供用来注册 EndpointRoutingMiddleware 和 EndpointMiddleware 中间件的扩展方法
public static class EndpointRoutingApplicationBuilderExtensions
{
    private const string GlobalEndpointRouteBuilderKey = "__GlobalEndpointRouteBuilder";
    private const string EndpointRouteBuilder = "__EndpointRouteBuilder";
    private const string UseRoutingKey = "__UseRouting";

    // 注册 EndpointRoutingMiddleware 中间件
    public static IApplicationBuilder UseRouting(this IApplicationBuilder builder)
    {
        ArgumentNullException.ThrowIfNull(builder);

        // 确保 EndpointRoutingMiddleware 中间件所需的服务已经注册
        // 即已经调用过 IServiceCollection.AddRouting 扩展方法
        VerifyRoutingServicesAreRegistered(builder);
 
        IEndpointRouteBuilder endpointRouteBuilder;
        // 尝试以 "__GlobalEndpointRouteBuilder" 为 Key 从 IApplicationBuilder 的共享字典中得到表示全局的 IEndpointRouteBuilder
        // 如果使用 Minimal API 编程模型，则 WebApplication 就是这个全局的 IEndpointRouteBuilder
        if (builder.Properties.TryGetValue(GlobalEndpointRouteBuilderKey, out var obj))
        {
            endpointRouteBuilder = (IEndpointRouteBuilder)obj!;
            // 将全局的 IEndpointRouteBuilder 以 "__EndpointRouteBuilder" 为 Key 添加到 IApplicationBuilder 的共享字典中
            builder.Properties[EndpointRouteBuilder] = endpointRouteBuilder;
        }
        else
        {
            // 如果使用的是 IHostBuilder 编程模型则创建一个 DefaultEndpointRouteBuilder 作为 IEndpointRouteBuilder
            endpointRouteBuilder = new DefaultEndpointRouteBuilder(builder);
            // 将 DefaultEndpointRouteBuilder 以 "__EndpointRouteBuilder" 为 Key 添加到 IApplicationBuilder 的共享字典中
            builder.Properties[EndpointRouteBuilder] = endpointRouteBuilder;
        }
 
        // 将 UseRouting 方法以 "__UseRouting" 为 Key 添加到 IApplicationBuilder 的共享字典中
        // 标记已经完成 EndpointRoutingMiddleware 中间件注册
        builder.Properties.TryAdd(UseRoutingKey, (object)UseRouting);

        // 注册 EndpointRoutingMiddleware 中间件
        // 并将得到的 IEndpointRouteBuilder 作为外部参数，用于创建 EndpointRoutingMiddleware 中间件时构造函数参数
        return builder.UseMiddleware<EndpointRoutingMiddleware>(endpointRouteBuilder);
    }

    // 注册 EndpointMiddleware 中间件
    public static IApplicationBuilder UseEndpoints(this IApplicationBuilder builder, Action<IEndpointRouteBuilder> configure)
    {
        ArgumentNullException.ThrowIfNull(builder);
        ArgumentNullException.ThrowIfNull(configure);
    
        // 确保 EndpointRoutingMiddleware 中间件所需的服务已经注册
        // 即已经调用过 IServiceCollection.AddRouting 扩展方法
        VerifyRoutingServicesAreRegistered(builder);
 
        // 尝试以 "__EndpointRouteBuilder" 为 Key 从 IApplicationBuilder 的共享字典中得到 IEndpointRouteBuilder
        VerifyEndpointRoutingMiddlewareIsRegistered(builder, out var endpointRouteBuilder);
 
        // 利用 IEndpointRouteBuilder 执行配置注册 EndpointDataSource
        // 在 Minimal API 编程模型中会传递一个什么也不做的空配置
        configure(endpointRouteBuilder);
 
        // 利用表示根容器的 IServiceProvider 得到 RouteOptions 选项
        // 并将所有利用 IEndpointRouteBuilder 注册的 EndpointDataSource 添加到 RouteOptions.EndpointDataSources 这个全局集合中
        var routeOptions = builder.ApplicationServices.GetRequiredService<IOptions<RouteOptions>>();
        foreach (var dataSource in endpointRouteBuilder.DataSources)
        {
            if (!routeOptions.Value.EndpointDataSources.Contains(dataSource))
            {
                routeOptions.Value.EndpointDataSources.Add(dataSource);
            }
        }

        // 注册 EndpointMiddleware 中间件
        return builder.UseMiddleware<EndpointMiddleware>();
    }

    // 利用表示根容器的 IServiceProvider 尝试得到 RoutingMarkerService 类型的服务
    // 如果存在表明已经调用过 IServiceCollection.AddRouting 扩展方法完成路由系统相关的服务注册
    private static void VerifyRoutingServicesAreRegistered(IApplicationBuilder app)
    {
        if (app.ApplicationServices.GetService(typeof(RoutingMarkerService)) == null)
        {
            throw new InvalidOperationException(Resources.FormatUnableToFindServices(
                nameof(IServiceCollection),
                nameof(RoutingServiceCollectionExtensions.AddRouting),
                "ConfigureServices(...)"));
        }
    }
    
    // 尝试以 "__EndpointRouteBuilder" 为 Key 从 IApplicationBuilder 的共享字典中得到 IEndpointRouteBuilder
    // 如果存在表明已经完成 EndpointRoutingMiddleware 中间件的注册，并通过输出参数返回
    private static void VerifyEndpointRoutingMiddlewareIsRegistered(IApplicationBuilder app, out IEndpointRouteBuilder endpointRouteBuilder)
    {
        if (!app.Properties.TryGetValue(EndpointRouteBuilder, out var obj))
        {
            var message =
                $"{nameof(EndpointRoutingMiddleware)} matches endpoints setup by {nameof(EndpointMiddleware)} and so must be added to the request " +
                $"execution pipeline before {nameof(EndpointMiddleware)}. " +
                $"Please add {nameof(EndpointRoutingMiddleware)} by calling '{nameof(IApplicationBuilder)}.{nameof(UseRouting)}' inside the call " +
                $"to 'Configure(...)' in the application startup code.";
            throw new InvalidOperationException(message);
        }
 
        endpointRouteBuilder = (IEndpointRouteBuilder)obj!;
 
        if (endpointRouteBuilder is DefaultEndpointRouteBuilder defaultRouteBuilder && !object.ReferenceEquals(app, defaultRouteBuilder.ApplicationBuilder))
        {
            var message =
                $"The {nameof(EndpointRoutingMiddleware)} and {nameof(EndpointMiddleware)} must be added to the same {nameof(IApplicationBuilder)} instance. " +
                $"To use Endpoint Routing with 'Map(...)', make sure to call '{nameof(IApplicationBuilder)}.{nameof(UseRouting)}' before " +
                $"'{nameof(IApplicationBuilder)}.{nameof(UseEndpoints)}' for each branch of the middleware pipeline.";
            throw new InvalidOperationException(message);
        }
    }
}
```

- EndpointRoutingMiddleware

```C#
// EndpointRoutingMiddleware 中间件
internal sealed partial class EndpointRoutingMiddleware
{
    private const string DiagnosticsEndpointMatchedKey = "Microsoft.AspNetCore.Routing.EndpointMatched";
 
    private readonly MatcherFactory _matcherFactory;
    private readonly ILogger _logger;
    private readonly EndpointDataSource _endpointDataSource;
    private readonly DiagnosticListener _diagnosticListener;
    private readonly RoutingMetrics _metrics;
    private readonly RequestDelegate _next;
    private readonly RouteOptions _routeOptions;
    private Task<Matcher>? _initializationTask;

    public EndpointRoutingMiddleware(
        MatcherFactory matcherFactory,
        ILogger<EndpointRoutingMiddleware> logger,
        IEndpointRouteBuilder endpointRouteBuilder,
        EndpointDataSource rootCompositeEndpointDataSource,
        DiagnosticListener diagnosticListener,
        IOptions<RouteOptions> routeOptions,
        RoutingMetrics metrics,
        RequestDelegate next)
    {
        ArgumentNullException.ThrowIfNull(endpointRouteBuilder);
 
        // 注入的 MatcherFactory 服务的实现类型是 DfaMatcherFactory
        _matcherFactory = matcherFactory ?? throw new ArgumentNullException(nameof(matcherFactory));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _diagnosticListener = diagnosticListener ?? throw new ArgumentNullException(nameof(diagnosticListener));
        _metrics = metrics;
        _next = next ?? throw new ArgumentNullException(nameof(next));
        _routeOptions = routeOptions.Value;
 
        _ = rootCompositeEndpointDataSource;
        // 将 IEndpointRouteBuilder 中注册的 EndpointDataSource 转移到 CompositeEndpointDataSource 中
        _endpointDataSource = new CompositeEndpointDataSource(endpointRouteBuilder.DataSources);
    }

    public Task Invoke(HttpContext httpContext)
    {
        // 从 HttpContext.Features 特性集合中尝试得到 IEndpointFeature 特性
        var endpoint = httpContext.GetEndpoint();
        // 如果存在 IEndpointFeature 特性
        // 说明已经有中间件匹配到了对应的 Endpoint
        // 这时候就要跳过匹配交由后续中间件处理
        // 这种情况是可能发送的，比如重复注册了 EndpointRoutingMiddleware 中间件
        if (endpoint != null)
        {
            Log.MatchSkipped(_logger, endpoint);
            return _next(httpContext);
        }

        // 创建 Matcher
        var matcherTask = InitializeAsync();
        if (!matcherTask.IsCompletedSuccessfully)
        {
            // 创建 Matcher 的过程如果没有同步完成时使用异步非阻塞方式处理
            return AwaitMatcher(this, httpContext, matcherTask);
        }
 
        // 使用 Matcher 匹配找到对应的 Endpoint
        // 最后将 Endpoint 利用 IEndpointFeature 封装后添加到 HttpContext.Features 特性集合中
        var matchTask = matcherTask.Result.MatchAsync(httpContext);
        if (!matchTask.IsCompletedSuccessfully)
        {
            // 匹配的过程如果没有同步完成时使用异步非阻塞方式处理
            return AwaitMatch(this, httpContext, matchTask);
        }
        
        // 同步完成创建 Matcher 与匹配 Endpoint 工作后交由后续中间件处理
        return SetRoutingAndContinue(httpContext);
 
        static async Task AwaitMatcher(EndpointRoutingMiddleware middleware, HttpContext httpContext, Task<Matcher> matcherTask)
        {
            var matcher = await matcherTask;
            await matcher.MatchAsync(httpContext);
            await middleware.SetRoutingAndContinue(httpContext);
        }
 
        static async Task AwaitMatch(EndpointRoutingMiddleware middleware, HttpContext httpContext, Task matchTask)
        {
            await matchTask;
            await middleware.SetRoutingAndContinue(httpContext);
        }
    }

    // 利用 MatcherFactory 创建 Matcher 并缓存在 Task<Matcher> 中避免重复创建
    private Task<Matcher> InitializeAsync()
    {
        var initializationTask = _initializationTask;
        if (initializationTask != null)
        {
            return initializationTask;
        }
 
        return InitializeCoreAsync();
    }
 
    // 实际创建 Matcher
    private Task<Matcher> InitializeCoreAsync()
    {
        var initialization = new TaskCompletionSource<Matcher>(TaskCreationOptions.RunContinuationsAsynchronously);
        // 创建过程需要保证线程安全，即只有一个线程处理创建任务
        var initializationTask = Interlocked.CompareExchange(ref _initializationTask, initialization.Task, null);
        if (initializationTask != null)
        {
            return initializationTask;
        }
 
        try
        {
            // DfaMatcherFactory 会先创建一个 DataSourceDependentMatcher 
            // 这个 Matcher 并不是最终的 Matcher，只是一个包装器，用于保存 CompositeEndpointDataSource
            // 最终再由 DataSourceDependentMatcher 创建 DfaMatcher
            var matcher = _matcherFactory.CreateMatcher(_endpointDataSource);
 
            _initializationTask = Task.FromResult(matcher);
 
            initialization.SetResult(matcher);
            return initialization.Task;
        }
        catch (Exception ex)
        {
            _initializationTask = null;
 
            initialization.SetException(ex);
            return initialization.Task;
        }
    }

    // 完成一些日志记录工作，并交由后续中间件处理
    private Task SetRoutingAndContinue(HttpContext httpContext)
    {
        var endpoint = httpContext.GetEndpoint();
        if (endpoint == null)
        {
            Log.MatchFailure(_logger);
            _metrics.MatchFailure();
        }
        else
        {
            if (_diagnosticListener.IsEnabled() && _diagnosticListener.IsEnabled(DiagnosticsEndpointMatchedKey))
            {
                Write(_diagnosticListener, httpContext);
            }
 
            if (_logger.IsEnabled(LogLevel.Debug) || _metrics.MatchSuccessCounterEnabled)
            {
                var isFallback = endpoint.Metadata.GetMetadata<FallbackMetadata>() is not null;
 
                Log.MatchSuccess(_logger, endpoint);
 
                if (isFallback)
                {
                    Log.FallbackMatch(_logger, endpoint);
                }
 
                var route = endpoint.Metadata.GetMetadata<IRouteDiagnosticsMetadata>()?.Route ?? "(missing)";
                _metrics.MatchSuccess(route, isFallback);
            }
 
            SetMaxRequestBodySize(httpContext);
 
            var shortCircuitMetadata = endpoint.Metadata.GetMetadata<ShortCircuitMetadata>();
            if (shortCircuitMetadata is not null)
            {
                return ExecuteShortCircuit(shortCircuitMetadata, endpoint, httpContext);
            }
        }
 
        return _next(httpContext);
 
        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern",
            Justification = "The values being passed into Write are being consumed by the application already.")]
        static void Write(DiagnosticListener diagnosticListener, HttpContext httpContext)
        {
            diagnosticListener.Write(DiagnosticsEndpointMatchedKey, httpContext);
        }
    }
}
```

- EndpointMiddleware

```C#
// EndpointMiddleware 中间件
internal sealed partial class EndpointMiddleware
{
    internal const string AuthorizationMiddlewareInvokedKey = "__AuthorizationMiddlewareWithEndpointInvoked";
    internal const string CorsMiddlewareInvokedKey = "__CorsMiddlewareWithEndpointInvoked";
    internal const string AntiforgeryMiddlewareWithEndpointInvokedKey = "__AntiforgeryMiddlewareWithEndpointInvoked";
 
    private readonly ILogger _logger;
    private readonly RequestDelegate _next;
    private readonly RouteOptions _routeOptions;
 
    public EndpointMiddleware(
        ILogger<EndpointMiddleware> logger,
        RequestDelegate next,
        IOptions<RouteOptions> routeOptions)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _next = next ?? throw new ArgumentNullException(nameof(next));
        _routeOptions = routeOptions?.Value ?? throw new ArgumentNullException(nameof(routeOptions));
    }
 
    public Task Invoke(HttpContext httpContext)
    {
        // 从 HttpContext.Features 特性集合中尝试得到 IEndpointFeature 特性中的 Endpoint
        var endpoint = httpContext.GetEndpoint();
        // 一旦找到了 Endpoint，则不会再交由管道中的后续中间件处理
        if (endpoint is not null)
        {
            // 判断 RouteOptints 选项中的 SuppressCheckForUnhandledSecurityMetadata 属性
            // 决定是否需要检查 Endpoint.Metadata 表示的 EndpointMetadataCollection 中相关元数据是否存在以及对应的中间件是否被调用
            if (!_routeOptions.SuppressCheckForUnhandledSecurityMetadata)
            {
                if (endpoint.Metadata.GetMetadata<IAuthorizeData>() is not null &&
                    !httpContext.Items.ContainsKey(AuthorizationMiddlewareInvokedKey))
                {
                    ThrowMissingAuthMiddlewareException(endpoint);
                }
 
                if (endpoint.Metadata.GetMetadata<ICorsMetadata>() is not null &&
                    !httpContext.Items.ContainsKey(CorsMiddlewareInvokedKey))
                {
                    ThrowMissingCorsMiddlewareException(endpoint);
                }
 
                if (endpoint.Metadata.GetMetadata<IAntiforgeryMetadata>() is { RequiresValidation: true } &&
                    !httpContext.Items.ContainsKey(AntiforgeryMiddlewareWithEndpointInvokedKey))
                {
                    ThrowMissingAntiforgeryMiddlewareException(endpoint);
                }
            }

            // 使用 Endpoint.RequestDelegate 表示的请求处理器完成终结点处理
            if (endpoint.RequestDelegate is not null)
            {
                if (!_logger.IsEnabled(LogLevel.Information))
                {
                    return endpoint.RequestDelegate(httpContext);
                }
 
                Log.ExecutingEndpoint(_logger, endpoint);
 
                try
                {
                    var requestTask = endpoint.RequestDelegate(httpContext);
                    if (!requestTask.IsCompletedSuccessfully)
                    {
                        // 如果终结点处理器没有同步完成则使用异步非阻塞方式处理
                        return AwaitRequestTask(endpoint, requestTask, _logger);
                    }
                }
                catch
                {
                    Log.ExecutedEndpoint(_logger, endpoint);
                    throw;
                }
 
                Log.ExecutedEndpoint(_logger, endpoint);
                return Task.CompletedTask;
            }
        }

        // 没有找到 Endpoint 情况下会继续交由管道中的后续中间件处理
        return _next(httpContext);
 
        static async Task AwaitRequestTask(Endpoint endpoint, Task requestTask, ILogger logger)
        {
            try
            {
                await requestTask;
            }
            finally
            {
                Log.ExecutedEndpoint(logger, endpoint);
            }
        }
    }
 
    private static void ThrowMissingAuthMiddlewareException(Endpoint endpoint)
    {
        throw new InvalidOperationException($"Endpoint {endpoint.DisplayName} contains authorization metadata, " +
            "but a middleware was not found that supports authorization." +
            Environment.NewLine +
            "Configure your application startup by adding app.UseAuthorization() in the application startup code. If there are calls to app.UseRouting() and app.UseEndpoints(...), the call to app.UseAuthorization() must go between them.");
    }
 
    private static void ThrowMissingCorsMiddlewareException(Endpoint endpoint)
    {
        throw new InvalidOperationException($"Endpoint {endpoint.DisplayName} contains CORS metadata, " +
            "but a middleware was not found that supports CORS." +
            Environment.NewLine +
            "Configure your application startup by adding app.UseCors() in the application startup code. If there are calls to app.UseRouting() and app.UseEndpoints(...), the call to app.UseCors() must go between them.");
    }
 
    private static void ThrowMissingAntiforgeryMiddlewareException(Endpoint endpoint)
    {
        throw new InvalidOperationException($"Endpoint {endpoint.DisplayName} contains anti-forgery metadata, " +
            "but a middleware was not found that supports anti-forgery." +
            Environment.NewLine +
            "Configure your application startup by adding app.UseAntiforgery() in the application startup code. If there are calls to app.UseRouting() and app.UseEndpoints(...), the call to app.UseAntiforgery() must go between them. " +
            "Calls to app.UseAntiforgery() must be placed after calls to app.UseAuthentication() and app.UseAuthorization().");
    }
 
    private static partial class Log
    {
        [LoggerMessage(0, LogLevel.Information, "Executing endpoint '{EndpointName}'", EventName = "ExecutingEndpoint")]
        public static partial void ExecutingEndpoint(ILogger logger, Endpoint endpointName);
 
        [LoggerMessage(1, LogLevel.Information, "Executed endpoint '{EndpointName}'", EventName = "ExecutedEndpoint")]
        public static partial void ExecutedEndpoint(ILogger logger, Endpoint endpointName);
    }
}
```

## 注册终结点

- EndpointRouteBuilderExtensions

```C#
// 提供用来注册路由系统终结点的扩展方法
public static class EndpointRouteBuilderExtensions
{
    // 相关 Http 方法谓词
    private static readonly string[] GetVerb = new[] { HttpMethods.Get };
    private static readonly string[] PostVerb = new[] { HttpMethods.Post };
    private static readonly string[] PutVerb = new[] { HttpMethods.Put };
    private static readonly string[] DeleteVerb = new[] { HttpMethods.Delete };
    private static readonly string[] PatchVerb = new[] { HttpMethods.Patch };

    // 创建 RouteEndpointDataSource
    internal static RouteEndpointDataSource GetOrAddRouteEndpointDataSource(this IEndpointRouteBuilder endpoints)
    {
        RouteEndpointDataSource? routeEndpointDataSource = null;
 
        // 检查 IEndpointRouteBuilder 中是否已经注册了 RouteEndpointDataSource
        foreach (var dataSource in endpoints.DataSources)
        {
            if (dataSource is RouteEndpointDataSource foundDataSource)
            {
                routeEndpointDataSource = foundDataSource;
                break;
            }
        }

        // 如果没有则创建并添加到 IEndpointRouteBuilder.DataSources 中
        if (routeEndpointDataSource is null)
        {
            // 在利用任意委托作为终结点处理器时存在参数绑定操作
            // 使用 RouteHandlerOptions 选项决定是否在参数绑定失败时响应 400 状态码
            var routeHandlerOptions = endpoints.ServiceProvider?.GetService<IOptions<RouteHandlerOptions>>();
            var throwOnBadRequest = routeHandlerOptions?.Value.ThrowOnBadRequest ?? false;
 
            routeEndpointDataSource = new RouteEndpointDataSource(endpoints.ServiceProvider ?? EmptyServiceProvider.Instance, throwOnBadRequest);
            endpoints.DataSources.Add(routeEndpointDataSource);
        }
 
        return routeEndpointDataSource;
    }

    // 以下是利用 RequestDelegate 类型作为终结点处理器注册路由系统终结点的扩展方法
    // 注意：返回值类型都是 IEndpointConventionBuilder，可以用来注册对 EndpointBuilder 的约定配置

    public static IEndpointConventionBuilder MapGet(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(endpoints, pattern, GetVerb, requestDelegate);
    }
 
    public static IEndpointConventionBuilder MapPost(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(endpoints, pattern, PostVerb, requestDelegate);
    }
 
    public static IEndpointConventionBuilder MapPut(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(endpoints, pattern, PutVerb, requestDelegate);
    }
 
    public static IEndpointConventionBuilder MapDelete(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(endpoints, pattern, DeleteVerb, requestDelegate);
    }
 
    public static IEndpointConventionBuilder MapPatch(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return MapMethods(endpoints, pattern, PatchVerb, requestDelegate);
    }

    // 利用路由模板、终结点处理器、Http 方法谓词集合注册路由系统终结点
    public static IEndpointConventionBuilder MapMethods(
       this IEndpointRouteBuilder endpoints,
       string pattern,
       IEnumerable<string> httpMethods,
       RequestDelegate requestDelegate)
    {
        ArgumentNullException.ThrowIfNull(httpMethods);

        // 需要利用 RoutePatternFactory 先将路由模板解析为 RoutePattern
        return endpoints.Map(RoutePatternFactory.Parse(pattern), requestDelegate, httpMethods);
    }

    public static IEndpointConventionBuilder Map(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        RequestDelegate requestDelegate)
    {
        return Map(endpoints, RoutePatternFactory.Parse(pattern), requestDelegate);
    }
 
    public static IEndpointConventionBuilder Map(
        this IEndpointRouteBuilder endpoints,
        RoutePattern pattern,
        RequestDelegate requestDelegate)
    {
        // Http 方法谓词集合为 null 表示任意 Http 方法
        return Map(endpoints, pattern, requestDelegate, httpMethods: null);
    }
    
    // 这个方法只能使用 RequestDelegate 类型作为终结点处理器
    private static IEndpointConventionBuilder Map(
        this IEndpointRouteBuilder endpoints,
        RoutePattern pattern,
        RequestDelegate requestDelegate,
        IEnumerable<string>? httpMethods)
    {
        ArgumentNullException.ThrowIfNull(endpoints);
        ArgumentNullException.ThrowIfNull(pattern);
        ArgumentNullException.ThrowIfNull(requestDelegate);

        // 利用 RouteEndpointDataSource 注册路由系统终结点构建时需要的路由模式、终结点处理器、Http 方法谓词集合
        return endpoints
            .GetOrAddRouteEndpointDataSource()
            // 只能使用 RequestDelegate 类型作为终结点处理器
            .AddRequestDelegate(pattern, requestDelegate, httpMethods, CreateHandlerRequestDelegate);
    }

    // 以下是利用任意委托类型作为终结点处理器注册路由系统终结点的扩展方法
    // 注意：返回值类型都是 IEndpointConventionBuilder，可以用来注册对 EndpointBuilder 的约定配置

    public static RouteHandlerBuilder MapGet(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate handler)
    {
        return MapMethods(endpoints, pattern, GetVerb, handler);
    }
 
    public static RouteHandlerBuilder MapPost(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate handler)
    {
        return MapMethods(endpoints, pattern, PostVerb, handler);
    }
 
    public static RouteHandlerBuilder MapPut(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate handler)
    {
        return MapMethods(endpoints, pattern, PutVerb, handler);
    }
 
    public static RouteHandlerBuilder MapDelete(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate handler)
    {
        return MapMethods(endpoints, pattern, DeleteVerb, handler);
    }
 
    public static RouteHandlerBuilder MapPatch(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate handler)
    {
        return MapMethods(endpoints, pattern, PatchVerb, handler);
    }

    public static RouteHandlerBuilder MapMethods(
       this IEndpointRouteBuilder endpoints,
       string pattern,
       IEnumerable<string> httpMethods,
       Delegate handler)
    {
        ArgumentNullException.ThrowIfNull(httpMethods);
        return endpoints.Map(RoutePatternFactory.Parse(pattern), handler, httpMethods, isFallback: false);
    }

    public static RouteHandlerBuilder Map(
        this IEndpointRouteBuilder endpoints,
        string pattern,
        Delegate handler)
    {
        return Map(endpoints, RoutePatternFactory.Parse(pattern), handler);
    }
 
    public static RouteHandlerBuilder Map(
        this IEndpointRouteBuilder endpoints,
        RoutePattern pattern,
        Delegate handler)
    {
        return Map(endpoints, pattern, handler, httpMethods: null, isFallback: false);
    }

    // 这个方法可以使用任意委托类型作为终结点处理器
    private static RouteHandlerBuilder Map(
        this IEndpointRouteBuilder endpoints,
        RoutePattern pattern,
        Delegate handler,
        IEnumerable<string>? httpMethods,
        bool isFallback)
    {
        ArgumentNullException.ThrowIfNull(endpoints);
        ArgumentNullException.ThrowIfNull(pattern);
        ArgumentNullException.ThrowIfNull(handler);
 
        return endpoints
            .GetOrAddRouteEndpointDataSource()
            // 可以使用任意委托类型作为终结点处理器
            // 最终会利用 RequestDelegateFactory 将任意委托转换为 RequestDelegate 类型的终结点处理器
            .AddRouteHandler(pattern, handler, httpMethods, isFallback, RequestDelegateFactory.InferMetadata, RequestDelegateFactory.Create);
    }
}
```
