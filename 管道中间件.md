# 管道中间件

## 源码涉及的核心类型

- GenericHostWebHostBuilderExtensions  
- GenericHostBuilderExtensions  
- WebHost  
- WebHostDefaults  
- WebHostOptions  
- IWebHostEnvironment  
- HostingEnvironment  
- IWebHostBuilder  
- ISupportsUseDefaultServiceProvider  
- ISupportsStartup  
- WebHostBuilderBase  
- GenericWebHostBuilder  
- HostingStartupWebHostBuilder  
- WebHostBuilderExtensions  
- IHostingStartup  
- IStartupFilter  
- IApplicationBuilder  
- ApplicationBuilder  
- IApplicationBuilderFactory  
- ApplicationBuilderFactory  
- RunExtensions  
- IMiddleware  
- IMiddlewareFactory  
- MiddlewareFactory  
- UseMiddlewareExtensions  
- HttpContext  
- HttpRequest  
- HttpResponse  
- IFeatureCollection  
- FeatureCollection  
- IHttpContextAccessor  
- HttpContextAccessor  
- HttpServiceCollectionExtensions  
- IHttpContextFactory  
- DefaultHttpContextFactory  
- IServiceProvidersFeature  
- RequestServicesFeature  
- IServer  
- IHttpApplication\<TContext\>  
- HostingApplication  
- GenericWebHostServiceOptions  
- GenericWebHostService  

## ASP.NET Core 服务承载

- GenericHostWebHostBuilderExtensions

```C#
// 宿主建造扩展方法
// 用来配置 IWebHostBuilder
public static class GenericHostWebHostBuilderExtensions
{
    // 添加针对 IWebHostBuilder 的配置
    public static IHostBuilder ConfigureWebHost(this IHostBuilder builder, Action<IWebHostBuilder> configure)
    {
        ArgumentNullException.ThrowIfNull(configure);
 
        return builder.ConfigureWebHost(configure, _ => { });
    }
 
    // 添加针对 IWebHostBuilder 的配置
    // 并接收针对 WebHostBuilderOptions 选项的配置
    // 创建的 IWebHostBuilder 实现类型为 GenericWebHostBuilder
    public static IHostBuilder ConfigureWebHost(this IHostBuilder builder, Action<IWebHostBuilder> configure, Action<WebHostBuilderOptions> configureWebHostBuilder)
    {
        return ConfigureWebHost(
            builder,
            static (hostBuilder, options) => new GenericWebHostBuilder(hostBuilder, options),
            configure,
            configureWebHostBuilder);
    }
    
    // 实际配置 IWebHostBuilder 的扩展方法
    private static IHostBuilder ConfigureWebHost(
        this IHostBuilder builder,
        Func<IHostBuilder, WebHostBuilderOptions, IWebHostBuilder> createWebHostBuilder,
        Action<IWebHostBuilder> configure,
        Action<WebHostBuilderOptions> configureWebHostBuilder)
    {
        ArgumentNullException.ThrowIfNull(configure);
        ArgumentNullException.ThrowIfNull(configureWebHostBuilder);
 
        if (builder is ISupportsConfigureWebHost supportsConfigureWebHost)
        {
            return supportsConfigureWebHost.ConfigureWebHost(configure, configureWebHostBuilder);
        }
 
        var webHostBuilderOptions = new WebHostBuilderOptions();
        // 利用 Action<WebHostBuilderOptions> 配置 WebHostBuilderOptions 选项
        configureWebHostBuilder(webHostBuilderOptions);
        // 利用 IHostBuilder 与 WebHostBuilderOptions 创建 IWebHostBuilder
        var webhostBuilder = createWebHostBuilder(builder, webHostBuilderOptions);
        // 利用 Action<IWebHostBuilder> 配置 IWebHostBuilder
        configure(webhostBuilder);
        // 添加针对服务注册的配置
        // 注册 IHostedService，使用 GenericWebHostService 类型
        builder.ConfigureServices((context, services) => services.AddHostedService<GenericWebHostService>());
        return builder;
    }
}
```

- GenericHostBuilderExtensions

```C#
// 宿主建造扩展方法
// 提供配置默认 IWebHostBuilder 的方法
public static class GenericHostBuilderExtensions
{
    // 使用默认方式配置 IWebHostBuilder
    public static IHostBuilder ConfigureWebHostDefaults(this IHostBuilder builder, Action<IWebHostBuilder> configure)
    {
        ArgumentNullException.ThrowIfNull(configure);
 
        return builder.ConfigureWebHostDefaults(configure, _ => { });
    }
    
    // 使用默认方式配置 IWebHostBuilder
    // 可以提供针对 WebHostBuilderOptions 的配置
    public static IHostBuilder ConfigureWebHostDefaults(this IHostBuilder builder, Action<IWebHostBuilder> configure, Action<WebHostBuilderOptions> configureOptions)
    {
        ArgumentNullException.ThrowIfNull(configure);

        return builder.ConfigureWebHost(webHostBuilder =>
        {
            // 先应用 WebHost.ConfigureWebDefaults 默认配置
            WebHost.ConfigureWebDefaults(webHostBuilder);

            // 再应用自定义配置
            configure(webHostBuilder);
        }, configureOptions);
    }
}
```

- WebHost

```C#
// 静态 WebHost
// 用来配置默认 IWebHostBuilder
public static class WebHost
{
    // 配置默认 IWebHostBuilder
    internal static void ConfigureWebDefaults(IWebHostBuilder builder)
    {
        // 添加针对应用的配置
        builder.ConfigureAppConfiguration((ctx, cb) =>
        {
            // 开发环境下，为 IWebHostEnvironment.WebRootFileProvider 创建新的 CompositeFileProvider
            // 作为后续用来使用静态资源
            // 步骤如下：
            // 1. 尝试从从宿主配置中得到 "staticWebAssets" 配置节表示的静态资源所在目录的路径
            // 2. 如果配置节不存在，则使用 IHostEnvironment.ApplicationName 名称的程序集所在的目录下
            //    "{IWebHostEnvironment.ApplicationName}.staticwebassets.runtime.json" 作为资源文件路径名
            // 3. 读取文件内容并反序列化为 StaticWebAssetManifest 类型对象
            // 4. 遍历对象的 StaticWebAssetManifest.ContentRoots 属性表示的多个静态资源的目录并得到对应的 PhysicalFileProvider
            // 5. 利用所有的 PhysicalFileProvider 和原来的 IWebHostEnvironment.WebRootFileProvider 创建 CompositeFileProvider 
            //    作为 IWebHostEnvironment.WebRootFileProvider 的新值
            if (ctx.HostingEnvironment.IsDevelopment())
            {
                StaticWebAssetsLoader.UseStaticWebAssets(ctx.HostingEnvironment, ctx.Configuration);
            }
        });

        ConfigureWebDefaultsWorker(
            // 使用 Kestrel 作为 Web 服务器
            // 注册 IServer，使用 KestrelServerImpl 类型
            builder.UseKestrel(ConfigureKestrel),
            // 注册路由相关的服务
            services =>
            {
                services.AddRouting();
            });

        // UseIIS 会检查当前操作系统是否为 Windows，并且是否为进程内托管
        // 如果是则使用 IIS 作为 Web 服务器
        // 注册 IServer，使用 IISHttpServer 类型
        // UseIISIntegration 开启 IIS 集成（进程外托管）
        // 此时会启用 IIS 作为反向代理服务器
        // 启用 IIS 作为反向代理服务器的前提是需要从 IWebHostBuilder 的备用配置或环境变量中存在相应的配置值
        // 具体来说需要存在以下配置值：
        // 1. 备用配置中的 "PORT" 配置节存在或环境变量 "ASPNETCORE_PORT" 存在
        // 2. 备用配置中的 "APPL_PATH" 配置节存在或环境变量 "ASPNETCORE_APPL_PATH" 存在
        // 3. 备用配置中的 "TOKEN" 配置节存在或环境变量 "ASPNETCORE_TOKEN" 存在
        // 通过 IIS 启动 ASP.NET Core 应用时会添加环境变量
        // 满足条件时会注册 IISMiddleware 中间件，中间件主要检查请求的来源是否来自 IIS 反向代理服务器
        // 并最终会配置 "http://127.0.0.1:{port}" 环回地址作为 Kestrel 服务器的监听地址
        // 这个配置会延迟在构建服务注册时设置，因为这时候应用配置已经构建完成，保证不会覆盖它
        builder
            .UseIIS()
            .UseIISIntegration();
    }

    // 针对 KestrelServerOptions 的配置方法
    private static void ConfigureKestrel(WebHostBuilderContext builderContext, KestrelServerOptions options)
    {
        options.Configure(builderContext.Configuration.GetSection("Kestrel"), reloadOnChange: true);
    }

    // 注册默认服务
    private static void ConfigureWebDefaultsWorker(IWebHostBuilder builder, Action<IServiceCollection>? configureRouting)
    {
        builder.ConfigureServices((hostingContext, services) =>
        {
            // 注册 HostFilteringOptions 选项配置
            services.PostConfigure<HostFilteringOptions>(options =>
            {
                if (options.AllowedHosts == null || options.AllowedHosts.Count == 0)
                {
                    // 尝试从应用配置中得到 "AllowedHosts" 配置节表示的 ";" 分割的主机列表 
                    // 例如：
                    // "AllowedHosts": "localhost;127.0.0.1;[::1]"
                    var hosts = hostingContext.Configuration["AllowedHosts"]?.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                    // 如果没有配置，则使用 "*" 作为默认值，允许所有主机
                    options.AllowedHosts = (hosts?.Length > 0 ? hosts : new[] { "*" });
                }
            });

            // 监听应用配置改变
            services.AddSingleton<IOptionsChangeTokenSource<HostFilteringOptions>>(
                    new ConfigurationChangeTokenSource<HostFilteringOptions>(hostingContext.Configuration));

            // 注册 IStartupFilter 服务
            // 最终会利用 Func<Action<IApplicationBuilder>, Action<IApplicationBuilder>> 得到 Action<IApplicationBuilder> 配置委托链
            services.AddTransient<IStartupFilter, HostFilteringStartupFilter>();
            services.AddTransient<IStartupFilter, ForwardedHeadersStartupFilter>();
            // 注册 ForwardedHeadersOptions 的选项配置
            services.AddTransient<IConfigureOptions<ForwardedHeadersOptions>, ForwardedHeadersOptionsSetup>();
 
            // 确保有针对路由相关服务注册的配置
            // 否则注册路由相关核心服务
            if (configureRouting == null)
            {
                services.AddRoutingCore();
            }
            else
            {
                configureRouting(services);
            }
        });
    }
}
```

- WebHostDefaults

```C#
// 默认配置键
public static class WebHostDefaults
{
    public static readonly string ApplicationKey = "applicationName";
 
    public static readonly string StartupAssemblyKey = "startupAssembly";
 
    public static readonly string HostingStartupAssembliesKey = "hostingStartupAssemblies";
 
    public static readonly string HostingStartupExcludeAssembliesKey = "hostingStartupExcludeAssemblies";
 
    public static readonly string DetailedErrorsKey = "detailedErrors";
 
    public static readonly string EnvironmentKey = "environment";
 
    public static readonly string WebRootKey = "webroot";
 
    public static readonly string CaptureStartupErrorsKey = "captureStartupErrors";
 
    public static readonly string ServerUrlsKey = "urls";
 
    public static readonly string HttpPortsKey = "http_ports";
 
    public static readonly string HttpsPortsKey = "https_ports";
 
    public static readonly string ContentRootKey = "contentRoot";
 
    public static readonly string PreferHostingUrlsKey = "preferHostingUrls";
 
    public static readonly string PreventHostingStartupKey = "preventHostingStartup";
 
    public static readonly string SuppressStatusMessagesKey = "suppressStatusMessages";
 
    public static readonly string ShutdownTimeoutKey = "shutdownTimeoutSeconds";
 
    public static readonly string StaticWebAssetsKey = "staticWebAssets";
}
```

- WebHostOptions

```C#
// 用来保存从主备 IConfiguration 中读取的各项配置
internal sealed class WebHostOptions
{
    // 创建 WebHostOptions 会在第一次调用 GetWebHostBuilderContext 方法时
    // 这时候正在构建应用配置，所以主配置就是 HostBuilderContext.Configuration 中保存的宿主配置
    public WebHostOptions(IConfiguration primaryConfiguration, IConfiguration? fallbackConfiguration = null, IHostEnvironment? environment = null)
    {
        ArgumentNullException.ThrowIfNull(primaryConfiguration);

        string? GetConfig(string key) => primaryConfiguration[key] ?? fallbackConfiguration?[key];
 
        ApplicationName = environment?.ApplicationName ?? 
            GetConfig(WebHostDefaults.ApplicationKey) ?? 
            Assembly.GetEntryAssembly()?.GetName().Name ?? string.Empty;
        StartupAssembly = GetConfig(WebHostDefaults.StartupAssemblyKey);
        DetailedErrors = WebHostUtilities.ParseBool(GetConfig(WebHostDefaults.DetailedErrorsKey));
        CaptureStartupErrors = WebHostUtilities.ParseBool(GetConfig(WebHostDefaults.CaptureStartupErrorsKey));
        Environment = environment?.EnvironmentName ?? GetConfig(WebHostDefaults.EnvironmentKey);
        WebRoot = GetConfig(WebHostDefaults.WebRootKey);
        ContentRootPath = environment?.ContentRootPath ?? GetConfig(WebHostDefaults.ContentRootKey);
        PreventHostingStartup = WebHostUtilities.ParseBool(GetConfig(WebHostDefaults.PreventHostingStartupKey));
        SuppressStatusMessages = WebHostUtilities.ParseBool(GetConfig(WebHostDefaults.SuppressStatusMessagesKey));
        ServerUrls = GetConfig(WebHostDefaults.ServerUrlsKey);
        PreferHostingUrls = WebHostUtilities.ParseBool(GetConfig(WebHostDefaults.PreferHostingUrlsKey));
 
        HostingStartupAssemblies = Split(ApplicationName, GetConfig(WebHostDefaults.HostingStartupAssembliesKey));
        HostingStartupExcludeAssemblies = Split(GetConfig(WebHostDefaults.HostingStartupExcludeAssembliesKey));
 
        var timeout = GetConfig(WebHostDefaults.ShutdownTimeoutKey);
        if (!string.IsNullOrEmpty(timeout)
            && int.TryParse(timeout, NumberStyles.None, CultureInfo.InvariantCulture, out var seconds))
        {
            ShutdownTimeout = TimeSpan.FromSeconds(seconds);
        }
    }
 
    public string ApplicationName { get; }
 
    public bool PreventHostingStartup { get; }
 
    public bool SuppressStatusMessages { get; }
 
    public IReadOnlyList<string> HostingStartupAssemblies { get; }
 
    public IReadOnlyList<string> HostingStartupExcludeAssemblies { get; }
 
    public bool DetailedErrors { get; }
 
    public bool CaptureStartupErrors { get; }
 
    public string? Environment { get; }
 
    public string? StartupAssembly { get; }
 
    public string? WebRoot { get; }
 
    public string? ContentRootPath { get; }
 
    public TimeSpan ShutdownTimeout { get; } = TimeSpan.FromSeconds(30);
 
    public string? ServerUrls { get; }
 
    public bool PreferHostingUrls { get; }
    
    // 得到 HostingStartup 程序集
    // 包含 "hostingStartupAssemblies" 配置节中通过 ";" 分隔的多个程序集名称
    // 排除 "hostingStartupExcludeAssemblies" 配置节中通过 ";" 分隔的多个程序集名称
    // 并且会包含入口程序集名称
    public IEnumerable<string> GetFinalHostingStartupAssemblies()
    {
        return HostingStartupAssemblies.Except(HostingStartupExcludeAssemblies, StringComparer.OrdinalIgnoreCase);
    }
 
    private static IReadOnlyList<string> Split(string? value)
    {
        return value?.Split(';', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries)
            ?? Array.Empty<string>();
    }
 
    private static IReadOnlyList<string> Split(string applicationName, string? environment)
    {
        if (string.IsNullOrEmpty(environment))
        {
            return new[] { applicationName };
        }
 
        return Split($"{applicationName};{environment}");
    }
}
```

- IWebHostEnvironment

```C#
// Web 宿主环境
// 实现 IHostEnvironment
public interface IWebHostEnvironment : IHostEnvironment
{
    // Web 目录
    // 默认为 IHostEnvironment.ContentRootPath 下的 wwwroot 目录
    string WebRootPath { get; set; }
    
    // 对应 WebRootPath 的 IFileProvider
    IFileProvider WebRootFileProvider { get; set; }
}
```

- HostingEnvironment

```C#
// IHostEnvironment 的默认实现
#pragma warning disable CS0618
internal sealed class HostingEnvironment : IHostingEnvironment, Extensions.Hosting.IHostingEnvironment, IWebHostEnvironment
#pragma warning restore CS0618
{
    public string EnvironmentName { get; set; } = Extensions.Hosting.Environments.Production;
 
#pragma warning disable CS8766
    public string? ApplicationName { get; set; }
#pragma warning restore CS8766
 
    public string WebRootPath { get; set; } = default!;
 
    public IFileProvider WebRootFileProvider { get; set; } = default!;
 
    public string ContentRootPath { get; set; } = default!;
 
    public IFileProvider ContentRootFileProvider { get; set; } = default!;
}
```

- IWebHostBuilder

```C#
// Web 宿主建造者抽象表示
// 在现有的承载系统中已不再利用 Build 方法构建 IWebHost
public interface IWebHostBuilder
{
    // 当前承载环境已不支持此方法
    IWebHost Build();
 
    // 收集针对应用的配置
    IWebHostBuilder ConfigureAppConfiguration(Action<WebHostBuilderContext, IConfigurationBuilder> configureDelegate);
    
    // 收集针对服务注册的配置
    IWebHostBuilder ConfigureServices(Action<IServiceCollection> configureServices);
 
    // 收集针对服务注册的配置
    IWebHostBuilder ConfigureServices(Action<WebHostBuilderContext, IServiceCollection> configureServices);
 
    // 从备用配置读取配置
    string? GetSetting(string key);
    
    // 为备用配置添加配置
    IWebHostBuilder UseSetting(string key, string? value);
}
```

- ISupportsUseDefaultServiceProvider

```C#
// 为实现 IWebHostBuilder 的类型约定需要提供创建 DefaultServiceProviderFactory 的方法
internal interface ISupportsUseDefaultServiceProvider
{
    IWebHostBuilder UseDefaultServiceProvider(Action<WebHostBuilderContext, ServiceProviderOptions> configure);
}
```

- ISupportsStartup

```C#
// 为实现 IWebHostBuilder 的类型约定提供两个额外的功能
// 1. 收集中间件建造者配置
// 2. 利用 Startup 类型收集各种配置
public interface ISupportsStartup
{
    IWebHostBuilder Configure(Action<IApplicationBuilder> configure);
 
    IWebHostBuilder Configure(Action<WebHostBuilderContext, IApplicationBuilder> configure);
 
    IWebHostBuilder UseStartup(Type startupType);
 
    IWebHostBuilder UseStartup<TStartup>(Func<WebHostBuilderContext, TStartup> startupFactory);
}
```

- WebHostBuilderBase

```C#
// IWebHostBuilder 的默认实现，并同时实现了 ISupportsUseDefaultServiceProvider
// 这是一个抽象类，主要用来收集针对 Web 应用的各种配置（应用配置、服务注册配置）
// 并最终将这些配置转移到 IHostBuilder 上
// 子类的主要功能是收集各种针对中间件建造者的配置
internal abstract class WebHostBuilderBase : IWebHostBuilder, ISupportsUseDefaultServiceProvider
{
    // 最终收集到的各种配置都会被转移到 IHostBuilder 上
    private protected readonly IHostBuilder _builder;
    // 一个为 IWebHostBuilder 准备的备用配置
    // 可以调用 UseSetting 方法添加配置
    private protected readonly IConfiguration _config;
 
    public WebHostBuilderBase(IHostBuilder builder, WebHostBuilderOptions options)
    {
        _builder = builder;
        // 添加一个针对内存的空配置源
        // 确保存在一个 IConfigurationProvider 可以用
        var configBuilder = new ConfigurationBuilder()
            .AddInMemoryCollection();

        // 根据 WebHostBuilderOptions.SuppressEnvironmentConfiguration 属性的值判断是否添加前缀为 "ASPNETCORE_" 的环境变量配置源
        if (!options.SuppressEnvironmentConfiguration)
        {
            configBuilder.AddEnvironmentVariables(prefix: "ASPNETCORE_");
        }

        // 构建备用配置
        _config = configBuilder.Build();
    }
    
    // 已不支持用来构建 IWebHost
    public IWebHost Build()
    {
        throw new NotSupportedException($"Building this implementation of {nameof(IWebHostBuilder)} is not supported.");
    }
    
    // 收集针对应用的配置
    public IWebHostBuilder ConfigureAppConfiguration(Action<WebHostBuilderContext, IConfigurationBuilder> configureDelegate)
    {
        // 转移到 IHostBuilder 上
        _builder.ConfigureAppConfiguration((context, builder) =>
        {
            // 利用 HostBuilderContext 得到 WebHostBuilderContext
            // 此时 HostBuilderContext.Configuration 是宿主配置
            // 得到 WebHostBuilderContext.Configuration 也是宿主配置
            var webhostBuilderContext = GetWebHostBuilderContext(context);
            configureDelegate(webhostBuilderContext, builder);
        });
 
        return this;
    }
    
    // 收集针对服务注册的配置
    public IWebHostBuilder ConfigureServices(Action<IServiceCollection> configureServices)
    {
        return ConfigureServices((context, services) => configureServices(services));
    }
 
    // 收集针对服务注册的配置
    public IWebHostBuilder ConfigureServices(Action<WebHostBuilderContext, IServiceCollection> configureServices)
    {
        // 转移到 IHostBuilder 上
        _builder.ConfigureServices((context, builder) =>
        {
            // 利用 HostBuilderContext 得到 WebHostBuilderContext
            // 此时 HostBuilderContext.Configuration 是应用配置
            // 得到 WebHostBuilderContext.Configuration 也是应用配置
            var webhostBuilderContext = GetWebHostBuilderContext(context);
            configureServices(webhostBuilderContext, builder);
        });
 
        return this;
    }
 
    // 实现 ISupportsUseDefaultServiceProvider 接口
    public IWebHostBuilder UseDefaultServiceProvider(Action<WebHostBuilderContext, ServiceProviderOptions> configure)
    {
        // 转移到 IHostBuilder 上
        _builder.UseServiceProviderFactory(context =>
        {
            // 利用 HostBuilderContext 得到 WebHostBuilderContext
            // 此时 HostBuilderContext.Configuration 是应用配置
            // 得到 WebHostBuilderContext.Configuration 也是应用配置
            var webHostBuilderContext = GetWebHostBuilderContext(context);
            var options = new ServiceProviderOptions();
            configure(webHostBuilderContext, options);
            return new DefaultServiceProviderFactory(options);
        });
 
        return this;
    }
 
    // 利用 HostBuilderContext 得到 WebHostBuilderContext
    // 首次调用时候传入的主配置应该是宿主配置
    protected WebHostBuilderContext GetWebHostBuilderContext(HostBuilderContext context)
    {
        // 利用 IHostBuilder.Properties 共享字典缓存创建的 WebHostBuilderContext
        // 保证只会创建一次
        if (!context.Properties.TryGetValue(typeof(WebHostBuilderContext), out var contextVal))
        {
            // 利用主备配置创建 WebHostOptions
            var options = new WebHostOptions(context.Configuration, fallbackConfiguration: _config, environment: context.HostingEnvironment);
            var webHostBuilderContext = new WebHostBuilderContext
            {
                // 此时 HostBuilderContext.Configuration 保存的是宿主配置
                Configuration = context.Configuration,
                HostingEnvironment = new HostingEnvironment()
            };
            // 通过 HostBuilderContext.HostingEnvironment 和 WebHostOptions 为 WebHostBuilderContext.HostingEnvironment 赋值
            // 如果配置节 "webroot" 不存在，则使用默认值 "wwwroot"
            // 最终 IWebHostEnvironment.WebRootPath 的值就是 "{IHostEnvironment.ContentRootPath}/wwwroot"
            webHostBuilderContext.HostingEnvironment.Initialize(context.HostingEnvironment.ContentRootPath, options, baseEnvironment: context.HostingEnvironment);
            // 缓存避免重复创建转换
            context.Properties[typeof(WebHostBuilderContext)] = webHostBuilderContext;
            context.Properties[typeof(WebHostOptions)] = options;
            return webHostBuilderContext;
        }
 
        var webHostContext = (WebHostBuilderContext)contextVal;
        // GetWebHostBuilderContext 方法在应用配置时可能会被多次调用
        // 当前 WebHostBuilderContext.Configuration 可能保存的只是宿主配置
        // 而 HostBuilderContext.Configuration 当前已经是应用配置
        // 所以需要在每次调用时更新
        webHostContext.Configuration = context.Configuration;
        return webHostContext;
    }
 
    public string? GetSetting(string key)
    {
        return _config[key];
    }
 
    public IWebHostBuilder UseSetting(string key, string? value)
    {
        _config[key] = value;
        return this;
    }
}
```

- GenericWebHostBuilder

```C#
// 继承 WebHostBuilderBase
// 实现 ISupportsStartup
// 主要功能：
// 1. 使用 Configure 方法收集中间件建造者配置
// 2. 使用 UseStartup 方法注册外部类型
//    利用外部类型的 ConfigureService 方法收集针对服务注册的配置
//    利用外部类型的 ConfigureContainer 方法收集针对容器建造者的配置
//    利用外部类型的 Configure 方法收集中间件建造者配置
// 收集配置的先后顺序：
// 1. 使用构造函数收集的
// 2. 使用 WebHost.ConfigureWebDefaults 方法收集的
// 3. 使用 IWebHostBuilder 调用方法收集的
//    如果调用 Startup 方法就会使用基于约定的 Startup 收集的（使用 Startup 类型）
// 4. 使用强类型 Startup 收集的（实现 IHostingStartup 接口）
// 5. 使用基于约定的 Startup 收集的（使用 "startupAssembly" 配置节表示的程序集中发现的 Startup 类型）
internal sealed class GenericWebHostBuilder : WebHostBuilderBase, ISupportsStartup
{
    private object? _startupObject;
    private readonly object _startupKey = new object();
 
    private AggregateException? _hostingStartupErrors;
    private HostingStartupWebHostBuilder? _hostingStartupWebHostBuilder;
 
    public GenericWebHostBuilder(IHostBuilder builder, WebHostBuilderOptions options)
        : base(builder, options)
    {
        // 添加针对宿主的配置
        // 将备用配置作为被链接的配置源        
        // 转移到 IHostBuilder 上
        _builder.ConfigureHostConfiguration(config =>
        {
            config.AddConfiguration(_config);

            // 在构建宿主配置时调用
            // 利用强类型 Startup 收集各种配置
            ExecuteHostingStartups();
        });
 
        // 添加针对应用的配置
        // 转移到 IHostBuilder 上
        _builder.ConfigureAppConfiguration((context, configurationBuilder) =>
        {
            // 确保启用强类型 Startup
            if (_hostingStartupWebHostBuilder != null)
            {
                var webhostContext = GetWebHostBuilderContext(context);
                // 执行 HostingStartupWebHostBuilder 中针对应用配置的委托链
                _hostingStartupWebHostBuilder.ConfigureAppConfiguration(webhostContext, configurationBuilder);
            }
        });

        // 添加针对服务注册的配置
        // 转移到 IHostBuilder 上
        _builder.ConfigureServices((context, services) =>
        {
            var webhostContext = GetWebHostBuilderContext(context);
            var webHostOptions = (WebHostOptions)context.Properties[typeof(WebHostOptions)];
 
            // 注册 IWebHostEnvironment，使用 IWebHostEnvironment.HostingEnvironment 实例
            services.AddSingleton(webhostContext.HostingEnvironment);
#pragma warning disable CS0618 
            services.AddSingleton((AspNetCore.Hosting.IHostingEnvironment)webhostContext.HostingEnvironment);
            services.AddSingleton<IApplicationLifetime, GenericWebHostApplicationLifetime>();
#pragma warning restore CS0618 
 
            // 注册 GenericWebHostServiceOptions 选项配置
            services.Configure<GenericWebHostServiceOptions>(options =>
            {
                options.WebHostOptions = webHostOptions;
                options.HostingStartupExceptions = _hostingStartupErrors;
            });
 
            // 注册 DiagnosticSource，使用 Func<IServiceProvider, DiagnosticListener> 工厂
            services.TryAddSingleton(sp => new DiagnosticListener("Microsoft.AspNetCore"));
            services.TryAddSingleton<DiagnosticSource>(sp => sp.GetRequiredService<DiagnosticListener>());
            // 注册 ActivitySource，使用 Func<IServiceProvider, ActivitySource> 工厂
            services.TryAddSingleton(sp => new ActivitySource("Microsoft.AspNetCore"));
            services.TryAddSingleton(DistributedContextPropagator.Current);
 
            // 注册 IHttpContextFactory, 使用 DefaultHttpContextFactory 类型
            services.TryAddSingleton<IHttpContextFactory, DefaultHttpContextFactory>();
            // 注册 IMiddlewareFactory，使用 MiddlewareFactory 类型（注册为 Scoped 生命周期）
            services.TryAddScoped<IMiddlewareFactory, MiddlewareFactory>();
            // 注册 IApplicationBuilderFactory, 使用 ApplicationBuilderFactory 类型
            services.TryAddSingleton<IApplicationBuilderFactory, ApplicationBuilderFactory>();
 
            services.AddMetrics();
            services.TryAddSingleton<HostingMetrics>();
 
            // 确保启用强类型 Startup
            // 执行 HostingStartupWebHostBuilder 中针对服务注册的委托链
            _hostingStartupWebHostBuilder?.ConfigureServices(webhostContext, services);
            
            if (!string.IsNullOrEmpty(webHostOptions.StartupAssembly))
            {
                // 在构建服务注册时调用
                // 利用基于约定的 Startup 收集各种配置
                ScanAssemblyAndRegisterStartup(context, services, webhostContext, webHostOptions);
            }
        });
    }
    
    // 创建基于约定的 Startup 类型
    private void ScanAssemblyAndRegisterStartup(HostBuilderContext context, IServiceCollection services, WebHostBuilderContext webhostContext, WebHostOptions webHostOptions)
    {
        try
        {
            // 如果 "startupAssembly" 配置节存在，则尝试加载对应名称的程序集并找到基于约定的 Startup 类型
            // 查找规则如下：
            // 1. "Startup{IWebHostEnvironment.EnvironmentName}" 
            // 2. "Startup"
            // 3. 以上名称前添加 "startupAssembly" 配置节表示的程序集名称 + "." 作为前缀
            // 4. "Startup{IWebHostEnvironment.EnvironmentName}" 忽略大小写
            // 5. "Startup" 忽略大小写
            // 最终根据以上的顺序使用最先找到的 Startup 类型
            var startupType = StartupLoader.FindStartupType(webHostOptions.StartupAssembly!, webhostContext.HostingEnvironment.EnvironmentName);
            UseStartup(startupType, context, services);
        }
        catch (Exception ex) when (webHostOptions.CaptureStartupErrors)
        {
            var capture = ExceptionDispatchInfo.Capture(ex);
 
            services.Configure<GenericWebHostServiceOptions>(options =>
            {
                options.ConfigureApplication = app =>
                {
                    capture.Throw();
                };
            });
        }
    }
    
    // 创建强类型的 Startup（实现 IHostingStartup 接口）
    // 并使用 HostingStartupWebHostBuilder 从强类型的 Startup 中收集各种配置
    private void ExecuteHostingStartups()
    {
        // 此时宿主配置尚未构建，只能使用备用配置创建 WebHostOptions
        // 备用配置的配置源主要是 "ASPNETCORE_" 前缀的环境变量配置源
        // 或者调用 IWebHostBuilder.UseSetting 方法直接添加的配置值
        var webHostOptions = new WebHostOptions(_config);
 
        // 如果 "preventHostingStartup" 配置节不存在或值为 "false"
        // 则不应用 HostingStartups
        if (webHostOptions.PreventHostingStartup)
        {
            return;
        }
 
        var exceptions = new List<Exception>();
        var processed = new HashSet<Assembly>();
 
        // 创建 HostingStartupWebHostBuilder
        // 是对 GenericWebHostBuilder 的封装
        // 内部在收集多个针对应用的配置或针对服务注册的配置时时通过委托链形式保存
        // 而其他的配置都将被转移到 GenericWebHostBuilder 上
        _hostingStartupWebHostBuilder = new HostingStartupWebHostBuilder(this);
 
        // 从备用配置的 "hostingStartupAssemblies" 配置节和 "hostingStartupExcludeAssemblies" 配置节得到强类型 Startup 程序集列表
        // 还会附加入口程序集的名称
        foreach (var assemblyName in webHostOptions.GetFinalHostingStartupAssemblies())
        {
            try
            {
                // 加载程序集
                var assembly = Assembly.Load(new AssemblyName(assemblyName));
 
                // 不会重复处理同名的程序集
                if (!processed.Add(assembly))
                {
                    continue;
                }
 
                // 从当前程序集得到绑定的 HostingStartupAttribute 特性集合
                foreach (var attribute in assembly.GetCustomAttributes<HostingStartupAttribute>())
                {
                    // 利用 HostingStartupAttribute.HostingStartupType 表示的类型反射得到对应实例（必须存在无参构造函数）
                    // 并强制类型转换为 IHostingStartup 接口类型
                    var hostingStartup = (IHostingStartup)Activator.CreateInstance(attribute.HostingStartupType)!;
                    // 调用 IHostingStartup.Configure 方法
                    // 利用 HostingStartupWebHostBuilder 从强类型 Startup 中收集各种配置
                    hostingStartup.Configure(_hostingStartupWebHostBuilder);
                }
            }
            catch (Exception ex)
            {
                exceptions.Add(new InvalidOperationException($"Startup assembly {assemblyName} failed to execute. See the inner exception for more details.", ex));
            }
        }
 
        if (exceptions.Count > 0)
        {
            _hostingStartupErrors = new AggregateException(exceptions);
        }
    }
    
    // UseStartup 的重载
    // 传递 Startup 类型
    public IWebHostBuilder UseStartup(Type startupType)
    {
        var startupAssemblyName = startupType.Assembly.GetName().Name;

        // 将 Startup 类型所在的程序集名称作为 "applicationName" 配置节的值
        UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);

        // 保存最后一次的 Startup 类型
        _startupObject = startupType;

        // 转移到 IHostBuilder 上
        _builder.ConfigureServices((context, services) =>
        {
            // 由于 UseStartup 可以多次调用，所以只支持最后一次为 _startupObject 赋值的调用
            if (object.ReferenceEquals(_startupObject, startupType))
            {
                // 在构建服务注册时调用
                UseStartup(startupType, context, services);
            }
        });
 
        return this;
    }
    
    // UseStartup 的重载
    // 传递 Func<WebHostBuilderContext, TStartup> 委托
    public IWebHostBuilder UseStartup<TStartup>(Func<WebHostBuilderContext, TStartup> startupFactory)
    {
        var startupAssemblyName = startupFactory.GetMethodInfo().DeclaringType!.Assembly.GetName().Name;

        // 将 startupFactory 委托的原型方法的类型所在程序集名称作为 "applicationName" 配置节的值
        UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        // 保存最后一次的 Func<WebHostBuilderContext, TStartup> 委托
        _startupObject = startupFactory;
 
        // 转移到 IHostBuilder 上
        _builder.ConfigureServices(ConfigureStartup);

        void ConfigureStartup(HostBuilderContext context, IServiceCollection services)
        {
            // 由于 UseStartup 可以多次调用，所以只支持最后一次为 _startupObject 赋值的调用
            if (object.ReferenceEquals(_startupObject, startupFactory))
            {
                var webHostBuilderContext = GetWebHostBuilderContext(context);
                // 利用 Func<WebHostBuilderContext, TStartup> 委托创建 Startup 类型实例
                var instance = startupFactory(webHostBuilderContext) ?? 
                               throw new InvalidOperationException("The specified factory returned null startup instance.");
                // 在构建服务注册时调用
                UseStartup(instance.GetType(), context, services, instance);
            }
        }
 
        return this;
    }
    
    // 私有方法
    // 实际创建基于约定的 Startup 并应用配置
    private void UseStartup(Type startupType, HostBuilderContext context, IServiceCollection services, object? instance = null)
    {
        var webHostBuilderContext = GetWebHostBuilderContext(context);
        var webHostOptions = (WebHostOptions)context.Properties[typeof(WebHostOptions)];
 
        ExceptionDispatchInfo? startupError = null;
        ConfigureBuilder? configureBuilder = null;
 
        try
        {
            // 不支持 Startup 类型实现 IStartup 接口
            if (typeof(IStartup).IsAssignableFrom(startupType))
            {
                throw new NotSupportedException($"{typeof(IStartup)} isn't supported");
            }
            // 不支持 Startup 类型中存在返回值类型是 IServiceProvider 的 "ConfigureServices" 方法
            if (StartupLoader.HasConfigureServicesIServiceProviderDelegate(startupType, context.HostingEnvironment.EnvironmentName))
            {
                throw new NotSupportedException($"ConfigureServices returning an {typeof(IServiceProvider)} isn't supported.");
            }

            // 如果 instance 参数表示的 Startup 类型实例为空
            // 则利用反射方式创建 Startup 类型实例
            // 需要选定 Startup 类型的一个最优构造函数
            // 并可以利用 HostServiceProvider 为构造函数提供 IHostEnvironment、IWebHostEnvironment、IConfiguration 三个服务类型的实例
            instance ??= ActivatorUtilities.CreateInstance(new HostServiceProvider(webHostBuilderContext), startupType);
            // 将实例存入由 IHostBuilder.Properties 表示的共享字典中
            context.Properties[_startupKey] = instance;
 
            // 从 Startup 类型中查找 "ConfigureServices" 方法
            // 支持实例或静态方法
            // 优先级顺序如下：
            // 1. 名称为 "Configure{IHostEnvironment.EnvironmentName}Services" 的方法
            // 2. 名称为 "ConfigureServices" 的方法
            // 并且该方法必须满足以下条件：
            // 1. public
            // 2. 返回值类型是 void
            // 3. 方法最多可以有一个参数，并且参数类型是 IServiceCollection
            // 4. 找到的方法不能存在重载
            var configureServicesBuilder = StartupLoader.FindConfigureServicesDelegate(startupType, context.HostingEnvironment.EnvironmentName);
            // 构建 Func<IServiceCollection, IServiceProvider?> 委托
            var configureServices = configureServicesBuilder.Build(instance);

            // 执行委托
            // 内部是通过反射方式调用 Startup 类型的 ConfigureService 方法
            configureServices(services);
 
            // 从 Startup 类型中查找 "ConfigureContainer" 方法
            // 支持实例或静态方法
            // 优先级顺序如下：
            // 1. 名称为 "Configure{IHostEnvironment.EnvironmentName}Container" 的方法
            // 2. 名称为 "ConfigureContainer" 的方法
            // 并且该方法必须满足以下条件：
            // 1. public
            // 2. 返回值类型是 void
            // 3. 方法有且仅有一个参数，参数的类型需要是实现 IContainerBuilder 接口的具体类型
            // 4. 找到的方法不能存在重载
            var configureContainerBuilder = StartupLoader.FindConfigureContainerDelegate(startupType, context.HostingEnvironment.EnvironmentName);
            // 基于约定的 Startup 类型中可以不定义 "ConfigureContainer" 相关方法
            if (configureContainerBuilder.MethodInfo != null)
            {
                // 将 ConfigureContainerBuilder 实例存入由 IHostBuilder.Properties 表示的构建共享字典中
                _builder.Properties[typeof(ConfigureContainerBuilder)] = configureContainerBuilder;

                // 通过反射方式添加针对容器建造者的配置 
                InvokeContainer(this, configureContainerBuilder);
            }
 
            // 从 Startup 类型中查找 "Configure" 方法
            // 支持实例或静态方法
            // 优先级顺序如下：
            // 1. 名称为 "Configure{IHostEnvironment.EnvironmentName}" 的方法
            // 2. 名称为 "Configure" 的方法
            // 并且该方法必须满足以下条件：
            // 1. public
            // 2. 返回值类型是 void
            // 3. 方法支持多个参数，可以存在一个类型为 IApplicationBuilder 的参数
            //    可以包含若干参数，但这些参数类型必须已经服务注册
            //    因为在通过反射调用 Startup 类型的 Configure 方法前
            //    会利用 IApplicationBuilder.ApplicationServices 这个根容器创建一个范围容器
            //    并利用这个范围容器创建对应类型参数所需要的实例
            // 4. 找到的方法不能存在重载
            configureBuilder = StartupLoader.FindConfigureDelegate(startupType, context.HostingEnvironment.EnvironmentName);
        }
        catch (Exception ex) when (webHostOptions.CaptureStartupErrors)
        {
            startupError = ExceptionDispatchInfo.Capture(ex);
        }
 
        // 注册 GenericWebHostServiceOptions 选项配置
        services.Configure<GenericWebHostServiceOptions>(options =>
        {
            // 将针对中间件建造者配置委托保存到 GenericWebHostServiceOptions.ConfigureApplication 属性中
            options.ConfigureApplication = app =>
            {
                startupError?.Throw();
 
                if (instance != null && configureBuilder != null)
                {
                    // 构建 Action<IApplicationBuilder> 委托并执行
                    // 内部通过反射方式调用 Startup 实例的 Configure 方法
                    configureBuilder.Build(instance)(app);
                }
            };
        });
 
        // 利用反射方式调用 IHostBuilder.ConfigureContainer
        static void InvokeContainer(GenericWebHostBuilder genericWebHostBuilder, ConfigureContainerBuilder configureContainerBuilder)
        {
            // 得到 ConfigureContainer 方法的具体参数类型
            var containerType = configureContainerBuilder.GetContainerType();
 
            // 不支持容器建造者类型是值类型
            if (containerType.IsValueType && !RuntimeFeature.IsDynamicCodeSupported)
            {
                throw new InvalidOperationException("A ValueType TContainerBuilder isn't supported with AOT.");
            }

            // 通过调用 MakeGenericType 得到具体容器建造者类型的 Action<HostBuilderContext, TContainerBuilder> 类型
            var actionType = typeof(Action<,>).MakeGenericType(typeof(HostBuilderContext), containerType);
 
            // 通过调用 MakeGenericType 得到具体容器建造者类型的 GenericWebHostBuilder.ConfigureContainerImpl<TContainer> 泛型方法的 MethodInfo
            // 并创建 Action<HostBuilderContext, TContainerBuilder> 委托
            var configureCallback = typeof(GenericWebHostBuilder)
                .GetMethod(nameof(ConfigureContainerImpl), BindingFlags.NonPublic | BindingFlags.Instance)!
                .MakeGenericMethod(containerType)
                .CreateDelegate(actionType, genericWebHostBuilder);
 
            // 通过调用 MakeGenericType 得到具体容器建造者类型的 IHostBuilder.ConfigureContainer<TContainer> 泛型方法的 MethodInfo
            // 再通过反射方式调用添加针对容器建造者的配置
            // 转移到 IHostBuilder 上
            typeof(IHostBuilder).GetMethod(nameof(IHostBuilder.ConfigureContainer))!
                .MakeGenericMethod(containerType)
                .InvokeWithoutWrappingExceptions(genericWebHostBuilder._builder, new object[] { configureCallback });
        }
    }
    
    // 用来构建 Action<HostBuilderContext, TContainerBuilder> 委托的方法原型
    private void ConfigureContainerImpl<TContainer>(HostBuilderContext context, TContainer container) where TContainer : notnull
    {
        // 先从 IHostBuilder.Properties 表示的构建共享字典中得到 Startup 类型实例
        var instance = context.Properties[_startupKey];
        // 再从 IHostBuilder.Properties 表示的构建共享字典中得到 ConfigureContainerBuilder 实例
        var builder = (ConfigureContainerBuilder)context.Properties[typeof(ConfigureContainerBuilder)];
        // 构建 Action<object> 委托并执行
        // 内部是通过反射方式调用 Startup 类型的 ConfigureContainer 方法
        builder.Build(instance)(container);
    }
 
    // 添加针对中间件建造者的配置
    public IWebHostBuilder Configure(Action<IApplicationBuilder> configure)
    {
        var startupAssemblyName = configure.GetMethodInfo().DeclaringType!.Assembly.GetName().Name!;
 
        // 将 configure 委托的原型方法的类型所在的程序集名称作为 "applicationName" 配置节的值
        UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        // 保存最后一次的 Action<IApplicationBuilder> 委托
        _startupObject = configure;
        
        // 转移到 IHostBuilder 上
        _builder.ConfigureServices((context, services) =>
        {
            // 由于 Configure 可以多次调用，所以只支持最后一次为 _startupObject 赋值的调用
            if (object.ReferenceEquals(_startupObject, configure))
            {
                // 注册 GenericWebHostServiceOptions 选项配置
                services.Configure<GenericWebHostServiceOptions>(options =>
                {
                    options.ConfigureApplication = app => configure(app);
                });
            }
        });
 
        return this;
    }
    
    // 添加针对中间件建造者的配置
    public IWebHostBuilder Configure(Action<WebHostBuilderContext, IApplicationBuilder> configure)
    {
        var startupAssemblyName = configure.GetMethodInfo().DeclaringType!.Assembly.GetName().Name!;
 
        // 将定义 configure 委托的原型方法的类型所在的程序集名称作为 "applicationName" 配置节的值
        UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        // 保存最后一次的 Action<WebHostBuilderContext, IApplicationBuilder> 委托
        _startupObject = configure;

        // 转移到 IHostBuilder 上
        _builder.ConfigureServices((context, services) =>
        {
            // 由于 Configure 可以多次调用，所以只支持最后一次为 _startupObject 赋值的调用
            if (object.ReferenceEquals(_startupObject, configure))
            {
                // 注册 GenericWebHostServiceOptions 选项配置
                services.Configure<GenericWebHostServiceOptions>(options =>
                {
                    var webhostBuilderContext = GetWebHostBuilderContext(context);
                    options.ConfigureApplication = app => configure(webhostBuilderContext, app);
                });
            }
        });
 
        return this;
    }
    
    // 实现 IServiceProvider
    // 并不是真实实现，本质是对 WebHostBuilderContext 的包装
    // 对外可以提供 IHostEnvironment、IWebHostEnvironment、IConfiguration 三个服务的实例
    private sealed class HostServiceProvider : IServiceProvider
    {
        private readonly WebHostBuilderContext _context;
 
        public HostServiceProvider(WebHostBuilderContext context)
        {
            _context = context;
        }
 
        public object? GetService(Type serviceType)
        {
            // The implementation of the HostingEnvironment supports both interfaces
#pragma warning disable CS0618 // Type or member is obsolete
            if (serviceType == typeof(Microsoft.Extensions.Hosting.IHostingEnvironment)
                || serviceType == typeof(Microsoft.AspNetCore.Hosting.IHostingEnvironment)
#pragma warning restore CS0618 // Type or member is obsolete
                    || serviceType == typeof(IWebHostEnvironment)
                || serviceType == typeof(IHostEnvironment)
                )
            {
                return _context.HostingEnvironment;
            }
 
            if (serviceType == typeof(IConfiguration))
            {
                return _context.Configuration;
            }
 
            return null;
        }
    }
}
```

- HostingStartupWebHostBuilder

```C#
// 实现 IWebHostBuilder，ISupportsUseDefaultServiceProvider、ISupportsStartup
// 是对 GenericWebHostBuilder 的封装
internal sealed class HostingStartupWebHostBuilder : IWebHostBuilder, ISupportsStartup, ISupportsUseDefaultServiceProvider
{
    private readonly GenericWebHostBuilder _builder;
    private Action<WebHostBuilderContext, IConfigurationBuilder>? _configureConfiguration;
    private Action<WebHostBuilderContext, IServiceCollection>? _configureServices;
 
    public HostingStartupWebHostBuilder(GenericWebHostBuilder builder)
    {
        _builder = builder;
    }
 
    public IWebHost Build()
    {
        throw new NotSupportedException($"Building this implementation of {nameof(IWebHostBuilder)} is not supported.");
    }
 
    // 收集针对应用的配置
    // 利用委托链保存多个配置
    public IWebHostBuilder ConfigureAppConfiguration(Action<WebHostBuilderContext, IConfigurationBuilder> configureDelegate)
    {
        _configureConfiguration += configureDelegate;
        return this;
    }
 
    // 收集针对服务注册的配置
    // 利用委托链保存多个配置
    public IWebHostBuilder ConfigureServices(Action<IServiceCollection> configureServices)
    {
        return ConfigureServices((context, services) => configureServices(services));
    }

    // 收集针对服务注册的配置
    // 利用委托链保存多个配置
    public IWebHostBuilder ConfigureServices(Action<WebHostBuilderContext, IServiceCollection> configureServices)
    {
        _configureServices += configureServices;
        return this;
    }
    
    // 从备用配置读取配置
    // 转移到 GenericWebHostBuilder 上
    public string? GetSetting(string key) => _builder.GetSetting(key);
    
    // 为备用配置添加配置
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder UseSetting(string key, string? value)
    {
        _builder.UseSetting(key, value);
        return this;
    }
    
    // Action<WebHostBuilderContext, IServiceCollection> 委托的原型方法
    // 执行委托链
    public void ConfigureServices(WebHostBuilderContext context, IServiceCollection services)
    {
        _configureServices?.Invoke(context, services);
    }
 
    // Action<WebHostBuilderContext, IConfigurationBuilder> 委托的原型方法
    // 执行委托链
    public void ConfigureAppConfiguration(WebHostBuilderContext context, IConfigurationBuilder builder)
    {
        _configureConfiguration?.Invoke(context, builder);
    }
 
    // 实现 ISupportsUseDefaultServiceProvider 接口
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder UseDefaultServiceProvider(Action<WebHostBuilderContext, ServiceProviderOptions> configure)
    {
        return _builder.UseDefaultServiceProvider(configure);
    }
 
    // 添加针对中间件建造者的配置
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder Configure(Action<IApplicationBuilder> configure)
    {
        return _builder.Configure(configure);
    }
 
    // 添加针对中间件建造者的配置
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder Configure(Action<WebHostBuilderContext, IApplicationBuilder> configure)
    {
        return _builder.Configure(configure);
    }
    
    // 根据 Startup 类型创建基于约定的 Startup 并应用配置
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder UseStartup(Type startupType)
    {
        return _builder.UseStartup(startupType);
    }
 
    // 根据 Func<WebHostBuilderContext, TStartup> 创建基于约定的 Startup 并应用配置
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder UseStartup<TStartup>(Func<WebHostBuilderContext, TStartup> startupFactory)
    {
        return _builder.UseStartup(startupFactory);
    }
}
```

- WebHostBuilderExtensions

```C#
// 为 IWebhostBuilder 提供扩展方法
// 由于 IWebhostBuilder 没有定义 Configure 和 UseStartup 方法
// 所以需要通过提供扩展方法转移到 IWebhostBuilder 的实现上
// 一般实现 IWebHostBuilder 接口的类型也会实现 ISupportsStartup 接口
// 所以可以通过 ISupportsStartup 接口调用 Configure 和 UseStartup 方法
public static class WebHostBuilderExtensions
{
    public static IWebHostBuilder Configure(this IWebHostBuilder hostBuilder, Action<IApplicationBuilder> configureApp)
    {
        ArgumentNullException.ThrowIfNull(configureApp);、

        if (hostBuilder is ISupportsStartup supportsStartup)
        {
            return supportsStartup.Configure(configureApp);
        }
 
        var startupAssemblyName = configureApp.GetMethodInfo().DeclaringType!.Assembly.GetName().Name!;
 
        hostBuilder.UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        return hostBuilder.ConfigureServices((context, services) =>
        {
            services.AddSingleton<IStartup>(sp =>
            {
                return new DelegateStartup(sp.GetRequiredService<IServiceProviderFactory<IServiceCollection>>(), (app => configureApp(app)));
            });
        });
    }
 
    public static IWebHostBuilder Configure(this IWebHostBuilder hostBuilder, Action<WebHostBuilderContext, IApplicationBuilder> configureApp)
    {
        ArgumentNullException.ThrowIfNull(configureApp);
 
        if (hostBuilder is ISupportsStartup supportsStartup)
        {
            return supportsStartup.Configure(configureApp);
        }
 
        var startupAssemblyName = configureApp.GetMethodInfo().DeclaringType!.Assembly.GetName().Name!;
 
        hostBuilder.UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        return hostBuilder.ConfigureServices((context, services) =>
        {
            services.AddSingleton<IStartup>(sp =>
            {
                return new DelegateStartup(sp.GetRequiredService<IServiceProviderFactory<IServiceCollection>>(), (app => configureApp(context, app)));
            });
        });
    }
 
    public static IWebHostBuilder UseStartup<TStartup>(this IWebHostBuilder hostBuilder, Func<WebHostBuilderContext, TStartup> startupFactory) where TStartup : class
    {
        ArgumentNullException.ThrowIfNull(startupFactory);
 
        if (hostBuilder is ISupportsStartup supportsStartup)
        {
            return supportsStartup.UseStartup(startupFactory);
        }
 
        var startupAssemblyName = startupFactory.GetMethodInfo().DeclaringType!.Assembly.GetName().Name;
 
        hostBuilder.UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        return hostBuilder
            .ConfigureServices((context, services) =>
            {
                services.AddSingleton(typeof(IStartup), GetStartupInstance);
 
                [UnconditionalSuppressMessage("Trimmer", "IL2072", Justification = "Startup type created by factory can't be determined statically.")]
                object GetStartupInstance(IServiceProvider serviceProvider)
                {
                    var instance = startupFactory(context) ?? throw new InvalidOperationException("The specified factory returned null startup instance.");
 
                    var hostingEnvironment = serviceProvider.GetRequiredService<IHostEnvironment>();
 
                    if (instance is IStartup startup)
                    {
                        return startup;
                    }
 
                    return new ConventionBasedStartup(StartupLoader.LoadMethods(serviceProvider, instance.GetType(), hostingEnvironment.EnvironmentName, instance));
                }
            });
    }
 
    public static IWebHostBuilder UseStartup(this IWebHostBuilder hostBuilder, Type startupType)
    {
        ArgumentNullException.ThrowIfNull(startupType);
 
        if (hostBuilder is ISupportsStartup supportsStartup)
        {
            return supportsStartup.UseStartup(startupType);
        }
 
        var startupAssemblyName = startupType.Assembly.GetName().Name;
 
        hostBuilder.UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        return hostBuilder
            .ConfigureServices(services =>
            {
                if (typeof(IStartup).IsAssignableFrom(startupType))
                {
                    services.AddSingleton(typeof(IStartup), startupType);
                }
                else
                {
                    services.AddSingleton(typeof(IStartup), sp =>
                    {
                        var hostingEnvironment = sp.GetRequiredService<IHostEnvironment>();
                        return new ConventionBasedStartup(StartupLoader.LoadMethods(sp, startupType, hostingEnvironment.EnvironmentName));
                    });
                }
            });
    }
 
    public static IWebHostBuilder UseStartup<TStartup>(this IWebHostBuilder hostBuilder) where TStartup : class
    {
        return hostBuilder.UseStartup(typeof(TStartup));
    }
 
    public static IWebHostBuilder UseDefaultServiceProvider(this IWebHostBuilder hostBuilder, Action<ServiceProviderOptions> configure)
    {
        return hostBuilder.UseDefaultServiceProvider((context, options) => configure(options));
    }
 
    public static IWebHostBuilder UseDefaultServiceProvider(this IWebHostBuilder hostBuilder, Action<WebHostBuilderContext, ServiceProviderOptions> configure)
    {
        if (hostBuilder is ISupportsUseDefaultServiceProvider supportsDefaultServiceProvider)
        {
            return supportsDefaultServiceProvider.UseDefaultServiceProvider(configure);
        }
 
        return hostBuilder.ConfigureServices((context, services) =>
        {
            var options = new ServiceProviderOptions();
            configure(context, options);
            services.Replace(ServiceDescriptor.Singleton<IServiceProviderFactory<IServiceCollection>>(new DefaultServiceProviderFactory(options)));
        });
    }
 
    public static IWebHostBuilder ConfigureAppConfiguration(this IWebHostBuilder hostBuilder, Action<IConfigurationBuilder> configureDelegate)
    {
        return hostBuilder.ConfigureAppConfiguration((context, builder) => configureDelegate(builder));
    }
 
    public static IWebHostBuilder ConfigureLogging(this IWebHostBuilder hostBuilder, Action<ILoggingBuilder> configureLogging)
    {
        return hostBuilder.ConfigureServices(collection => collection.AddLogging(configureLogging));
    }
 
    public static IWebHostBuilder ConfigureLogging(this IWebHostBuilder hostBuilder, Action<WebHostBuilderContext, ILoggingBuilder> configureLogging)
    {
        return hostBuilder.ConfigureServices((context, collection) => collection.AddLogging(builder => configureLogging(context, builder)));
    }
 
    public static IWebHostBuilder UseStaticWebAssets(this IWebHostBuilder builder)
    {
        builder.ConfigureAppConfiguration((context, configBuilder) =>
        {
            StaticWebAssetsLoader.UseStaticWebAssets(context.HostingEnvironment, context.Configuration);
        });
 
        return builder;
    }
}
```

- IHostingStartup

```C#
// HostingStartup 接口
// 用来定义强类型 Startup
public interface IHostingStartup
{
    void Configure(IWebHostBuilder builder);
}
```

## 中间件

- IStartupFilter

```C#
// 用来注册 IStartupFilter 服务
public interface IStartupFilter
{
    // 通过调用 Configure 方法传入后续中间件建造者配置返回前序中间件建造者配置
    // 构建 Action<IApplicationBuilder> -> Action<IApplicationBuilder> -> ... -> Action<IApplicationBuilder> 中间件建造者配置链
    Action<IApplicationBuilder> Configure(Action<IApplicationBuilder> next);
}
```

- IApplicationBuilder

```C#
// 中间件建造者
// 注册 Func<RequestDelegate, RequestDelegate> 形式的原始中间件
// 并最终将中间件构建成 RequestDelegate -> RequestDelegate -> ... -> RequestDelegate 请求处理委托链
public interface IApplicationBuilder
{
    // 代表根容器的 IServiceProvider
    IServiceProvider ApplicationServices { get; set; }
    
    // 不同服务器提供的特性集合
    IFeatureCollection ServerFeatures { get; }

    // 构建过程中用于共享的数据字典
    IDictionary<string, object?> Properties { get; }
    
    // 注册 Func<RequestDelegate, RequestDelegate> 形式的中间件
    // Func<RequestDelegate, RequestDelegate> 是中间件的原始形式
    // 一般很少直接调用此方法注册中间件
    // 通常会将中间件定义为具体类型，然后通过 UseMiddlewareExtensions 中的 UseMiddleware 扩展方法进行注册
    // 但最终都会被转换为 Func<RequestDelegate, RequestDelegate> 形式的中间件，再调用此方法注册
    IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware);
 
    // 创建一个新的 IApplicationBuilder
    IApplicationBuilder New();
    
    // 构建请求处理委托链
    // 将收集到的 Func<RequestDelegate, RequestDelegate> 形式的中间件反转
    // 然后使用代表终结点请求处理器的 RequestDelegate 依次调用委托
    // 通过传入的 RequestDelegate 作为返回的 RequestDelegate 的后续请求处理的形式
    // 构建成 RequestDelegate -> RequestDelegate -> ... -> RequestDelegate 的请求处理委托链
    // 并返回代表第一个请求处理器的 RequestDelegate
    RequestDelegate Build();
}
```

- ApplicationBuilder

```C#
// IApplicationBuilder 的默认实现
public partial class ApplicationBuilder : IApplicationBuilder
{
    private const string ServerFeaturesKey = "server.Features";
    private const string ApplicationServicesKey = "application.Services";
    private const string MiddlewareDescriptionsKey = "__MiddlewareDescriptions";
    private const string RequestUnhandledKey = "__RequestUnhandled";
 
    private readonly List<Func<RequestDelegate, RequestDelegate>> _components = new();
    private readonly List<string>? _descriptions;
    private readonly IDebugger _debugger;
    
    public ApplicationBuilder(IServiceProvider serviceProvider) : this(serviceProvider, new FeatureCollection())
    {
    }
    
    // 中间件数量
    private int MiddlewareCount => _components.Count;
 
    // 利用 IApplicationBuilderFactory 创建 ApplicationBuilder
    // 并提供表示根容器的 IServiceProvider 和由服务器提供的特性集合 IFeatureCollection（server 参数）
    public ApplicationBuilder(IServiceProvider serviceProvider, object server)
    {
        Properties = new Dictionary<string, object?>(StringComparer.Ordinal);
        ApplicationServices = serviceProvider;

        // 使用 "server.Features" 作为 Key 将 IFeatureCollection 特性集合保存到共享字典中
        SetProperty(ServerFeaturesKey, server);
 
        _debugger = (IDebugger?)serviceProvider?.GetService(typeof(IDebugger)) ?? DebuggerWrapper.Instance;
 
        if (_debugger.IsAttached)
        {
            _descriptions = new();
            SetProperty(MiddlewareDescriptionsKey, _descriptions);
        }
    }
 
    private ApplicationBuilder(ApplicationBuilder builder)
    {
        Properties = new CopyOnWriteDictionary<string, object?>(builder.Properties, StringComparer.Ordinal);
        _debugger = builder._debugger;
        if (_debugger.IsAttached)
        {
            _descriptions = new();
        }
    }
    
    // 使用 "application.Services" 作为 Key 存取表示根容器的 IServiceProvider
    public IServiceProvider ApplicationServices
    {
        get
        {
            return GetProperty<IServiceProvider>(ApplicationServicesKey)!;
        }
        set
        {
            SetProperty<IServiceProvider>(ApplicationServicesKey, value);
        }
    }
 
    // 从共享字典中获取服务器提供的特性集合
    public IFeatureCollection ServerFeatures
    {
        get
        {
            return GetProperty<IFeatureCollection>(ServerFeaturesKey)!;
        }
    }
 
    // ApplicationServices 和 ServerFeatures 两个属性的存取实际都是通过这个共享字典来完成的
    public IDictionary<string, object?> Properties { get; }
 
    private T? GetProperty<T>(string key)
    {
        return Properties.TryGetValue(key, out var value) ? (T?)value : default(T);
    }
 
    private void SetProperty<T>(string key, T value)
    {
        Properties[key] = value;
    }
 
    // 注册 Func<RequestDelegate, RequestDelegate> 形式的原始中间件
    public IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware)
    {
        // 收集原始中间件
        _components.Add(middleware);
        _descriptions?.Add(CreateMiddlewareDescription(middleware));
 
        return this;
    }
 
    private static string CreateMiddlewareDescription(Func<RequestDelegate, RequestDelegate> middleware)
    {
        if (middleware.Target != null)
        {
            if (middleware.Method.Name == "CreateMiddleware")
            {
                return middleware.Target.ToString()!;
            }
 
            return middleware.Target.GetType().FullName + "." + middleware.Method.Name;
        }
 
        return middleware.Method.Name.ToString();
    }
 
    // 利用自身创建一个新的 IApplicationBuilder
    public IApplicationBuilder New()
    {
        return new ApplicationBuilder(this);
    }
 
    // 构建请求处理委托链
    public RequestDelegate Build()
    {
        // 创建一个返回 404 处理器，用于循环调用 Func<RequestDelegate, RequestDelegate> 创建请求处理委托链时的末端处理器
        // 如果前序的请求处理器没有返回，则最终会到达这个末端处理器，并返回 404 状态码
        RequestDelegate app = context =>
        {
            // 从 HttpContext.Features 中尝试获取 IEndpointFeature 类型的特性对象
            var endpoint = context.GetEndpoint();
            var endpointRequestDelegate = endpoint?.RequestDelegate;
            // 如果前序的请求处理器将终结点作为特性保存在 HttpContext.Features 特性集合中
            // 表明需要通过 UseEndpoints 注册终结点处理器，这个终结点处理器会从 HttpContext.Features 特性集合中取出终结点完成处理并返回
            // 如果运行到这个末端处理器时候存在终结点，可能没有通过 UseEndpoints 注册终结点处理器，或者有其他不可预知的问题发生
            // 这时候就会抛出 InvalidOperationException
            if (endpointRequestDelegate != null)
            {
                var message =
                    $"The request reached the end of the pipeline without executing the endpoint: '{endpoint!.DisplayName}'. " +
                    $"Please register the EndpointMiddleware using '{nameof(IApplicationBuilder)}.UseEndpoints(...)' if using " +
                    $"routing.";
                throw new InvalidOperationException(message);
            }
 
            // 返回 404 状态码
            // 表明没有命中任何终结点
            if (!context.Response.HasStarted)
            {
                context.Response.StatusCode = StatusCodes.Status404NotFound;
            }
 
            // 通知前序的请求处理器这个请求没有被任何终结点处理器处理
            context.Items[RequestUnhandledKey] = true;
 
            return Task.CompletedTask;
        };

        // 反转 Func<RequestDelegate, RequestDelegate> 原始中间件列表
        // 利用末端处理器，从后向前开始执行 Func<RequestDelegate, RequestDelegate> 构建请求处理委托链
        for (var c = _components.Count - 1; c >= 0; c--)
        {
            app = _components[c](app);
        }

        // 返回位于头部的请求处理器
        return app;
    }
}
```

- IApplicationBuilderFactory

```C#
// 中间件构建者工厂的抽象表示
public interface IApplicationBuilderFactory
{
    // 利用特性集合创建 IApplicationBuilder
    IApplicationBuilder CreateBuilder(IFeatureCollection serverFeatures);
}
```

- ApplicationBuilderFactory

```C#
// IApplicationBuilderFactory 的默认实现
// 利用注入的表示根容器的 IServiceProvider 和由服务器提供的特性集合 IFeatureCollection 创建 ApplicationBuilder
public class ApplicationBuilderFactory : IApplicationBuilderFactory
{
    private readonly IServiceProvider _serviceProvider;
 
    // 注入表示根容器的 IServiceProvider
    public ApplicationBuilderFactory(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
 
    public IApplicationBuilder CreateBuilder(IFeatureCollection serverFeatures)
    {
        return new ApplicationBuilder(_serviceProvider, serverFeatures);
    }
}
```

- RunExtensions

```C#
// 提供中间件注册的扩展方法
public static class RunExtensions
{
    // 注册中间件
    // 这个方法注册的中间件属于短路中间件
    // 因为返回的 RequestDelegate 请求处理器并未包含对传入的 RequestDelegate 的调用，造成短路
    // 此时 handler 参数表示的请求处理器可以就是终结点请求处理器
    public static void Run(this IApplicationBuilder app, RequestDelegate handler)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(handler);
 
        app.Use(_ => handler);
    }
}
```

- IMiddleware

```C#
// 用来定义强类型中间件使用的接口
public interface IMiddleware
{
    Task InvokeAsync(HttpContext context, RequestDelegate next);
}
```

- IMiddlewareFactory

```C#
// 中间件工厂接口
// 用来创建强类型中间件
// 这个服务被注册为 Scoped 生命周期
public interface IMiddlewareFactory
{
    // 创建强类型中间件（实现 IMiddleware）
    IMiddleware? Create(Type middlewareType);
    
    // 对创建的中间件进行回收
    void Release(IMiddleware middleware);
}
```

- MiddlewareFactory

```C#
// IMiddlewareFactory 的默认实现
public class MiddlewareFactory : IMiddlewareFactory
{
    // 表示范围容器的 IServiceProvider
    private readonly IServiceProvider _serviceProvider;
    
    // 因为 IMiddlewareFactory 被注册为 Scoped 生命周期
    // 并且在请求处理阶段由 HttpContext.RequestServices 表示的范围容器创建
    // 所以注入是表示范围容器的 IServiceProvider
    public MiddlewareFactory(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
    
    // 使用范围容器创建强类型中间件
    // 所以强类型中间件可以注册为 Scoped 生命周期
    // 实现强类型中间件在请求作用域下唯一
    public IMiddleware? Create(Type middlewareType)
    {
        return _serviceProvider.GetRequiredService(middlewareType) as IMiddleware;
    }
    
    // 释放
    public void Release(IMiddleware middleware)
    {
        // 不做任何事情
        // 强类型中间件的生命周期由依赖注入容器管理
    }
}
```

- UseMiddlewareExtensions

```C#
// 提供扩展方法用来注册基于类型的中间件
public static class UseMiddlewareExtensions
{
    // 两个用于在中间件中定义的特定方法名
    internal const string InvokeMethodName = "Invoke";
    internal const string InvokeAsyncMethodName = "InvokeAsync";

    // 得到 UseMiddlewareExtensions.GetService 方法的 MethodInfo
    private static readonly MethodInfo GetServiceInfo = typeof(UseMiddlewareExtensions).GetMethod(nameof(GetService), BindingFlags.NonPublic | BindingFlags.Static)!;

    // 注册中间件
    // 使用泛型参数表示的中间件类型
    public static IApplicationBuilder UseMiddleware<TMiddleware>(this IApplicationBuilder app, params object?[] args)
    {
        return app.UseMiddleware(typeof(TMiddleware), args);
    }

    // 注册中间件
    // 强类型中间件是由 HttpContext.RequestServices 表示的范围容器在请求处理阶段创建的（不支持传递外部参数列表）
    // 所以强类型中间可以基于每个请求创建独立的中间件实例
    // 基于约定的中间件是在构建请求处理委托链时通过反射方式创建的
    // 提供给构造函数的参数中，除了 RequestDelegate 类型的参数外，还可以使用传递的外部参数列表
    // 在外部参数列表中不存在对应类型的参数时，还可以由 IApplicationBuilder.ApplicationServices 表示的根容器创建对应参数类型的实例
    // 另外在请求处理阶段，可以由 HttpContext.RequestServices 表示的范围容器创建除 HttpContext 类型参数以外的其他参数类型的实例
    // 所以基于约定的中间件在整个应用程序生命周期内只会创建一个实例
    public static IApplicationBuilder UseMiddleware(
        this IApplicationBuilder app,
        Type middleware,
        params object?[] args)
    {
        // 如果是强类型中间件，则不支持传递参数
        if (typeof(IMiddleware).IsAssignableFrom(middleware))
        {
            if (args.Length > 0)
            {
                throw new NotSupportedException(Resources.FormatException_UseMiddlewareExplicitArgumentsNotSupported(typeof(IMiddleware)));
            }

            // 使用 InterfaceMiddlewareBinder.CreateMiddleware 方法完成从强类型中间件到原始中间件形式的转换工作
            var interfaceBinder = new InterfaceMiddlewareBinder(middleware);
            return app.Use(interfaceBinder.CreateMiddleware);
        }
 
        // 以下是将基于约定的中间件转换为 Func<RequestDelegate, RequestDelegate> 形式的中间件
        // 基于约定中间件必须满足以下条件：
        // 1. 检查中间件类型中是否存在名称为 "Invoke" 或 "InvokeAsync" 的公开实例方法（严格区分大小写）
        // 2. 不能定义 "Invoke" 或 "InvokeAsync" 方法的重载，并且 "Invoke" 和 "InvokeAsync" 方法之间也不能同时存在
        // 3. "Invoke" 或 "InvokeAsync" 方法返回类型必须是 Task
        // 4. "Invoke" 或 "InvokeAsync" 方法必须存在参数，并且第一个参数也必须是 HttpContext 类型
        var methods = middleware.GetMethods(BindingFlags.Instance | BindingFlags.Public);
        MethodInfo? invokeMethod = null;
        foreach (var method in methods)
        {
            if (string.Equals(method.Name, InvokeMethodName, StringComparison.Ordinal) || 
                string.Equals(method.Name, InvokeAsyncMethodName, StringComparison.Ordinal))
            {
                if (invokeMethod is not null)
                {
                    throw new InvalidOperationException(Resources.FormatException_UseMiddleMutlipleInvokes(InvokeMethodName, InvokeAsyncMethodName));
                }

                invokeMethod = method;
            }
        }

        if (invokeMethod is null)
        {
            throw new InvalidOperationException(Resources.FormatException_UseMiddlewareNoInvokeMethod(InvokeMethodName, InvokeAsyncMethodName, middleware));
        }

        if (!typeof(Task).IsAssignableFrom(invokeMethod.ReturnType))
        {
            throw new InvalidOperationException(Resources.FormatException_UseMiddlewareNonTaskReturnType(InvokeMethodName, InvokeAsyncMethodName, nameof(Task)));
        }
 
        var parameters = invokeMethod.GetParameters();
        if (parameters.Length == 0 || parameters[0].ParameterType != typeof(HttpContext))
        {
            throw new InvalidOperationException(Resources.FormatException_UseMiddlewareNoParameters(InvokeMethodName, InvokeAsyncMethodName, nameof(HttpContext)));
        }

        // 使用 ReflectionMiddlewareBinder.CreateMiddleware 方法完成基于约定的中间件到原始中间件形式的转换工作
        var reflectionBinder = new ReflectionMiddlewareBinder(app, middleware, args, invokeMethod, parameters);
        return app.Use(reflectionBinder.CreateMiddleware);
    }

    // 强类型中间件绑定器
    // 用来将强类型中间转换为 Func<RequestDelegate, RequestDelegate> 形式的原始中间件
    private sealed class InterfaceMiddlewareBinder
    {
        private readonly Type _middlewareType;
 
        public InterfaceMiddlewareBinder(Type middlewareType)
        {
            _middlewareType = middlewareType;
        }
 
        // 中间件的原始形式
        public RequestDelegate CreateMiddleware(RequestDelegate next)
        {
            // 强类型中间件的创建是在请求处理阶段
            // 所以如果将强类型中间件注册为 Scoped 生命周期的话
            // 那通过 HttpContext.RequestServices 范围容器创建的强类型中间件实例就是针对当前请求作用域下的
            return async context =>
            {
                // 使用 HttpContext.RequestServices 表示的范围容器创建 IMiddlewareFactory
                // 所以 IMiddlewareFacotry 的实现类型会被注入 HttpContext.RequestServices 表示的范围容器
                var middlewareFactory = (IMiddlewareFactory?)context.RequestServices.GetService(typeof(IMiddlewareFactory));
                if (middlewareFactory == null)
                {
                    
                    throw new InvalidOperationException(Resources.FormatException_UseMiddlewareNoMiddlewareFactory(typeof(IMiddlewareFactory)));
                }

                // 使用 IMiddlewareFactory 创建中间件实例
                // 因为强类型中间件是由范围容器创建的
                // 所以可以在注册强类型中间件时注册为 Scoped 生命周期
                // 这样每次请求都会创建一个新的强类型中间件实例
                var middleware = middlewareFactory.Create(_middlewareType);
                if (middleware == null)
                {
                    // The factory returned null, it's a broken implementation
                    throw new InvalidOperationException(Resources.FormatException_UseMiddlewareUnableToCreateMiddleware(middlewareFactory.GetType(), _middlewareType));
                }
 
                try
                {
                    // 调用 IMiddleware.InvokeAsync 方法
                    await middleware.InvokeAsync(context, next);
                }
                finally
                {
                    middlewareFactory.Release(middleware);
                }
            };
        }
 
        public override string ToString() => _middlewareType.ToString();
    }

    // 基于约定的中间件绑定器
    // 用来将基于约定的中间转换为 Func<RequestDelegate, RequestDelegate> 形式的原始中间件
    private sealed class ReflectionMiddlewareBinder
    {
        private readonly IApplicationBuilder _app;
        private readonly Type _middleware;
        private readonly object?[] _args;
        private readonly MethodInfo _invokeMethod;
        private readonly ParameterInfo[] _parameters;
 
        public ReflectionMiddlewareBinder(
            IApplicationBuilder app,
            Type middleware,
            object?[] args,
            MethodInfo invokeMethod,
            ParameterInfo[] parameters)
        {
            _app = app;
            _middleware = middleware;
            _args = args;
            _invokeMethod = invokeMethod;
            _parameters = parameters;
        }

        // 中间件的原始形式
        public RequestDelegate CreateMiddleware(RequestDelegate next)
        {
            // 创建中间件的构造函数实参列表
            // 除了 RequestDelegate 类型参数外
            // 其他参数可以从外部的实参列、依赖注入容器或者类型默认值提供
            // 所以基于约定的中间件构造函数中必须包含代表后续请求处理器的 RequestDelegate 类型的参数
            var ctorArgs = new object[_args.Length + 1];
            ctorArgs[0] = next;
            Array.Copy(_args, 0, ctorArgs, 1, _args.Length);
            // 创建基于约定的中间件类型实例
            // 步骤如下：
            // 1. 根据构造函数实参列表的每个类型查找最佳匹配构造函数
            //    最佳匹配构造函数的参数列表类型必须包含实参列表中所有的参数类型，并且参数列表越长越好
            // 2. 根据最佳匹配构造函数的参数列表尝试从实参列表中得到对应的传参值
            //    优先使用实参列表中对应位置的值
            //    如果没有则利用 IApplicationBuilder.ApplicationServices 表示的根容器创建对应类型的实例作为实参
            // 3. 如果没有注册对应的服务，则尝试使用对应类型的默认值作为实参
            // 4. 最后通过反射方式调用最佳匹配构造函数创建基于约定的中间件实例
            var instance = ActivatorUtilities.CreateInstance(_app.ApplicationServices, _middleware, ctorArgs);
            // 如果 "Invoke" 或 "InvokeAsync" 方法的参数个数为 1
            // 表明函数只有 HttpContext 类型参数，并且方法的返回值类型为 Task
            // 直接利用 MethodInfo 方法创建 RequestDelegate 委托
            if (_parameters.Length == 1)
            {
                return (RequestDelegate)_invokeMethod.CreateDelegate(typeof(RequestDelegate), instance);
            }
            
            // 如果 "Invoke" 或 "InvokeAsync" 方法有除 HttpContext 类型参数外还有其他参数
            // 则需要确定允许环境是否支持运行时动态代码编译
            // 如果是则使用表达式树构建运行时动态代码后编译成 Func<object, HttpContext, IServiceProvider, Task> 委托执行
            // 否则使用反射方式调用 "Invoke" 或 "InvokeAsync" 方法
            var factory = RuntimeFeature.IsDynamicCodeCompiled
                ? CompileExpression<object>(_invokeMethod, _parameters)
                : ReflectionFallback<object>(_invokeMethod, _parameters);

            // 基于约定的中间件是在构造请求处理委托链时创建的
            // 所以在整个应用程序生命周期中，基于约定的中间件实例是以单例形式存在的
            // 但 "Invoke" 或 "InvokeAsync" 方法的参数可以由 HttpContext.RequestServices 表示的范围容器创建
            return context =>
            {
                // 可以使用 HttpContext.RequestServices 表示的范围容器创建除 HttpContext 类型参数以外的其他参数实例
                var serviceProvider = context.RequestServices ?? _app.ApplicationServices;
                if (serviceProvider == null)
                {
                    throw new InvalidOperationException(Resources.FormatException_UseMiddlewareIServiceProviderNotAvailable(nameof(IServiceProvider)));
                }
 
                return factory(instance, context, serviceProvider);
            };
        }
 
        public override string ToString() => _middleware.ToString();
    }

    // 内部通过反射方式调用 "Invoke" 或 "InvokeAsync" 方法
    private static Func<T, HttpContext, IServiceProvider, Task> ReflectionFallback<T>(MethodInfo methodInfo, ParameterInfo[] parameters)
    {
        Debug.Assert(!RuntimeFeature.IsDynamicCodeSupported, "Use reflection fallback when dynamic code is not supported.");
 
        for (var i = 1; i < parameters.Length; i++)
        {
            var parameterType = parameters[i].ParameterType;
            // 不支持按地址传递的参数
            if (parameterType.IsByRef)
            {
                throw new NotSupportedException(Resources.FormatException_InvokeDoesNotSupportRefOrOutParams(InvokeMethodName));
            }
        }
 
        return (middleware, context, serviceProvider) =>
        {
            var methodArguments = new object[parameters.Length];
            // 第一个实参赋给 HttpContext 类型参数
            methodArguments[0] = context;
            for (var i = 1; i < parameters.Length; i++)
            {
                // 利用范围容器创建除第一个参数以外的其他参数
                methodArguments[i] = GetService(serviceProvider, parameters[i].ParameterType, methodInfo.DeclaringType!);
            }

            // 通过反射调用 "Invoke" 或 "InvokeAsync" 方法
            // 反射方式会在每次调用前对元数据进行字符串查找，性能较差
            return (Task)methodInfo.Invoke(middleware, BindingFlags.DoNotWrapExceptions, binder: null, methodArguments, culture: null)!;
        };
    }
 
    // 内部通过使用构建动态代码后编译表达式成委托执行 "Invoke" 或 "InvokeAsync" 方法
    private static Func<T, HttpContext, IServiceProvider, Task> CompileExpression<T>(MethodInfo methodInfo, ParameterInfo[] parameters)
    {
        Debug.Assert(RuntimeFeature.IsDynamicCodeSupported, "Use compiled expression when dynamic code is supported.");
 
        // 中间件的实际类型
        // 根据调用来看，此处是 object 类型
        var middleware = typeof(T);
 
        // 创建 Func<T, HttpContext, IServiceProvider, Task> 委托原型方法需要的三个入参
        // 分别是：
        // 1. 表示中间件实例，参数名 "middleware"，object 类型
        // 2. 表示请求上下文，参数名 "httpContext"，HttpContext 类型
        // 3. 表示范围容器，参数名 "serviceProvider"，IServiceProvider 类型
        var instanceArg = Expression.Parameter(middleware, "middleware");
        var httpContextArg = Expression.Parameter(typeof(HttpContext), "httpContext");
        var providerArg = Expression.Parameter(typeof(IServiceProvider), "serviceProvider");

        // 创建调用 "Invoke" 或 "InvokeAsync" 方法的实参列表
        var methodArguments = new Expression[parameters.Length];
        // 利用 "httpContext" 参数作为第一个实参
        methodArguments[0] = httpContextArg;
        for (var i = 1; i < parameters.Length; i++)
        {
            var parameterType = parameters[i].ParameterType;
            if (parameterType.IsByRef)
            {
                throw new NotSupportedException(Resources.FormatException_InvokeDoesNotSupportRefOrOutParams(InvokeMethodName));
            }
 
            // 利用 "serviceProvider" 参数和常量类型作为入参
            var parameterTypeExpression = new Expression[]
            {
                providerArg,
                Expression.Constant(parameterType, typeof(Type)),
                Expression.Constant(methodInfo.DeclaringType, typeof(Type))
            };

            // 调用 UseMiddlewareExtensions.GetService 静态方法
            // 为 "Invoke" 或 "InvokeAsync" 方法创建除第一个参数以外的实参
            var getServiceCall = Expression.Call(GetServiceInfo, parameterTypeExpression);
            // 对实参进行强制类型转换为对应的类型
            methodArguments[i] = Expression.Convert(getServiceCall, parameterType);
        }
 
        // 将 "middleware" 参数，object 类型，强制类型转换为中间件的实际类型
        Expression middlewareInstanceArg = instanceArg;
        if (methodInfo.DeclaringType != null && methodInfo.DeclaringType != typeof(T))
        {
            middlewareInstanceArg = Expression.Convert(middlewareInstanceArg, methodInfo.DeclaringType);
        }
        
        // 通过中间件实例调用 "Invoke" 或 "InvokeAsync" 方法
        var body = Expression.Call(middlewareInstanceArg, methodInfo, methodArguments);
 
        // 创建 Expression<Func<T, HttpContext, IServiceProvider, Task>> 表达式
        var lambda = Expression.Lambda<Func<T, HttpContext, IServiceProvider, Task>>(body, instanceArg, httpContextArg, providerArg);

        // 将表达式编译成 Func<T, HttpContext, IServiceProvider, Task> 委托
        return lambda.Compile();
    }
 
    // 通过范围容器创建对应类型的实例
    private static object GetService(IServiceProvider sp, Type type, Type middleware)
    {
        var service = sp.GetService(type);
        if (service == null)
        {
            throw new InvalidOperationException(Resources.FormatException_InvokeMiddlewareNoService(type, middleware));
        }
 
        return service;
    }
}
```

- HttpContext

```C#
// 表示 HTTP 上下文
// DefaultHttpContext 是 HttpContext 抽象类的默认实现
// DefaultHttpContext 并不负责具体属性值的提供，它的核心功能只是代理
// 通过构造 DefaultHttpContext 时由不同服务器传入的 IFeatureCollection 特性集合
// 利用相应的特性类型（一般为接口类型）从特性集合中得到特性对象
public abstract class HttpContext
{
    // 不同服务器所提供的特性集合
    public abstract IFeatureCollection Features { get; }

    // 表示 HTTP 请求
    public abstract HttpRequest Request { get; }

    // 表示 HTTP 响应
    public abstract HttpResponse Response { get; }

    // 表示范围容器的 IServiceProvider
    // 为每个请求作用域提供服务
    public abstract IServiceProvider RequestServices { get; set; }

    // 表示当前用户身份的声明持有者
    public abstract ClaimsPrincipal User { get; set; }

    // 用来在请求处理阶段在管道中共享数据的字典
    public abstract IDictionary<object, object?> Items { get; set; }

    // 表示连接信息
    public abstract ConnectionInfo Connection { get; }

    // 表示当前会话
    public abstract ISession Session { get; set; }

    // 调试追踪 Id
    public abstract string TraceIdentifier { get; set; } 
}
```

- HttpRequest

```C#
// 表示 HTTP 请求
// DefaultHttpRequest 是 HttpRequest 抽象类的默认实现
// DefaultHttpRequest 并不负责具体属性值的提供，它的核心功能只是代理
// 通过构造 DefaultHttpRequest 时传入的 DefaultHttpContext
// 通过 DefaultHttpContext.Features 保存着由不同服务器创捷的 IFeatureCollection 列表
// 利用相应的特性类型（一般为接口类型）从特性集合中得到特性对象
public abstract class HttpRequest
{
    public abstract HttpContext HttpContext { get; }
 
    // HTTP 请求方法谓词
    public abstract string Method { get; set; }
 
    // 表示请求的协议 "http" 或 "https"
    public abstract string Scheme { get; set; }
 
    // 是否是一个使用了 TSL/SSL 的 https 请求
    public abstract bool IsHttps { get; set; }
 
    // 请求目标地址的主机名（含端口号）
    public abstract HostString Host { get; set; }
 
    // 请求基础路径
    public abstract PathString PathBase { get; set; }
 
    // 相对于 PathBase 的路径
    public abstract PathString Path { get; set; }
 
    // 查询字符串的原始形式
    public abstract QueryString QueryString { get; set; }
    
    // 查询字符串的 Key/Value 形式
    // 由于查询字符串可以有多个相同的 Key，所以 Value 是一个字符串列表
    public abstract IQueryCollection Query { get; set; }
 
    // http 协议版本
    // 比如：HTTP/1.1 等
    public abstract string Protocol { get; set; }
    
    // 请求头，用 Key/Value 形式表示
    // 由于请求头可以有多个相同的 Key，所以 Value 是一个字符串列表
    public abstract IHeaderDictionary Headers { get; }
 
    // 请求携带的 Cookie 列表，用 Key/Value 形式表示
    public abstract IRequestCookieCollection Cookies { get; set; }
 
    // 请求主体内容的字节长度
    public abstract long? ContentLength { get; set; }
 
    // 请求主体内容的媒体类型
    // 比如：text/html、text/json 等
    public abstract string? ContentType { get; set; }
 
    // 请求主体内容的输入流
    public abstract Stream Body { get; set; }
 
    // 是否为表单媒体类型
    // 表单媒体类型一般为 application/x-www-form-urlencoded 和 multipart/form-data
    public abstract bool HasFormContentType { get; }
 
    // 表单内容，用 Key/Value 形式表示
    // 由于表单内容可以有多个相同的 Key，所以 Value 是一个字符串列表
    public abstract IFormCollection Form { get; set; }
 
    // 读取表单内容
    public abstract Task<IFormCollection> ReadFormAsync(CancellationToken cancellationToken = new CancellationToken());
}
```

- HttpResponse

```C#
// 表示 HTTP 响应
// DefaultHttpResponse 是 HttpRequest 抽象类的默认实现
// DefaultHttpResponse 并不负责具体属性值的提供，它的核心功能只是代理
// 通过构造 DefaultHttpResponse 时传入的 DefaultHttpContext
// 通过 DefaultHttpContext.Features 保存着由不同服务器创捷的 IFeatureCollection 列表
// 利用相应的特性类型（一般为接口类型）从特性集合中得到特性对象
public abstract class HttpResponse
{
    public abstract HttpContext HttpContext { get; }
 
    // 响应状态码
    public abstract int StatusCode { get; set; }
 
    // 响应头，用 Key/Value 形式表示
    // 由于响应头可以有多个相同的 Key，所以 Value 是一个字符串列表
    public abstract IHeaderDictionary Headers { get; }
 
    // 响应主体内容的输出流
    public abstract Stream Body { get; set; }
 
    // 响应主体内容的字节长度
    public abstract long? ContentLength { get; set; }
 
    // 响应主体内容的媒体类型
    public abstract string? ContentType { get; set; }
 
    // 用于设置响应 Cookie
    public abstract IResponseCookies Cookies { get; }
 
    // 响应首部是否已经开始发送
    public abstract bool HasStarted { get; }
 
    // 注册回调，在响应开发发送时触发
    public abstract void OnStarting(Func<object, Task> callback, object state);
 
    // 注册回调，在响应开发发送时触发
    public virtual void OnStarting(Func<Task> callback) => OnStarting(_callbackDelegate, callback);
 
    // 注册回调，在响应发送完成后触发
    public abstract void OnCompleted(Func<object, Task> callback, object state);

    // 注册回调，在响应发送完成后触发
    public virtual void OnCompleted(Func<Task> callback) => OnCompleted(_callbackDelegate, callback);
 
    // 注册响应完成后需要回收的对象
    public virtual void RegisterForDispose(IDisposable disposable) => OnCompleted(_disposeDelegate, disposable);
 
    // 注册响应完成后需要回收的对象
    public virtual void RegisterForDisposeAsync(IAsyncDisposable disposable) => OnCompleted(_disposeDelegate, disposable);
 
    // 发送针对指定地址的 301（永久）或 302（临时）重定向响应消息
    public virtual void Redirect(string location) => Redirect(location, permanent: false);
 
    // 发送针对指定地址的 301（永久）或 302（临时）重定向响应消息
    public abstract void Redirect(string location, bool permanent);
}
```

- IFeatureCollection

```C#
// 表示由不同服务器提供的特性集合
// 本质是一个 Key/Value 类型分别为 Type/object 的字典
// Key 表示特性 TFeature 的类型（一般为接口类型）
// Value 表示特性 TFeature 对象本身
public interface IFeatureCollection : IEnumerable<KeyValuePair<Type, object>>
{
    // 是否只读
    // 实现类型应该永远返回 false，支持可读可写
    bool IsReadOnly { get; }
 
    // IFeature 的对象版本
    // 向特性集合添加或删除特性都会造成版本自增
    int Revision { get; }
 
    // 通过索引器利用特性类型添加或得到特性对象
    object? this[Type key] { get; set; }
    
    // 通过 TFeature 泛型参数类型得到特性对象
    TFeature? Get<TFeature>();
 
    // 向特性集合添加指定 TFeature 泛型参数类型的特性对象
    void Set<TFeature>(TFeature? instance);
}
```

- FeatureCollection

```C#
// IFeatureCollection 的默认实现
public class FeatureCollection : IFeatureCollection
{
    private static readonly KeyComparer FeatureKeyComparer = new KeyComparer();
    private readonly IFeatureCollection? _defaults;
    private readonly int _initialCapacity;
    private IDictionary<Type, object>? _features;
    private volatile int _containerRevision;
    
    // 用来创建一个空特性集合
    public FeatureCollection()
    {
    }
    
    // 用来创建一个初始容量的空特性集合
    public FeatureCollection(int initialCapacity)
    {
        ArgumentOutOfRangeThrowHelper.ThrowIfNegative(initialCapacity);
 
        _initialCapacity = initialCapacity;
    }
    
    // 用来创建一个空特性集合
    // 并传入一个备用特性集合
    public FeatureCollection(IFeatureCollection defaults)
    {
        _defaults = defaults;
    }
 
    // 特性集合的版本
    // 每次添加或修改特性集合都会自增版本
    // 如果存在备用特性集合则版本号会加上备用特性集合的 Revision 属性值
    public virtual int Revision
    {
        get { return _containerRevision + (_defaults?.Revision ?? 0); }
    }
 
    // 永远返回 fasle
    public bool IsReadOnly { get { return false; } }
 
    public object? this[Type key]
    {
        get
        {
            ArgumentNullThrowHelper.ThrowIfNull(key);

            // 如果没有可以从备用特性集合获取
            return _features != null && _features.TryGetValue(key, out var result) ? result : _defaults?[key];
        }
        set
        {
            ArgumentNullThrowHelper.ThrowIfNull(key);

            // 可以通过传 null 来从特性集合中删除对应类型的特性
            if (value == null)
            {
                if (_features != null && _features.Remove(key))
                {
                    _containerRevision++;
                }
                return;
            }
 
            if (_features == null)
            {
                _features = new Dictionary<Type, object>(_initialCapacity);
            }
            _features[key] = value;
            // 版本自增
            _containerRevision++;
        }
    }
 
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
 
    public IEnumerator<KeyValuePair<Type, object>> GetEnumerator()
    {
        if (_features != null)
        {
            foreach (var pair in _features)
            {
                yield return pair;
            }
        }
 
        if (_defaults != null)
        {
            foreach (var pair in _features == null ? _defaults : _defaults.Except(_features, FeatureKeyComparer))
            {
                yield return pair;
            }
        }
    }
    
    // 内部是对索引器的访问，得到指定类型的特性对象
    public TFeature? Get<TFeature>()
    {
        if (typeof(TFeature).IsValueType)
        {
            var feature = this[typeof(TFeature)];
            if (feature is null && Nullable.GetUnderlyingType(typeof(TFeature)) is null)
            {
                throw new InvalidOperationException(
                    $"{typeof(TFeature).FullName} does not exist in the feature collection " +
                    $"and because it is a struct the method can't return null. Use 'featureCollection[typeof({typeof(TFeature).FullName})] is not null' to check if the feature exists.");
            }
            return (TFeature?)feature;
        }
        return (TFeature?)this[typeof(TFeature)];
    }
 
    // 内部是对索引器的访问，添加指定类型的特性对象
    public void Set<TFeature>(TFeature? instance)
    {
        this[typeof(TFeature)] = instance;
    }
 
    private int GetCount() => this.Count();
 
    // 在通过迭代器返回时将自身特性集合和备用特性集合中相同的特性做去重处理
    private sealed class KeyComparer : IEqualityComparer<KeyValuePair<Type, object>>
    {
        public bool Equals(KeyValuePair<Type, object> x, KeyValuePair<Type, object> y)
        {
            return x.Key.Equals(y.Key);
        }
 
        public int GetHashCode(KeyValuePair<Type, object> obj)
        {
            return obj.Key.GetHashCode();
        }
    }
}
```

- IHttpContextAccessor

```C#
// 用来服务注册 IHttpContextAccessor 的接口
// 通过依赖注入得到服务实例，为第三方组件提供访问 HttpContext 的能力
public interface IHttpContextAccessor
{
    HttpContext? HttpContext { get; set; }
}
```

- HttpContextAccessor

```C#
// IHttpContextAccessor 的默认实现
public class HttpContextAccessor : IHttpContextAccessor
{
    // 利用 AsyncLocal<HttpContextHolder> 自身作为 Key 将保存 HttpContext 保存在 ExecutionContext 中
    // 这样即使发生线程切换，也能利用线程切换时 ExecutionContext 流动的特点，实现在异步编程中访问到同一个 HttpContext
    private static readonly AsyncLocal<HttpContextHolder> _httpContextCurrent = new AsyncLocal<HttpContextHolder>();
 
    public HttpContext? HttpContext
    {
        get
        {
            return _httpContextCurrent.Value?.Context;
        }
        set
        {
            var holder = _httpContextCurrent.Value;
            // 每次赋值都会首先清空保存的 HttpContext
            // 所以可以通过传 null 来重置
            if (holder != null)
            {
                holder.Context = null;
            }
 
            if (value != null)
            {
                _httpContextCurrent.Value = new HttpContextHolder { Context = value };
            }
        }
    }
 
    private sealed class HttpContextHolder
    {
        public HttpContext? Context;
    }
}
```

- HttpServiceCollectionExtensions

```C#
// 用来注册 IHttpContextAccessor
public static class HttpServiceCollectionExtensions
{
    public static IServiceCollection AddHttpContextAccessor(this IServiceCollection services)
    {
        ArgumentNullException.ThrowIfNull(services);
 
        // 注册为 Singleton 生命周期
        // 因为本质是从 ExecutionContext 中获取
        services.TryAddSingleton<IHttpContextAccessor, HttpContextAccessor>();
        return services;
    }
}
```

- IHttpContextFactory

```C#
// HttpContext 工厂的抽象表示
// 负责针对每个请求创建 HttpContext
// 并在完成请求响应后释放
public interface IHttpContextFactory
{
    // 利用服务器提供的 IFeatureCollection 特性集合创建 HttpContext
    HttpContext Create(IFeatureCollection featureCollection);
    
    // 回收 HttpContext
    // 核心是将 IHttpContextAccessor.HttpContext 属性重置
    void Dispose(HttpContext httpContext);
}
```

- DefaultHttpContextFactory

```C#
// IHttpContextFactory 的默认实现
public class DefaultHttpContextFactory : IHttpContextFactory
{
    private readonly IHttpContextAccessor? _httpContextAccessor;
    private readonly FormOptions _formOptions;
    private readonly IServiceScopeFactory _serviceScopeFactory;
 
    // 因为 IHttpContextFactory 注册 Singleton 生命周期
    // 所以注入表示根容器的 IServiceProvider
    public DefaultHttpContextFactory(IServiceProvider serviceProvider)
    {
        _httpContextAccessor = serviceProvider.GetService<IHttpContextAccessor>();
        _formOptions = serviceProvider.GetRequiredService<IOptions<FormOptions>>().Value;
        // 如果使用的是默认的依赖注入框架
        // 那么得到 IServiceScopeFactory 就是 ServiceProvider.Root 属性保存的 ServiceProviderEngineScope
        _serviceScopeFactory = serviceProvider.GetRequiredService<IServiceScopeFactory>();
    }
 
    internal IHttpContextAccessor? HttpContextAccessor => _httpContextAccessor;
 
    public HttpContext Create(IFeatureCollection featureCollection)
    {
        ArgumentNullException.ThrowIfNull(featureCollection);

        // 利用有不同服务器提供的 IFeatureCollection 特性集合创建 DefaultHttpContext
        var httpContext = new DefaultHttpContext(featureCollection);
        Initialize(httpContext, featureCollection);
        return httpContext;
    }
 
    // 初始化 HttpContext
    // 最终会将 IServiceScopeFactory 保存到 HttpContext.ServiceScopeFactory 属性中
    internal void Initialize(DefaultHttpContext httpContext, IFeatureCollection featureCollection)
    {
        Debug.Assert(featureCollection != null);
        Debug.Assert(httpContext != null);
 
        // 对 HttpContext 初始化
        httpContext.Initialize(featureCollection);
 
        if (_httpContextAccessor != null)
        {
            _httpContextAccessor.HttpContext = httpContext;
        }
 
        httpContext.FormOptions = _formOptions;
        // HttpContext.RequestServices 属性保存的表示范围容器的 IServiceProvider 都是由 IServiceScopeFactory 创建的
        // 在 DefaultHttpContext 内部通过 IServiceProviderFeature 的实现类型 RequestServicesFeature 
        // 利用 IServiceScopeFactory 完成范围容器 IServiceProvider 的创建
        httpContext.ServiceScopeFactory = _serviceScopeFactory;
    }
 
    public void Dispose(HttpContext httpContext)
    {
        if (_httpContextAccessor != null)
        {
            _httpContextAccessor.HttpContext = null;
        }
    }
 
    internal void Dispose(DefaultHttpContext httpContext)
    {
        if (_httpContextAccessor != null)
        {
            _httpContextAccessor.HttpContext = null;
        }
 
        httpContext.Uninitialize();
    }
}
```

- IServiceProvidersFeature

```C#
// 表示范围容器的特性接口
public interface IServiceProvidersFeature
{
    IServiceProvider RequestServices { get; set; }
}
```

- RequestServicesFeature

```C#
// IServiceProvidersFeature 默认实现
// 主要功能：
// 1. 利用 IServiceScopeFactory 为每个请求的 HttpContext 创建表示范围容器的 IServiceProvider
// 2. 注册 HttpResponse.RegisterForDisposeAsync 方法在每个请求响应完成后执行回收操作（主要用来释放表示范围容器的 IServiceProvider）
public class RequestServicesFeature : IServiceProvidersFeature, IDisposable, IAsyncDisposable
{
    private readonly IServiceScopeFactory? _scopeFactory;
    private IServiceProvider? _requestServices;
    private IServiceScope? _scope;
    private bool _requestServicesSet;
    private readonly HttpContext _context;
 
    public RequestServicesFeature(HttpContext context, IServiceScopeFactory? scopeFactory)
    {
        _context = context;
        _scopeFactory = scopeFactory;
    }
 
    // 利用 IServiceScopeFactory 创建范围容器
    public IServiceProvider RequestServices
    {
        get
        {
            if (!_requestServicesSet && _scopeFactory != null)
            {
                // 将自身注册成响应完成回收对象
                _context.Response.RegisterForDisposeAsync(this);
                _scope = _scopeFactory.CreateScope();
                _requestServices = _scope.ServiceProvider;
                _requestServicesSet = true;
            }
            return _requestServices!;
        }
        set
        {
            _requestServices = value;
            _requestServicesSet = true;
        }
    }
 
    // 响应完成后调用回收范围容器
    public ValueTask DisposeAsync()
    {
        switch (_scope)
        {
            case IAsyncDisposable asyncDisposable:
                var vt = asyncDisposable.DisposeAsync();
                if (!vt.IsCompletedSuccessfully)
                {
                    return Awaited(this, vt);
                }
                vt.GetAwaiter().GetResult();
                break;
            case IDisposable disposable:
                disposable.Dispose();
                break;
        }
 
        _scope = null;
        _requestServices = null;
 
        return default;
 
        static async ValueTask Awaited(RequestServicesFeature servicesFeature, ValueTask vt)
        {
            await vt;
            servicesFeature._scope = null;
            servicesFeature._requestServices = null;
        }
    }
    
    // 响应完成后调用回收范围容器
    public void Dispose()
    {
        DisposeAsync().AsTask().GetAwaiter().GetResult();
    }
}
```

## 服务器

- IServer

```C#
// Web 服务器的抽象表示
public interface IServer : IDisposable
{
    // 服务器提供的特性集合
    IFeatureCollection Features { get; }
 
    // 启动服务器
    // 利用服务器提供的特性集合
    // 调用 IHttpApplication<TContext>.CreateContext 方法创建 HttpContext
    // 调用 IHttpApplication<TContext>.ProcessRequestAsync 方法将得到的 HttpContext 交由后续的请求处理器处理
    // 调用 IHttpApplication<TContext>.DisposeContext 方法回收 HttpContext
    Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken) where TContext : notnull;
 
    // 停止服务器
    Task StopAsync(CancellationToken cancellationToken);
}
```

- IHttpApplication\<TContext\>

```C#
// 表示处理请求的应用程序
public interface IHttpApplication<TContext> where TContext : notnull
{
    // 利用服务器提供的特性集合创建 TContext
    TContext CreateContext(IFeatureCollection contextFeatures);
 
    // 将创建的 TContext 交由后续的请求处理器处理
    Task ProcessRequestAsync(TContext context);
 
    // 响应完成后回收 TContext
    void DisposeContext(TContext context, Exception? exception);
}
```

- HostingApplication

```C#
// IHttpApplication<TContext> 的默认实现
// 主要功能：
// 1. 利用服务器提供的特性集合创建 HttpContext
//    本质是调用 IHttpContextFactory.Create 方法
// 2. 将 HttpContext 交由后续的请求处理器处理
// 3. 利用 IHttpContextFactory 回收 HttpContext
internal sealed class HostingApplication : IHttpApplication<HostingApplication.Context>
{
    // 表示由中间件构建的请求处理委托链的第一个处理器
    private readonly RequestDelegate _application;
    private readonly IHttpContextFactory? _httpContextFactory;
    private readonly DefaultHttpContextFactory? _defaultHttpContextFactory;
    private readonly HostingApplicationDiagnostics _diagnostics;
 
    public HostingApplication(
        RequestDelegate application,
        ILogger logger,
        DiagnosticListener diagnosticSource,
        ActivitySource activitySource,
        DistributedContextPropagator propagator,
        IHttpContextFactory httpContextFactory,
        HostingEventSource eventSource,
        HostingMetrics metrics)
    {
        _application = application;
        _diagnostics = new HostingApplicationDiagnostics(logger, diagnosticSource, activitySource, propagator, eventSource, metrics);
        if (httpContextFactory is DefaultHttpContextFactory factory)
        {
            _defaultHttpContextFactory = factory;
        }
        else
        {
            _httpContextFactory = httpContextFactory;
        }
    }
 
    public Context CreateContext(IFeatureCollection contextFeatures)
    {
        Context? hostContext;
        if (contextFeatures is IHostContextContainer<Context> container)
        {
            hostContext = container.HostContext;
            if (hostContext is null)
            {
                hostContext = new Context();
                container.HostContext = hostContext;
            }
        }
        else
        {
            hostContext = new Context();
        }
 
        HttpContext httpContext;
        if (_defaultHttpContextFactory != null)
        {
            var defaultHttpContext = (DefaultHttpContext?)hostContext.HttpContext;
            if (defaultHttpContext is null)
            {
                // 通过 DefaultHttpContextFactory 利用服务器特性集合创建 DefaultHttpContext
                httpContext = _defaultHttpContextFactory.Create(contextFeatures);
                // 保存到 Context.HttpContext 中
                hostContext.HttpContext = httpContext;
            }
            else
            {
                _defaultHttpContextFactory.Initialize(defaultHttpContext, contextFeatures);
                httpContext = defaultHttpContext;
            }
        }
        else
        {
            httpContext = _httpContextFactory!.Create(contextFeatures);
            hostContext.HttpContext = httpContext;
        }
 
        _diagnostics.BeginRequest(httpContext, hostContext);
        return hostContext;
    }
 
    public Task ProcessRequestAsync(Context context)
    {
        // 将 HttpContext 交由后续的请求处理器处理
        return _application(context.HttpContext!);
    }
 
    public void DisposeContext(Context context, Exception? exception)
    {
        var httpContext = context.HttpContext!;
        _diagnostics.RequestEnd(httpContext, exception, context);
 
        if (_defaultHttpContextFactory != null)
        {
            // 利用 DefaultHttpContextFactory 释放 HttpContext
            // 本质是将 IHttpContextAccessor.HttpContext 属性重置
            _defaultHttpContextFactory.Dispose((DefaultHttpContext)httpContext);
 
            if (_defaultHttpContextFactory.HttpContextAccessor != null)
            {
                context.HttpContext = null;
            }
        }
        else
        {
            _httpContextFactory!.Dispose(httpContext);
        }
 
        _diagnostics.ContextDisposed(context);
 
        context.Reset();
    }
 
    // 对 HttpContext 的封装，同时承载一些诊断相关的信息
    internal sealed class Context
    {
        public HttpContext? HttpContext { get; set; }
        public IDisposable? Scope { get; set; }
        public Activity? Activity
        {
            get => HttpActivityFeature?.Activity;
            set
            {
                if (HttpActivityFeature is null)
                {
                    if (value != null)
                    {
                        HttpActivityFeature = new HttpActivityFeature(value);
                    }
                }
                else
                {
                    HttpActivityFeature.Activity = value!;
                }
            }
        }
        internal HostingRequestStartingLog? StartLog { get; set; }
 
        public long StartTimestamp { get; set; }
        internal bool HasDiagnosticListener { get; set; }
        public bool MetricsEnabled { get; set; }
        public bool EventLogEnabled { get; set; }
 
        internal HttpActivityFeature? HttpActivityFeature;
        internal HttpMetricsTagsFeature? MetricsTagsFeature;
 
        public void Reset()
        {
            Scope = null;
            Activity = null;
            StartLog = null;
 
            StartTimestamp = 0;
            HasDiagnosticListener = false;
            MetricsEnabled = false;
            EventLogEnabled = false;
            MetricsTagsFeature?.TagsList.Clear();
        }
    }
}
```

- GenericWebHostServiceOptions

```C#
// 通用 Web 主机选项
internal sealed class GenericWebHostServiceOptions
{
    public Action<IApplicationBuilder>? ConfigureApplication { get; set; }
    
    public WebHostOptions WebHostOptions { get; set; } = default!;
 
    public AggregateException? HostingStartupExceptions { get; set; }
}
```

- GenericWebHostService

```C#
// 通用 Web 主机服务
internal sealed partial class GenericWebHostService : IHostedService
{
    public GenericWebHostService(IOptions<GenericWebHostServiceOptions> options,
                                 IServer server,
                                 ILoggerFactory loggerFactory,
                                 DiagnosticListener diagnosticListener,
                                 ActivitySource activitySource,
                                 DistributedContextPropagator propagator,
                                 IHttpContextFactory httpContextFactory,
                                 IApplicationBuilderFactory applicationBuilderFactory,
                                 IEnumerable<IStartupFilter> startupFilters,
                                 IConfiguration configuration,
                                 IWebHostEnvironment hostingEnvironment,
                                 HostingMetrics hostingMetrics)
    {
        Options = options.Value;
        Server = server;
        Logger = loggerFactory.CreateLogger("Microsoft.AspNetCore.Hosting.Diagnostics");
        LifetimeLogger = loggerFactory.CreateLogger("Microsoft.Hosting.Lifetime");
        DiagnosticListener = diagnosticListener;
        ActivitySource = activitySource;
        Propagator = propagator;
        HttpContextFactory = httpContextFactory;
        ApplicationBuilderFactory = applicationBuilderFactory;
        StartupFilters = startupFilters;
        Configuration = configuration;
        HostingEnvironment = hostingEnvironment;
        HostingMetrics = hostingMetrics;
    }
 
    public GenericWebHostServiceOptions Options { get; }
    public IServer Server { get; }
    public ILogger Logger { get; }
    public ILogger LifetimeLogger { get; }
    public DiagnosticListener DiagnosticListener { get; }
    public ActivitySource ActivitySource { get; }
    public DistributedContextPropagator Propagator { get; }
    public IHttpContextFactory HttpContextFactory { get; }
    public IApplicationBuilderFactory ApplicationBuilderFactory { get; }
    public IEnumerable<IStartupFilter> StartupFilters { get; }
    public IConfiguration Configuration { get; }
    public IWebHostEnvironment HostingEnvironment { get; }
    public HostingMetrics HostingMetrics { get; }
 
    public async Task StartAsync(CancellationToken cancellationToken)
    {
        HostingEventSource.Log.HostStart();
 
        var serverAddressesFeature = Server.Features.Get<IServerAddressesFeature>();
        var addresses = serverAddressesFeature?.Addresses;
        if (addresses != null && !addresses.IsReadOnly && addresses.Count == 0)
        {
            // 从应用配置读取 "urls" 配置节表示的地址（包含端口），多个地址用 ";" 分割
            var urls = Configuration[WebHostDefaults.ServerUrlsKey];
 
            if (string.IsNullOrEmpty(urls))
            {
                // 从备用配置读取
                urls = Options.WebHostOptions.ServerUrls;
            }

            // 从应用配置读取 "http_ports" 和 "https_ports" 配置节表示的端口，多个端口用 ";" 分割
            // 这两个配置的优先级比较低，只有在 "urls" 配置节不存在时启用
            // 并且会使用 "*" 通配符表示监听本机所有地址，包括环回地址
            var httpPorts = Configuration[WebHostDefaults.HttpPortsKey] ?? string.Empty;
            var httpsPorts = Configuration[WebHostDefaults.HttpsPortsKey] ?? string.Empty;
            if (string.IsNullOrEmpty(urls))
            {
                static string ExpandPorts(string ports, string scheme)
                {
                    return string.Join(';',
                        ports.Split(';', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries)
                        .Select(port => $"{scheme}://*:{port}"));
                }
 
                var httpUrls = ExpandPorts(httpPorts, Uri.UriSchemeHttp);
                var httpsUrls = ExpandPorts(httpsPorts, Uri.UriSchemeHttps);
                urls = $"{httpUrls};{httpsUrls}";
            }
            else if (!string.IsNullOrEmpty(httpPorts) || !string.IsNullOrEmpty(httpsPorts))
            {
                Logger.PortsOverridenByUrls(httpPorts, httpsPorts, urls);
            }
 
            if (!string.IsNullOrEmpty(urls))
            {
                // 例如 Kestrel 服务器提供了 ConfigureKestrel 扩展方法来注册 KestrelServerOptions 的选项配置
                // 通过调用 KesrelServerOptions.Listen 方法可以直接设置 ip 地址和 port 端口用于服务器监听
                // 如果 "preferHostingUrls" 配置节为 true，则会优先使用应用配置中的地址
                // 默认为 false，表明如果存在选项配置直接设置的地址，则会忽略应用配置中的地址
                var preferHostingUrlsConfig = Configuration[WebHostDefaults.PreferHostingUrlsKey];
 
                if (!string.IsNullOrEmpty(preferHostingUrlsConfig))
                {
                    serverAddressesFeature!.PreferHostingUrls = WebHostUtilities.ParseBool(preferHostingUrlsConfig);
                }
                else
                {
                    serverAddressesFeature!.PreferHostingUrls = Options.WebHostOptions.PreferHostingUrls;
                }
 
                foreach (var value in urls.Split(';', StringSplitOptions.RemoveEmptyEntries))
                {
                    addresses.Add(value);
                }
            }
        }
 
        RequestDelegate? application = null;
 
        try
        {
            // 从选项中取出 Action<IApplicationBuilder> 针对中间件建造者的配置
            var configure = Options.ConfigureApplication;
 
            if (configure == null)
            {
                throw new InvalidOperationException($"No application configured. Please specify an application via IWebHostBuilder.UseStartup, IWebHostBuilder.Configure, or specifying the startup assembly via {nameof(WebHostDefaults.StartupAssemblyKey)} in the web host configuration.");
            }

            // 利用服务器提供的特性集合创建 IApplicationBuilder
            var builder = ApplicationBuilderFactory.CreateBuilder(Server.Features);
 
            // 反转注册的 IStartupFilter 集合，保证先注册的会后执行 IStartupFilter.Configure 方法
            // 并将 GenericWebHostServiceOptions.ConfigureApplication 保存的配置作为末端配置最后执行
            // 构建 Action<IApplicationBuilder> -> Action<IApplicationBuilder> -> ... -> Action<IApplicationBuilder> 配置委托链
            foreach (var filter in StartupFilters.Reverse())
            {
                configure = filter.Configure(configure);
            }

            // 执行配置委托链，注册中间件
            configure(builder);
 
            // 构建请求处理委托链并返回头部的请求处理器
            application = builder.Build();
        }
        catch (Exception ex)
        {
            Logger.ApplicationError(ex);
 
            if (!Options.WebHostOptions.CaptureStartupErrors)
            {
                throw;
            }
 
            var showDetailedErrors = HostingEnvironment.IsDevelopment() || Options.WebHostOptions.DetailedErrors;
 
            application = ErrorPageBuilder.BuildErrorPageApplication(HostingEnvironment.ContentRootFileProvider, Logger, showDetailedErrors, ex);
        }

        // 创建 HostingApplication（实现 IHttpApplication<HostingApplication.Context>）
        var httpApplication = new HostingApplication(application, Logger, DiagnosticListener, ActivitySource, Propagator, HttpContextFactory, HostingEventSource.Log, HostingMetrics);

        // 启动服务器
        await Server.StartAsync(httpApplication, cancellationToken);
        // 输出诊断日志
        HostingEventSource.Log.ServerReady();
 
        if (addresses != null)
        {
            foreach (var address in addresses)
            {
                Log.ListeningOnAddress(LifetimeLogger, address);
            }
        }
 
        if (Logger.IsEnabled(LogLevel.Debug))
        {
            foreach (var assembly in Options.WebHostOptions.GetFinalHostingStartupAssemblies())
            {
                Log.StartupAssemblyLoaded(Logger, assembly);
            }
        }
 
        if (Options.HostingStartupExceptions != null)
        {
            foreach (var exception in Options.HostingStartupExceptions.InnerExceptions)
            {
                Logger.HostingStartupAssemblyError(exception);
            }
        }
    }
 
    public async Task StopAsync(CancellationToken cancellationToken)
    {
        try
        {
            // 停止服务器
            await Server.StopAsync(cancellationToken);
        }
        finally
        {
            HostingEventSource.Log.HostStop();
        }
    }
 
    private static partial class Log
    {
        [LoggerMessage(14, LogLevel.Information,
            "Now listening on: {address}",
            EventName = "ListeningOnAddress")]
        public static partial void ListeningOnAddress(ILogger logger, string address);
 
        [LoggerMessage(13, LogLevel.Debug,
            "Loaded hosting startup assembly {assemblyName}",
            EventName = "HostingStartupAssemblyLoaded",
            SkipEnabledCheck = true)]
        public static partial void StartupAssemblyLoaded(ILogger logger, string assemblyName);
    }
}
```
