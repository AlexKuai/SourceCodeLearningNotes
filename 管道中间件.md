# 管道中间件

## 源码涉及的核心类型

- GenericHostWebHostBuilderExtensions  
- GenericHostBuilderExtensions  
- WebHost  
- WebHostDefaults  
- WebHostOptions  
- IWebHostEnvironment  
- HostingEnvironment  
- IWebHostBuilder  
- ISupportsUseDefaultServiceProvider  
- ISupportsStartup  
- WebHostBuilderBase  
- GenericWebHostBuilder  
- HostingStartupWebHostBuilder  
- WebHostBuilderExtensions  
- IHostingStartup  
- IStartupFilter  
- IApplicationBuilder  
- ApplicationBuilder  
- IApplicationBuilderFactory  
- ApplicationBuilderFactory  
- RunExtensions  
- IMiddleware  
- IMiddlewareFactory  
- MiddlewareFactory  
- UseMiddlewareExtensions  
- HttpContext  
- HttpRequest  
- HttpResponse  
- IFeatureCollection  
- FeatureCollection  
- IHttpContextAccessor  
- HttpContextAccessor  
- HttpServiceCollectionExtensions  
- IHttpContextFactory  
- DefaultHttpContextFactory  
- IServiceProvidersFeature  
- RequestServicesFeature  
- IServer  
- IHttpApplication\<\>  
- HostingApplication  
- GenericWebHostServiceOptions  
- GenericWebHostService  

## ASP.NET Core 服务承载

- GenericHostWebHostBuilderExtensions

```C#
// 提供宿主建造者的扩展方法
// 目的是使用 IWebHostBuilder 收集各种配置
public static class GenericHostWebHostBuilderExtensions
{
    // 添加针对 IWebHostBuilder 的配置
    public static IHostBuilder ConfigureWebHost(this IHostBuilder builder, Action<IWebHostBuilder> configure)
    {
        ArgumentNullException.ThrowIfNull(configure);

        return builder.ConfigureWebHost(configure, _ => { });
    }

    // 添加针对 IWebHostBuilder 的配置
    // 并添加对 WebHostBuilderOptions 选项的配置
    public static IHostBuilder ConfigureWebHost(this IHostBuilder builder, Action<IWebHostBuilder> configure, Action<WebHostBuilderOptions> configureWebHostBuilder)
    {
        // 创建的 IWebHostBuilder 实现类型为 GenericWebHostBuilder
        return ConfigureWebHost(
            builder,
            static (hostBuilder, options) => new GenericWebHostBuilder(hostBuilder, options),
            configure,
            configureWebHostBuilder);
    }

    // 配置 IWebHostBuilder 的扩展方法
    private static IHostBuilder ConfigureWebHost(
        this IHostBuilder builder,
        Func<IHostBuilder, WebHostBuilderOptions, IWebHostBuilder> createWebHostBuilder,
        Action<IWebHostBuilder> configure,
        Action<WebHostBuilderOptions> configureWebHostBuilder)
    {
        ArgumentNullException.ThrowIfNull(configure);
        ArgumentNullException.ThrowIfNull(configureWebHostBuilder);
 
        if (builder is ISupportsConfigureWebHost supportsConfigureWebHost)
        {
            return supportsConfigureWebHost.ConfigureWebHost(configure, configureWebHostBuilder);
        }
 
        var webHostBuilderOptions = new WebHostBuilderOptions();
        // 利用 Action<WebHostBuilderOptions> 配置 WebHostBuilderOptions 选项
        configureWebHostBuilder(webHostBuilderOptions);
        // 利用 IHostBuilder 与 WebHostBuilderOptions 创建 IWebHostBuilder
        var webhostBuilder = createWebHostBuilder(builder, webHostBuilderOptions);
        // 利用 Action<IWebHostBuilder> 配置 IWebHostBuilder
        configure(webhostBuilder);
        // 添加针对服务注册的配置
        // 注册 IHostedService 服务，使用 GenericWebHostService 类型
        builder.ConfigureServices((context, services) 
            => services.AddHostedService<GenericWebHostService>());
        return builder;
    }
}
```

- GenericHostBuilderExtensions

```C#
// 提供宿主建造者的扩展方法
// 目的是使用 IWebHostBuilder 收集各种默认配置
public static class GenericHostBuilderExtensions
{
    // 使用默认方式配置 IWebHostBuilder
    public static IHostBuilder ConfigureWebHostDefaults(this IHostBuilder builder, Action<IWebHostBuilder> configure)
    {
        ArgumentNullException.ThrowIfNull(configure);
 
        return builder.ConfigureWebHostDefaults(configure, _ => { });
    }
    
    // 使用默认方式配置 IWebHostBuilder
    // 需要提供针对 WebHostBuilderOptions 的配置
    public static IHostBuilder ConfigureWebHostDefaults(this IHostBuilder builder, Action<IWebHostBuilder> configure, Action<WebHostBuilderOptions> configureOptions)
    {
        ArgumentNullException.ThrowIfNull(configure);

        return builder.ConfigureWebHost(webHostBuilder =>
        {
            // 先调用 WebHost.ConfigureWebDefaults 方法收集默认配置
            WebHost.ConfigureWebDefaults(webHostBuilder);

            // 再收集自定义配置
            configure(webHostBuilder);
        }, configureOptions);
    }
}
```

- WebHost

```C#
// 静态 WebHost
// 通过 IWebHostBuilder 收集默认配置
public static class WebHost
{
    // 配置默认 IWebHostBuilder
    internal static void ConfigureWebDefaults(IWebHostBuilder builder)
    {
        // 添加针对应用的配置
        builder.ConfigureAppConfiguration((ctx, cb) =>
        {
            // 开发环境下，为 IWebHostEnvironment.WebRootFileProvider 创建新的 CompositeFileProvider 作为静态资源文件提供者
            // 步骤如下：
            // 1. 尝试从从宿主配置中得到 "staticWebAssets" 配置节表示的静态资源所在的目录路径
            // 2. 如果配置节不存在，则使用程序根目录下的 "{IWebHostEnvironment.ApplicationName}.staticwebassets.runtime.json" 作为资源文件路径名
            // 3. 读取文件内容并反序列化为 StaticWebAssetManifest 类型对象
            // 4. 遍历 StaticWebAssetManifest.ContentRoots 属性表示的多个静态资源的目录并得到对应的 PhysicalFileProvider
            // 5. 将所有的 PhysicalFileProvider 和原来的 IWebHostEnvironment.WebRootFileProvider 创建 CompositeFileProvider 
            // 6. 将 CompositeFileProvider 作为 IWebHostEnvironment.WebRootFileProvider 的新值
            if (ctx.HostingEnvironment.IsDevelopment())
            {
                StaticWebAssetsLoader.UseStaticWebAssets(ctx.HostingEnvironment, ctx.Configuration);
            }
        });

        // 配置 Kestrel 作为默认的 Web 服务器
        ConfigureWebDefaultsWorker(
            // 使用 Kestrel 作为 Web 服务器
            // 注册 IServer 服务，使用 KestrelServerImpl 类型
            builder.UseKestrel(ConfigureKestrel),
            // 注册路由相关的服务
            services =>
            {
                services.AddRouting();
            });

        // IWebHostBuilder.UseIIS 方法的作用是检查当前操作系统是否为 Windows，并且 AspNetCoreModule 相关的 DLL 已经被加载到进程内（进程内托管）
        // 如果是则使用 IIS 作为 Web 服务器
        // 注册 IServer 服务，使用 IISHttpServer 类型
        // IWebHostBuilder.UseIISIntegration 方法的作用是开启 IIS 集成（进程外托管）
        // 开启 IIS 集成（进程外托管），需要从 IWebHostBuilder 的备用配置或环境变量中读取相应的配置
        // 具体来说需要存在以下配置：
        // 1. 备用配置中的 "PORT" 配置节存在或环境变量 "ASPNETCORE_PORT" 存在
        // 2. 备用配置中的 "APPL_PATH" 配置节存在或环境变量 "ASPNETCORE_APPL_PATH" 存在
        // 3. 备用配置中的 "TOKEN" 配置节存在或环境变量 "ASPNETCORE_TOKEN" 存在
        // 通过 IIS 启动 ASP.NET Core 应用时会自动添加以上环境变量
        // 注册 IStartupFilter 服务，使用 IISSetupFilter 类型
        // 其中会注册 3 个中间件：
        // 1. PathBaseMiddleware 中间件，用来处理 IIS 服务器转发的请求路径前缀
        // 2. ForwardedHeadersMiddleware 中间件，用来处理来自反向代理服务器的转发头信息
        // 3. IISMiddleware 中间件，用来处理与 IIS 服务器的通信
        // 最终会配置 "http://127.0.0.1:{port}" 环回地址作为 Kestrel 服务器的监听地址
        // 这个配置会延迟在配置服务注册时添加，因为这时候宿主配置已经构建完成，保证不会被其他宿主配置覆盖，但会被应用配置覆盖
        // 所以如果使用 IIS 作为反向代理服务器，则需要移除应用配置中对 Urls 的配置，避免 Kestrel 服务器的监听地址被覆盖
        builder
            .UseIIS()
            .UseIISIntegration();
    }

    // 注册默认服务
    private static void ConfigureWebDefaultsWorker(IWebHostBuilder builder, Action<IServiceCollection>? configureRouting)
    {
        builder.ConfigureServices((hostingContext, services) =>
        {
            // 注册 HostFilteringOptions 选项配置
            services.PostConfigure<HostFilteringOptions>(options =>
            {
                if (options.AllowedHosts == null || options.AllowedHosts.Count == 0)
                {
                    // 尝试从应用配置中得到 "AllowedHosts" 配置节表示的主机列表，多个则以 ";" 分割
                    // 例如：
                    // "AllowedHosts": "localhost;127.0.0.1;[::1]"
                    var hosts = hostingContext.Configuration["AllowedHosts"]?.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                    // 如果没有配置，则使用 "*" 作为默认值，表示允许所有主机
                    options.AllowedHosts = (hosts?.Length > 0 ? hosts : new[] { "*" });
                }
            });

            // 监听针对 HostFilteringOptions 选项的配置改变
            services.AddSingleton<IOptionsChangeTokenSource<HostFilteringOptions>>(
                    new ConfigurationChangeTokenSource<HostFilteringOptions>(hostingContext.Configuration));

            // 注册 IStartupFilter 服务
            services.AddTransient<IStartupFilter, HostFilteringStartupFilter>();
            services.AddTransient<IStartupFilter, ForwardedHeadersStartupFilter>();
            // 注册 ForwardedHeadersOptions 的选项配置
            services.AddTransient<IConfigureOptions<ForwardedHeadersOptions>, ForwardedHeadersOptionsSetup>();
 
            // 注册路由相关核心服务或使用自定义服务配置注册
            if (configureRouting == null)
            {
                services.AddRoutingCore();
            }
            else
            {
                configureRouting(services);
            }
        });
    }
}
```

- WebHostDefaults

```C#
// 默认配置键
public static class WebHostDefaults
{
    public static readonly string ApplicationKey = "applicationName";
 
    public static readonly string StartupAssemblyKey = "startupAssembly";
 
    public static readonly string HostingStartupAssembliesKey = "hostingStartupAssemblies";
 
    public static readonly string HostingStartupExcludeAssembliesKey = "hostingStartupExcludeAssemblies";
 
    public static readonly string DetailedErrorsKey = "detailedErrors";
 
    public static readonly string EnvironmentKey = "environment";
 
    public static readonly string WebRootKey = "webroot";
 
    public static readonly string CaptureStartupErrorsKey = "captureStartupErrors";
 
    public static readonly string ServerUrlsKey = "urls";
 
    public static readonly string HttpPortsKey = "http_ports";
 
    public static readonly string HttpsPortsKey = "https_ports";
 
    public static readonly string ContentRootKey = "contentRoot";
 
    public static readonly string PreferHostingUrlsKey = "preferHostingUrls";
 
    public static readonly string PreventHostingStartupKey = "preventHostingStartup";
 
    public static readonly string SuppressStatusMessagesKey = "suppressStatusMessages";
 
    public static readonly string ShutdownTimeoutKey = "shutdownTimeoutSeconds";
 
    public static readonly string StaticWebAssetsKey = "staticWebAssets";
}
```

- WebHostOptions

```C#
// 用于保存从主备 IConfiguration 中读取的各项配置
internal sealed class WebHostOptions
{
    // 读取配置值时使用宿主配置作为主配置，回退配置作为备用配置
    // 部分配置优先从 HostBuilderContext.HostingEnvironment 读取
    public WebHostOptions(IConfiguration primaryConfiguration, IConfiguration? fallbackConfiguration = null, IHostEnvironment? environment = null)
    {
        ArgumentNullException.ThrowIfNull(primaryConfiguration);

        string? GetConfig(string key) => primaryConfiguration[key] ?? fallbackConfiguration?[key];
 
        ApplicationName = environment?.ApplicationName ?? 
            GetConfig(WebHostDefaults.ApplicationKey) ?? 
            Assembly.GetEntryAssembly()?.GetName().Name ?? string.Empty;
        StartupAssembly = GetConfig(WebHostDefaults.StartupAssemblyKey);
        DetailedErrors = WebHostUtilities.ParseBool(GetConfig(WebHostDefaults.DetailedErrorsKey));
        CaptureStartupErrors = WebHostUtilities.ParseBool(GetConfig(WebHostDefaults.CaptureStartupErrorsKey));
        Environment = environment?.EnvironmentName ?? GetConfig(WebHostDefaults.EnvironmentKey);
        WebRoot = GetConfig(WebHostDefaults.WebRootKey);
        ContentRootPath = environment?.ContentRootPath ?? GetConfig(WebHostDefaults.ContentRootKey);
        PreventHostingStartup = WebHostUtilities.ParseBool(GetConfig(WebHostDefaults.PreventHostingStartupKey));
        SuppressStatusMessages = WebHostUtilities.ParseBool(GetConfig(WebHostDefaults.SuppressStatusMessagesKey));
        ServerUrls = GetConfig(WebHostDefaults.ServerUrlsKey);
        PreferHostingUrls = WebHostUtilities.ParseBool(GetConfig(WebHostDefaults.PreferHostingUrlsKey));
 
        HostingStartupAssemblies = Split(ApplicationName, GetConfig(WebHostDefaults.HostingStartupAssembliesKey));
        HostingStartupExcludeAssemblies = Split(GetConfig(WebHostDefaults.HostingStartupExcludeAssembliesKey));
 
        var timeout = GetConfig(WebHostDefaults.ShutdownTimeoutKey);
        if (!string.IsNullOrEmpty(timeout)
            && int.TryParse(timeout, NumberStyles.None, CultureInfo.InvariantCulture, out var seconds))
        {
            ShutdownTimeout = TimeSpan.FromSeconds(seconds);
        }
    }
 
    public string ApplicationName { get; }
 
    public bool PreventHostingStartup { get; }
 
    public bool SuppressStatusMessages { get; }
 
    public IReadOnlyList<string> HostingStartupAssemblies { get; }
 
    public IReadOnlyList<string> HostingStartupExcludeAssemblies { get; }
 
    public bool DetailedErrors { get; }
 
    public bool CaptureStartupErrors { get; }
 
    public string? Environment { get; }
 
    public string? StartupAssembly { get; }
 
    public string? WebRoot { get; }
 
    public string? ContentRootPath { get; }
 
    public TimeSpan ShutdownTimeout { get; } = TimeSpan.FromSeconds(30);
 
    public string? ServerUrls { get; }
 
    public bool PreferHostingUrls { get; }
    
    // 得到 HostingStartup 程序集
    // 包含 "hostingStartupAssemblies" 配置节中通过 ";" 分隔的多个程序集名称
    // 排除 "hostingStartupExcludeAssemblies" 配置节中通过 ";" 分隔的多个程序集名称
    // 并且一定会包含入口程序集名称
    public IEnumerable<string> GetFinalHostingStartupAssemblies()
    {
        return HostingStartupAssemblies.Except(HostingStartupExcludeAssemblies, StringComparer.OrdinalIgnoreCase);
    }
 
    private static IReadOnlyList<string> Split(string? value)
    {
        return value?.Split(';', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries)
            ?? Array.Empty<string>();
    }
 
    private static IReadOnlyList<string> Split(string applicationName, string? environment)
    {
        if (string.IsNullOrEmpty(environment))
        {
            return new[] { applicationName };
        }
 
        return Split($"{applicationName};{environment}");
    }
}
```

- IWebHostEnvironment

```C#
// Web 宿主环境
// 实现 IHostEnvironment
public interface IWebHostEnvironment : IHostEnvironment
{
    // Web 根目录
    // 默认目录路径为 {IHostEnvironment.ContentRootPath}/wwwroot
    string WebRootPath { get; set; }
    
    // 表示 WebRootPath 目录的 IFileProvider
    IFileProvider WebRootFileProvider { get; set; }
}
```

- HostingEnvironment

```C#
// IWebHostEnvironment 的默认实现
#pragma warning disable CS0618
internal sealed class HostingEnvironment : IHostingEnvironment, Extensions.Hosting.IHostingEnvironment, IWebHostEnvironment
#pragma warning restore CS0618
{
    public string EnvironmentName { get; set; } = Extensions.Hosting.Environments.Production;
 
#pragma warning disable CS8766
    public string? ApplicationName { get; set; }
#pragma warning restore CS8766
 
    public string WebRootPath { get; set; } = default!;
 
    public IFileProvider WebRootFileProvider { get; set; } = default!;
 
    public string ContentRootPath { get; set; } = default!;
 
    public IFileProvider ContentRootFileProvider { get; set; } = default!;
}
```

- IWebHostBuilder

```C#
// Web 宿主建造者的抽象表示
// 在现有的承载系统中已不再利用 Build 方法构建 IWebHost
public interface IWebHostBuilder
{
    // 当前承载系统已不支持此方法
    IWebHost Build();
 
    // 收集针对应用的配置
    IWebHostBuilder ConfigureAppConfiguration(Action<WebHostBuilderContext, IConfigurationBuilder> configureDelegate);
    
    // 收集针对服务注册的配置
    IWebHostBuilder ConfigureServices(Action<IServiceCollection> configureServices);
 
    // 收集针对服务注册的配置
    IWebHostBuilder ConfigureServices(Action<WebHostBuilderContext, IServiceCollection> configureServices);
 
    // 从备用配置读取配置
    string? GetSetting(string key);
    
    // 向备用配置添加配置
    IWebHostBuilder UseSetting(string key, string? value);
}
```

- ISupportsUseDefaultServiceProvider

```C#
// 约定实现 IWebHostBuilder 的类型需要提供 DefaultServiceProviderFactory 方法
internal interface ISupportsUseDefaultServiceProvider
{
    IWebHostBuilder UseDefaultServiceProvider(Action<WebHostBuilderContext, ServiceProviderOptions> configure);
}
```

- ISupportsStartup

```C#
// 约定实现 IWebHostBuilder 的类型需要提供两个额外的功能
// 1. 收集中间件建造者配置
// 2. 注册 Startup 类型，用户收集各种配置
public interface ISupportsStartup
{
    IWebHostBuilder Configure(Action<IApplicationBuilder> configure);
 
    IWebHostBuilder Configure(Action<WebHostBuilderContext, IApplicationBuilder> configure);
 
    IWebHostBuilder UseStartup(Type startupType);
 
    IWebHostBuilder UseStartup<TStartup>(Func<WebHostBuilderContext, TStartup> startupFactory);
}
```

- WebHostBuilderBase

```C#
// IWebHostBuilder 的默认实现，并同时实现了 ISupportsUseDefaultServiceProvider
// 这是一个抽象类，主要用来收集针对 Web 应用的各种配置（应用配置、服务注册配置），并最终将这些配置转移到 IHostBuilder 上
// 具体实现类的职责是收集各种针对中间件建造者的配置
internal abstract class WebHostBuilderBase : IWebHostBuilder, ISupportsUseDefaultServiceProvider
{
    // 最终收集到的各种配置都会被转移到 IHostBuilder 上
    private protected readonly IHostBuilder _builder;
    // 为 IWebHostBuilder 准备的备用配置
    // 可以调用 UseSetting 方法添加配置
    private protected readonly IConfiguration _config;
 
    public WebHostBuilderBase(IHostBuilder builder, WebHostBuilderOptions options)
    {
        _builder = builder;
        // 添加一个空的内存配置源
        var configBuilder = new ConfigurationBuilder()
            .AddInMemoryCollection();

        // 根据 WebHostBuilderOptions.SuppressEnvironmentConfiguration 属性判断是否添加前缀为 "ASPNETCORE_" 的环境变量配置源
        if (!options.SuppressEnvironmentConfiguration)
        {
            configBuilder.AddEnvironmentVariables(prefix: "ASPNETCORE_");
        }

        // 构建备用配置
        _config = configBuilder.Build();
    }
    
    // 已不支持用来构建 IWebHost
    public IWebHost Build()
    {
        throw new NotSupportedException($"Building this implementation of {nameof(IWebHostBuilder)} is not supported.");
    }
    
    // 收集针对应用的配置
    public IWebHostBuilder ConfigureAppConfiguration(Action<WebHostBuilderContext, IConfigurationBuilder> configureDelegate)
    {
        // 转移到 IHostBuilder 上
        _builder.ConfigureAppConfiguration((context, builder) =>
        {
            // 利用 HostBuilderContext 得到 WebHostBuilderContext
            // 注意：此时 HostBuilderContext.Configuration 还是宿主配置
            // 得到的 WebHostBuilderContext.Configuration 也是宿主配置
            var webhostBuilderContext = GetWebHostBuilderContext(context);
            configureDelegate(webhostBuilderContext, builder);
        });
 
        return this;
    }
    
    // 收集针对服务注册的配置
    public IWebHostBuilder ConfigureServices(Action<IServiceCollection> configureServices)
    {
        return ConfigureServices((context, services) => configureServices(services));
    }
 
    // 收集针对服务注册的配置
    public IWebHostBuilder ConfigureServices(Action<WebHostBuilderContext, IServiceCollection> configureServices)
    {
        // 转移到 IHostBuilder 上
        _builder.ConfigureServices((context, builder) =>
        {
            // 利用 HostBuilderContext 得到 WebHostBuilderContext
            // 注意：此时 HostBuilderContext.Configuration 是应用配置
            // 得到的 WebHostBuilderContext.Configuration 也是应用配置
            var webhostBuilderContext = GetWebHostBuilderContext(context);
            configureServices(webhostBuilderContext, builder);
        });
 
        return this;
    }
 
    // 实现 ISupportsUseDefaultServiceProvider 接口
    public IWebHostBuilder UseDefaultServiceProvider(Action<WebHostBuilderContext, ServiceProviderOptions> configure)
    {
        // 转移到 IHostBuilder 上
        _builder.UseServiceProviderFactory(context =>
        {
            // 利用 HostBuilderContext 得到 WebHostBuilderContext
            // 注意：此时 HostBuilderContext.Configuration 是应用配置
            // 得到的 WebHostBuilderContext.Configuration 也是应用配置
            var webHostBuilderContext = GetWebHostBuilderContext(context);
            var options = new ServiceProviderOptions();
            configure(webHostBuilderContext, options);
            return new DefaultServiceProviderFactory(options);
        });
 
        return this;
    }
 
    // 利用 HostBuilderContext 得到 WebHostBuilderContext
    protected WebHostBuilderContext GetWebHostBuilderContext(HostBuilderContext context)
    {
        // 利用 IHostBuilder.Properties 共享字典缓存创建的 WebHostBuilderContext
        // 避免多次创建 WebHostBuilderContext
        if (!context.Properties.TryGetValue(typeof(WebHostBuilderContext), out var contextVal))
        {
            // 创建 WebHostOptions
            // 注意：首次调用时候传入的主配置是宿主配置
            var options = new WebHostOptions(context.Configuration, fallbackConfiguration: _config, environment: context.HostingEnvironment);
            var webHostBuilderContext = new WebHostBuilderContext
            {
                // 此时 HostBuilderContext.Configuration 是宿主配置
                Configuration = context.Configuration,
                HostingEnvironment = new HostingEnvironment()
            };
            // 通过 HostBuilderContext.HostingEnvironment 和 WebHostOptions 为 WebHostBuilderContext.HostingEnvironment 赋值
            // 如果配置中不存在 "webroot" 配置节，则使用默认值 "wwwroot"
            // 最终 IWebHostEnvironment.WebRootPath 的值就是 "{IHostEnvironment.ContentRootPath}/wwwroot"，并创建这个目录
            webHostBuilderContext.HostingEnvironment.Initialize(context.HostingEnvironment.ContentRootPath, options, baseEnvironment: context.HostingEnvironment);
            // 缓存避免重复创建转换
            context.Properties[typeof(WebHostBuilderContext)] = webHostBuilderContext;
            context.Properties[typeof(WebHostOptions)] = options;
            return webHostBuilderContext;
        }
 
        var webHostContext = (WebHostBuilderContext)contextVal;
        // 最终 WebHostBuilderContext.Configuration 会被更新为应用配置
        webHostContext.Configuration = context.Configuration;
        return webHostContext;
    }
 
    public string? GetSetting(string key)
    {
        return _config[key];
    }
 
    public IWebHostBuilder UseSetting(string key, string? value)
    {
        _config[key] = value;
        return this;
    }
}
```

- GenericWebHostBuilder

```C#
// 继承 WebHostBuilderBase
// 实现 ISupportsStartup
// 主要功能：
// 1. 使用 Configure 方法收集中间件建造者配置
// 2. 使用 UseStartup 方法注册外部类型，作用是用它来收集各种配置
//    利用外部类型的 ConfigureService 方法收集针对服务注册的配置
//    利用外部类型的 ConfigureContainer 方法收集针对容器建造者的配置
//    利用外部类型的 Configure 方法收集中间件建造者配置
internal sealed class GenericWebHostBuilder : WebHostBuilderBase, ISupportsStartup
{
    private object? _startupObject;
    private readonly object _startupKey = new object();
 
    private AggregateException? _hostingStartupErrors;
    private HostingStartupWebHostBuilder? _hostingStartupWebHostBuilder;
 
    public GenericWebHostBuilder(IHostBuilder builder, WebHostBuilderOptions options)
        : base(builder, options)
    {
        // 添加针对宿主的配置 
        // 转移到 IHostBuilder 上
        _builder.ConfigureHostConfiguration(config =>
        {
            // 将备用配置作为被链接的配置源
            config.AddConfiguration(_config);

            // 根据 "hostingStartupAssemblies" 配置节的配置得到目标程序集
            // 注意：这时候的主要配置来源于以 "ASPNETCORE_" 为前缀的环境变量
            // 检查程序集是否绑定了 HostingStartupAttribute 特性
            // 利用 HostingStartupAttribute.HostingStartupType 创建实现了 IHostingStartup 的类型
            // 调用 IHostingStartup.Configure 方法，用于配置 HostingStartupWebHostBuilder
            ExecuteHostingStartups();
        });
 
        // 添加针对应用的配置
        // 转移到 IHostBuilder 上
        _builder.ConfigureAppConfiguration((context, configurationBuilder) =>
        {
            // 检查是否启用 HostingStartupWebHostBuilder
            if (_hostingStartupWebHostBuilder != null)
            {
                var webhostContext = GetWebHostBuilderContext(context);
                // 执行 HostingStartupWebHostBuilder 中的应用配置委托链
                _hostingStartupWebHostBuilder.ConfigureAppConfiguration(webhostContext, configurationBuilder);
            }
        });

        // 添加针对服务注册的配置
        // 转移到 IHostBuilder 上
        _builder.ConfigureServices((context, services) =>
        {
            var webhostContext = GetWebHostBuilderContext(context);
            var webHostOptions = (WebHostOptions)context.Properties[typeof(WebHostOptions)];
 
            // 注册 IWebHostEnvironment.HostingEnvironment 实例
            services.AddSingleton(webhostContext.HostingEnvironment);
#pragma warning disable CS0618 
            services.AddSingleton((AspNetCore.Hosting.IHostingEnvironment)webhostContext.HostingEnvironment);
            services.AddSingleton<IApplicationLifetime, GenericWebHostApplicationLifetime>();
#pragma warning restore CS0618 
 
            // 注册 GenericWebHostServiceOptions 选项配置
            services.Configure<GenericWebHostServiceOptions>(options =>
            {
                options.WebHostOptions = webHostOptions;
                options.HostingStartupExceptions = _hostingStartupErrors;
            });
 
            // 注册 DiagnosticSource，使用 Func<IServiceProvider, DiagnosticListener> 工厂
            services.TryAddSingleton(sp => new DiagnosticListener("Microsoft.AspNetCore"));
            services.TryAddSingleton<DiagnosticSource>(sp => sp.GetRequiredService<DiagnosticListener>());
            // 注册 ActivitySource，使用 Func<IServiceProvider, ActivitySource> 工厂
            services.TryAddSingleton(sp => new ActivitySource("Microsoft.AspNetCore"));
            services.TryAddSingleton(DistributedContextPropagator.Current);
 
            // 注册 IHttpContextFactory, 使用 DefaultHttpContextFactory 类型
            services.TryAddSingleton<IHttpContextFactory, DefaultHttpContextFactory>();
            // 注册 IMiddlewareFactory，使用 MiddlewareFactory 类型
            services.TryAddScoped<IMiddlewareFactory, MiddlewareFactory>();
            // 注册 IApplicationBuilderFactory, 使用 ApplicationBuilderFactory 类型
            services.TryAddSingleton<IApplicationBuilderFactory, ApplicationBuilderFactory>();
 
            services.AddMetrics();
            services.TryAddSingleton<HostingMetrics>();
 
            // 执行 HostingStartupWebHostBuilder 中的服务注册委托链
            _hostingStartupWebHostBuilder?.ConfigureServices(webhostContext, services);
            
            if (!string.IsNullOrEmpty(webHostOptions.StartupAssembly))
            {
                // 在构建服务注册时利用基于约定的 Startup 类型收集各种配置
                ScanAssemblyAndRegisterStartup(context, services, webhostContext, webHostOptions);
            }
        });
    }
    
    // 创建基于约定的 Startup 类型
    private void ScanAssemblyAndRegisterStartup(HostBuilderContext context, IServiceCollection services, WebHostBuilderContext webhostContext, WebHostOptions webHostOptions)
    {
        try
        {
            // 如果 "startupAssembly" 配置节存在，则尝试加载对应的程序集并找到基于约定的 Startup 类型
            // 查找 Startup 类型的规则和顺序如下：
            // 1. "Startup{IWebHostEnvironment.EnvironmentName}" 
            // 2. "{startupAssembly 配置节表示的程序集名称}.Startup{IWebHostEnvironment.EnvironmentName}"
            // 3. "Startup"
            // 4. "{startupAssembly 配置节表示的程序集名称}.Startup"
            var startupType = StartupLoader.FindStartupType(webHostOptions.StartupAssembly!, webhostContext.HostingEnvironment.EnvironmentName);
            UseStartup(startupType, context, services);
        }
        catch (Exception ex) when (webHostOptions.CaptureStartupErrors)
        {
            var capture = ExceptionDispatchInfo.Capture(ex);
 
            services.Configure<GenericWebHostServiceOptions>(options =>
            {
                options.ConfigureApplication = app =>
                {
                    capture.Throw();
                };
            });
        }
    }
    
    // 创建实现 IHostingStartup 接口的类型
    // 并使用 HostingStartupWebHostBuilder 收集各种配置
    private void ExecuteHostingStartups()
    {
        // 此时备用配置的配置源主要是 "ASPNETCORE_" 前缀的环境变量配置源
        // 或者通过调用 IWebHostBuilder.UseSetting 方法直接添加的配置值
        var webHostOptions = new WebHostOptions(_config);
 
        // 如果 "preventHostingStartup" 配置节不存在或值为 "false"，则不应用 IHostingStartup
        if (webHostOptions.PreventHostingStartup)
        {
            return;
        }
 
        var exceptions = new List<Exception>();
        var processed = new HashSet<Assembly>();
 
        // 创建 HostingStartupWebHostBuilder
        // 是对 GenericWebHostBuilder 的封装
        // 内部在收集针对应用的配置或针对服务注册的配置都是通过委托链形式保存
        // 而其他的配置都将被转移到 GenericWebHostBuilder 上
        _hostingStartupWebHostBuilder = new HostingStartupWebHostBuilder(this);
 
        // 根据备用配置的 "hostingStartupAssemblies" 配置节和 "hostingStartupExcludeAssemblies" 配置节最终得到 IHostingStartup 程序集列表
        // 注意：还会附加入口程序集
        foreach (var assemblyName in webHostOptions.GetFinalHostingStartupAssemblies())
        {
            try
            {
                // 加载程序集
                var assembly = Assembly.Load(new AssemblyName(assemblyName));
 
                // 不会重复处理同名的程序集
                if (!processed.Add(assembly))
                {
                    continue;
                }
 
                // 从程序集得到绑定的 HostingStartupAttribute 特性集合
                foreach (var attribute in assembly.GetCustomAttributes<HostingStartupAttribute>())
                {
                    // 利用 HostingStartupAttribute.HostingStartupType 表示的类型反射得到对应实例，并强制类型转换为 IHostingStartup 接口类型
                    var hostingStartup = (IHostingStartup)Activator.CreateInstance(attribute.HostingStartupType)!;
                    // 调用 IHostingStartup.Configure 方法
                    // 利用 HostingStartupWebHostBuilder 收集各种配置
                    hostingStartup.Configure(_hostingStartupWebHostBuilder);
                }
            }
            catch (Exception ex)
            {
                exceptions.Add(new InvalidOperationException($"Startup assembly {assemblyName} failed to execute. See the inner exception for more details.", ex));
            }
        }
 
        if (exceptions.Count > 0)
        {
            _hostingStartupErrors = new AggregateException(exceptions);
        }
    }
    
    // 应用 Startup 类型
    public IWebHostBuilder UseStartup(Type startupType)
    {
        var startupAssemblyName = startupType.Assembly.GetName().Name;

        // 将 Startup 类型所在的程序集名称作为 "applicationName" 配置节的值
        UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);

        // 缓存 Startup 类型
        _startupObject = startupType;

        // 转移到 IHostBuilder 上
        _builder.ConfigureServices((context, services) =>
        {
            // 如果 UseStartup 被多次调用，只有最后一次的调用有效
            if (object.ReferenceEquals(_startupObject, startupType))
            {
                // 在构建服务注册时调用
                UseStartup(startupType, context, services);
            }
        });
 
        return this;
    }
    
    // 应用 Startup 类型
    // 传递 Func<WebHostBuilderContext, TStartup> 委托
    public IWebHostBuilder UseStartup<TStartup>(Func<WebHostBuilderContext, TStartup> startupFactory)
    {
        // 将 startupFactory 委托的原型方法的类型所在程序集名称作为 "applicationName" 配置节的值
        var startupAssemblyName = startupFactory.GetMethodInfo().DeclaringType!.Assembly.GetName().Name;

        UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        // 保存最后一次的 Func<WebHostBuilderContext, TStartup> 委托
        _startupObject = startupFactory;
 
        // 转移到 IHostBuilder 上
        _builder.ConfigureServices(ConfigureStartup);

        void ConfigureStartup(HostBuilderContext context, IServiceCollection services)
        {
            // 如果 UseStartup 被多次调用，只有最后一次的调用有效
            if (object.ReferenceEquals(_startupObject, startupFactory))
            {
                var webHostBuilderContext = GetWebHostBuilderContext(context);
                // 利用 Func<WebHostBuilderContext, TStartup> 委托创建 Startup 类型实例
                var instance = startupFactory(webHostBuilderContext) ?? 
                               throw new InvalidOperationException("The specified factory returned null startup instance.");
                // 在构建服务注册时调用
                UseStartup(instance.GetType(), context, services, instance);
            }
        }
 
        return this;
    }
    
    // 私有 UseStartup 方法
    // 创建基于约定的 Startup 并应用配置
    private void UseStartup(Type startupType, HostBuilderContext context, IServiceCollection services, object? instance = null)
    {
        var webHostBuilderContext = GetWebHostBuilderContext(context);
        var webHostOptions = (WebHostOptions)context.Properties[typeof(WebHostOptions)];
 
        ExceptionDispatchInfo? startupError = null;
        ConfigureBuilder? configureBuilder = null;
 
        try
        {
            // 已不支持 Startup 类型实现 IStartup 接口
            if (typeof(IStartup).IsAssignableFrom(startupType))
            {
                throw new NotSupportedException($"{typeof(IStartup)} isn't supported");
            }
            // 已不支持 Startup 类型中存在返回值类型是 IServiceProvider 的 "ConfigureServices" 方法
            if (StartupLoader.HasConfigureServicesIServiceProviderDelegate(startupType, context.HostingEnvironment.EnvironmentName))
            {
                throw new NotSupportedException($"ConfigureServices returning an {typeof(IServiceProvider)} isn't supported.");
            }

            // 如果没有传入 Startup 类型的实例，则利用反射方式创建 Startup 类型实例
            // 这个过程中会选定 Startup 类型的一个最优构造函数，并利用 HostServiceProvider 作为 IServiceProvider，为构造函数提供 IHostEnvironment、IWebHostEnvironment、IConfiguration 三种服务类型的实例
            instance ??= ActivatorUtilities.CreateInstance(new HostServiceProvider(webHostBuilderContext), startupType);
            // 将 Startup 类型实例存入由 IHostBuilder.Properties 表示的共享字典中
            context.Properties[_startupKey] = instance;
 
            // 在 Startup 类型中查找 "ConfigureServices" 方法时
            // 优先级顺序如下：
            // 1. 名称为 "Configure{IHostEnvironment.EnvironmentName}Services" 的方法
            // 2. 名称为 "ConfigureServices" 的方法
            // 并且该方法必须满足以下条件：
            // 1. public
            // 2. 支持实例或静态方法
            // 3. 返回值类型是 void
            // 4. 找到的方法不能存在重载
            // 并最终封装为 ConfigureServicesBuilder
            var configureServicesBuilder = StartupLoader.FindConfigureServicesDelegate(startupType, context.HostingEnvironment.EnvironmentName);
            // 构建 Func<IServiceCollection, IServiceProvider?> 委托
            var configureServices = configureServicesBuilder.Build(instance);

            // 执行 Func<IServiceCollection, IServiceProvider?> 委托
            // 内部是通过反射方式调用 Startup 类型的 ConfigureService 方法
            configureServices(services);
 
            // 从 Startup 类型中查找 "ConfigureContainer" 方法时
            // 优先级顺序如下：
            // 1. 名称为 "Configure{IHostEnvironment.EnvironmentName}Container" 的方法
            // 2. 名称为 "ConfigureContainer" 的方法
            // 并且该方法必须满足以下条件：
            // 1. public
            // 2. 支持实例或静态方法
            // 3. 返回值类型是 void
            // 4. 找到的方法不能存在重载
            // 并最终封装为 ConfigureContainerBuilder
            var configureContainerBuilder = StartupLoader.FindConfigureContainerDelegate(startupType, context.HostingEnvironment.EnvironmentName);
            // 基于约定的 Startup 类型中可以不定义 "ConfigureContainer" 相关方法
            if (configureContainerBuilder.MethodInfo != null)
            {
                // 将 ConfigureContainerBuilder 实例存入由 IHostBuilder.Properties 表示的共享字典中
                _builder.Properties[typeof(ConfigureContainerBuilder)] = configureContainerBuilder;

                // 通过反射方式调用 IHostBuilder.ConfigureContainer 方法添加针对容器建造者的配置
                InvokeContainer(this, configureContainerBuilder);
            }
 
            // 从 Startup 类型中查找 "Configure" 方法时
            // 优先级顺序如下：
            // 1. 名称为 "Configure{IHostEnvironment.EnvironmentName}" 的方法
            // 2. 名称为 "Configure" 的方法
            // 并且该方法必须满足以下条件：
            // 1. public
            // 2. 返回值类型是 void
            // 3. 支持实例或静态方法
            // 4. 找到的方法不能存在重载
            // 并最终封装为 ConfigureBuilder
            configureBuilder = StartupLoader.FindConfigureDelegate(startupType, context.HostingEnvironment.EnvironmentName);
        }
        catch (Exception ex) when (webHostOptions.CaptureStartupErrors)
        {
            startupError = ExceptionDispatchInfo.Capture(ex);
        }
 
        // 注册 GenericWebHostService 选项配置
        services.Configure<GenericWebHostServiceOptions>(options =>
        {
            // 将中间件建造者的配置委托保存到 GenericWebHostServiceOptions.ConfigureApplication 属性中
            options.ConfigureApplication = app =>
            {
                startupError?.Throw();
 
                if (instance != null && configureBuilder != null)
                {
                    // 通过反射方式调用方法添加中间件建造者配置
                    configureBuilder.Build(instance)(app);
                }
            };
        });
 
        // 通过反射方式调用 IHostBuilder.ConfigureContainer 方法添加针对容器建造者的配置
        static void InvokeContainer(GenericWebHostBuilder genericWebHostBuilder, ConfigureContainerBuilder configureContainerBuilder)
        {
            // 得到 ConfigureContainer 方法的容器建造者类型
            var containerType = configureContainerBuilder.GetContainerType();
 
            // AOT 方式不支持容器建造者类型是值类型
            if (containerType.IsValueType && !RuntimeFeature.IsDynamicCodeSupported)
            {
                throw new InvalidOperationException("A ValueType TContainerBuilder isn't supported with AOT.");
            }

            // 得到容器建造者的具体配置委托类型 Action<HostBuilderContext, TContainerBuilder> 类型
            var actionType = typeof(Action<,>).MakeGenericType(typeof(HostBuilderContext), containerType);
 
            // 创建 Action<HostBuilderContext, TContainerBuilder> 委托实例
            var configureCallback = typeof(GenericWebHostBuilder)
                .GetMethod(nameof(ConfigureContainerImpl), BindingFlags.NonPublic | BindingFlags.Instance)!
                .MakeGenericMethod(containerType)
                .CreateDelegate(actionType, genericWebHostBuilder);
 
            // 反射方式调用 IHostBuilder.ConfigureContainer 方法添加针对容器建造者的配置
            typeof(IHostBuilder).GetMethod(nameof(IHostBuilder.ConfigureContainer))!
                .MakeGenericMethod(containerType)
                .InvokeWithoutWrappingExceptions(genericWebHostBuilder._builder, new object[] { configureCallback });
        }
    }
    
    // 用来构建 Action<HostBuilderContext, TContainerBuilder> 委托的方法原型
    private void ConfigureContainerImpl<TContainer>(HostBuilderContext context, TContainer container) where TContainer : notnull
    {
        // 先从 IHostBuilder.Properties 表示的共享字典中得到 Startup 类型实例
        var instance = context.Properties[_startupKey];
        // 再从 IHostBuilder.Properties 表示的构建共享字典中得到 ConfigureContainerBuilder 实例
        var builder = (ConfigureContainerBuilder)context.Properties[typeof(ConfigureContainerBuilder)];
        // 内部通过反射方式调用 Startup 类型的 ConfigureContainer 方法配置容器建造者
        builder.Build(instance)(container);
    }
 
    // 添加针对中间件建造者的配置
    public IWebHostBuilder Configure(Action<IApplicationBuilder> configure)
    {
        var startupAssemblyName = configure.GetMethodInfo().DeclaringType!.Assembly.GetName().Name!;
 
        // 将配置委托的原型方法的声明类型所在程序集名称作为 "applicationName" 配置节的值
        UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        // 保存最后一次的 Action<IApplicationBuilder> 委托
        _startupObject = configure;
        
        // 转移到 IHostBuilder 上
        _builder.ConfigureServices((context, services) =>
        {
            // 如果 Configure 被多次调用，只有最后一次的调用有效
            if (object.ReferenceEquals(_startupObject, configure))
            {
                // 注册 GenericWebHostService 选项配置
                services.Configure<GenericWebHostServiceOptions>(options =>
                {
                    options.ConfigureApplication = app => configure(app);
                });
            }
        });
 
        return this;
    }
    
    // 添加针对中间件建造者的配置
    public IWebHostBuilder Configure(Action<WebHostBuilderContext, IApplicationBuilder> configure)
    {
        var startupAssemblyName = configure.GetMethodInfo().DeclaringType!.Assembly.GetName().Name!;
 
        // 将定义配置委托的原型方法的声明类型所在程序集名称作为 "applicationName" 配置节的值
        UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        // 保存最后一次的 Action<WebHostBuilderContext, IApplicationBuilder> 委托
        _startupObject = configure;

        // 转移到 IHostBuilder 上
        _builder.ConfigureServices((context, services) =>
        {
            // 如果 Configure 被多次调用，只有最后一次的调用有效
            if (object.ReferenceEquals(_startupObject, configure))
            {
                // 注册 GenericWebHostService 选项配置
                services.Configure<GenericWebHostServiceOptions>(options =>
                {
                    var webhostBuilderContext = GetWebHostBuilderContext(context);
                    options.ConfigureApplication = app => configure(webhostBuilderContext, app);
                });
            }
        });
 
        return this;
    }
    
    // 实现 IServiceProvider
    // 本质是对 WebHostBuilderContext 的包装
    // 对外可以提供 IHostEnvironment、IWebHostEnvironment、IConfiguration 三个服务的实例
    private sealed class HostServiceProvider : IServiceProvider
    {
        private readonly WebHostBuilderContext _context;
 
        public HostServiceProvider(WebHostBuilderContext context)
        {
            _context = context;
        }
 
        public object? GetService(Type serviceType)
        {
            // The implementation of the HostingEnvironment supports both interfaces
#pragma warning disable CS0618 // Type or member is obsolete
            if (serviceType == typeof(Microsoft.Extensions.Hosting.IHostingEnvironment)
                || serviceType == typeof(Microsoft.AspNetCore.Hosting.IHostingEnvironment)
#pragma warning restore CS0618 // Type or member is obsolete
                    || serviceType == typeof(IWebHostEnvironment)
                || serviceType == typeof(IHostEnvironment)
                )
            {
                return _context.HostingEnvironment;
            }
 
            if (serviceType == typeof(IConfiguration))
            {
                return _context.Configuration;
            }
 
            return null;
        }
    }
}
```

- HostingStartupWebHostBuilder

```C#
// 实现 IWebHostBuilder，ISupportsUseDefaultServiceProvider、ISupportsStartup
// 本质是对 GenericWebHostBuilder 的封装
internal sealed class HostingStartupWebHostBuilder : IWebHostBuilder, ISupportsStartup, ISupportsUseDefaultServiceProvider
{
    private readonly GenericWebHostBuilder _builder;
    private Action<WebHostBuilderContext, IConfigurationBuilder>? _configureConfiguration;
    private Action<WebHostBuilderContext, IServiceCollection>? _configureServices;
 
    public HostingStartupWebHostBuilder(GenericWebHostBuilder builder)
    {
        _builder = builder;
    }
 
    // 不支持通过 IWebHostBuilder.Builder 方法构建
    public IWebHost Build()
    {
        throw new NotSupportedException($"Building this implementation of {nameof(IWebHostBuilder)} is not supported.");
    }
 
    // 收集针对应用的配置
    // 利用委托链保存多个配置
    public IWebHostBuilder ConfigureAppConfiguration(Action<WebHostBuilderContext, IConfigurationBuilder> configureDelegate)
    {
        _configureConfiguration += configureDelegate;
        return this;
    }
 
    // 收集针对服务注册的配置
    // 利用委托链保存多个配置
    public IWebHostBuilder ConfigureServices(Action<IServiceCollection> configureServices)
    {
        return ConfigureServices((context, services) => configureServices(services));
    }

    // 收集针对服务注册的配置
    // 利用委托链保存多个配置
    public IWebHostBuilder ConfigureServices(Action<WebHostBuilderContext, IServiceCollection> configureServices)
    {
        _configureServices += configureServices;
        return this;
    }
    
    // 从备用配置读取配置
    // 转移到 GenericWebHostBuilder 上
    public string? GetSetting(string key) => _builder.GetSetting(key);
    
    // 为备用配置添加配置
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder UseSetting(string key, string? value)
    {
        _builder.UseSetting(key, value);
        return this;
    }
    
    // Action<WebHostBuilderContext, IServiceCollection> 委托的原型方法
    // 执行委托链
    public void ConfigureServices(WebHostBuilderContext context, IServiceCollection services)
    {
        _configureServices?.Invoke(context, services);
    }
 
    // Action<WebHostBuilderContext, IConfigurationBuilder> 委托的原型方法
    // 执行委托链
    public void ConfigureAppConfiguration(WebHostBuilderContext context, IConfigurationBuilder builder)
    {
        _configureConfiguration?.Invoke(context, builder);
    }
 
    // 实现 ISupportsUseDefaultServiceProvider 接口
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder UseDefaultServiceProvider(Action<WebHostBuilderContext, ServiceProviderOptions> configure)
    {
        return _builder.UseDefaultServiceProvider(configure);
    }
 
    // 添加针对中间件建造者的配置
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder Configure(Action<IApplicationBuilder> configure)
    {
        return _builder.Configure(configure);
    }
 
    // 添加针对中间件建造者的配置
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder Configure(Action<WebHostBuilderContext, IApplicationBuilder> configure)
    {
        return _builder.Configure(configure);
    }
    
    // 根据 Startup 类型创建基于约定的 Startup 并应用配置
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder UseStartup(Type startupType)
    {
        return _builder.UseStartup(startupType);
    }
 
    // 根据 Func<WebHostBuilderContext, TStartup> 创建基于约定的 Startup 并应用配置
    // 转移到 GenericWebHostBuilder 上
    public IWebHostBuilder UseStartup<TStartup>(Func<WebHostBuilderContext, TStartup> startupFactory)
    {
        return _builder.UseStartup(startupFactory);
    }
}
```

- WebHostBuilderExtensions

```C#
// 为 IWebhostBuilder 提供扩展方法
public static class WebHostBuilderExtensions
{
    public static IWebHostBuilder Configure(this IWebHostBuilder hostBuilder, Action<IApplicationBuilder> configureApp)
    {
        ArgumentNullException.ThrowIfNull(configureApp);

        if (hostBuilder is ISupportsStartup supportsStartup)
        {
            return supportsStartup.Configure(configureApp);
        }
 
        // 将配置委托的原型方法的声明类型所在程序集名称作为 "applicationName" 配置节的值
        var startupAssemblyName = configureApp.GetMethodInfo().DeclaringType!.Assembly.GetName().Name!;
 
        hostBuilder.UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        return hostBuilder.ConfigureServices((context, services) =>
        {
            // 注册 IStartup 服务类型
            services.AddSingleton<IStartup>(sp =>
            {
                return new DelegateStartup(sp.GetRequiredService<IServiceProviderFactory<IServiceCollection>>(), (app => configureApp(app)));
            });
        });
    }
 
    public static IWebHostBuilder Configure(this IWebHostBuilder hostBuilder, Action<WebHostBuilderContext, IApplicationBuilder> configureApp)
    {
        ArgumentNullException.ThrowIfNull(configureApp);
 
        if (hostBuilder is ISupportsStartup supportsStartup)
        {
            return supportsStartup.Configure(configureApp);
        }
 
        // 将配置委托的原型方法的声明类型所在程序集名称作为 "applicationName" 配置节的值
        var startupAssemblyName = configureApp.GetMethodInfo().DeclaringType!.Assembly.GetName().Name!;
 
        hostBuilder.UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        return hostBuilder.ConfigureServices((context, services) =>
        {
            // 注册 IStartup 服务类型
            services.AddSingleton<IStartup>(sp =>
            {
                return new DelegateStartup(sp.GetRequiredService<IServiceProviderFactory<IServiceCollection>>(), (app => configureApp(context, app)));
            });
        });
    }
 
    public static IWebHostBuilder UseStartup<TStartup>(this IWebHostBuilder hostBuilder, Func<WebHostBuilderContext, TStartup> startupFactory) where TStartup : class
    {
        ArgumentNullException.ThrowIfNull(startupFactory);
 
        if (hostBuilder is ISupportsStartup supportsStartup)
        {
            return supportsStartup.UseStartup(startupFactory);
        }
 
        var startupAssemblyName = startupFactory.GetMethodInfo().DeclaringType!.Assembly.GetName().Name;
 
        hostBuilder.UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        return hostBuilder
            .ConfigureServices((context, services) =>
            {
                // 注册 IStartup 服务类型
                services.AddSingleton(typeof(IStartup), GetStartupInstance);
 
                [UnconditionalSuppressMessage("Trimmer", "IL2072", Justification = "Startup type created by factory can't be determined statically.")]
                object GetStartupInstance(IServiceProvider serviceProvider)
                {
                    var instance = startupFactory(context) ?? throw new InvalidOperationException("The specified factory returned null startup instance.");
 
                    var hostingEnvironment = serviceProvider.GetRequiredService<IHostEnvironment>();
 
                    if (instance is IStartup startup)
                    {
                        return startup;
                    }
 
                    return new ConventionBasedStartup(StartupLoader.LoadMethods(serviceProvider, instance.GetType(), hostingEnvironment.EnvironmentName, instance));
                }
            });
    }
 
    public static IWebHostBuilder UseStartup(this IWebHostBuilder hostBuilder, Type startupType)
    {
        ArgumentNullException.ThrowIfNull(startupType);
 
        if (hostBuilder is ISupportsStartup supportsStartup)
        {
            return supportsStartup.UseStartup(startupType);
        }
 
        var startupAssemblyName = startupType.Assembly.GetName().Name;
 
        hostBuilder.UseSetting(WebHostDefaults.ApplicationKey, startupAssemblyName);
 
        return hostBuilder
            .ConfigureServices(services =>
            {
                if (typeof(IStartup).IsAssignableFrom(startupType))
                {
                    services.AddSingleton(typeof(IStartup), startupType);
                }
                else
                {
                    // 注册 IStartup 服务类型
                    services.AddSingleton(typeof(IStartup), sp =>
                    {
                        var hostingEnvironment = sp.GetRequiredService<IHostEnvironment>();
                        return new ConventionBasedStartup(StartupLoader.LoadMethods(sp, startupType, hostingEnvironment.EnvironmentName));
                    });
                }
            });
    }
 
    public static IWebHostBuilder UseStartup<TStartup>(this IWebHostBuilder hostBuilder) where TStartup : class
    {
        return hostBuilder.UseStartup(typeof(TStartup));
    }
 
    public static IWebHostBuilder UseDefaultServiceProvider(this IWebHostBuilder hostBuilder, Action<ServiceProviderOptions> configure)
    {
        return hostBuilder.UseDefaultServiceProvider((context, options) => configure(options));
    }
 
    public static IWebHostBuilder UseDefaultServiceProvider(this IWebHostBuilder hostBuilder, Action<WebHostBuilderContext, ServiceProviderOptions> configure)
    {
        if (hostBuilder is ISupportsUseDefaultServiceProvider supportsDefaultServiceProvider)
        {
            return supportsDefaultServiceProvider.UseDefaultServiceProvider(configure);
        }
 
        return hostBuilder.ConfigureServices((context, services) =>
        {
            var options = new ServiceProviderOptions();
            configure(context, options);
            services.Replace(ServiceDescriptor.Singleton<IServiceProviderFactory<IServiceCollection>>(new DefaultServiceProviderFactory(options)));
        });
    }
 
    public static IWebHostBuilder ConfigureAppConfiguration(this IWebHostBuilder hostBuilder, Action<IConfigurationBuilder> configureDelegate)
    {
        return hostBuilder.ConfigureAppConfiguration((context, builder) => configureDelegate(builder));
    }
 
    public static IWebHostBuilder ConfigureLogging(this IWebHostBuilder hostBuilder, Action<ILoggingBuilder> configureLogging)
    {
        return hostBuilder.ConfigureServices(collection => collection.AddLogging(configureLogging));
    }
 
    public static IWebHostBuilder ConfigureLogging(this IWebHostBuilder hostBuilder, Action<WebHostBuilderContext, ILoggingBuilder> configureLogging)
    {
        return hostBuilder.ConfigureServices((context, collection) => collection.AddLogging(builder => configureLogging(context, builder)));
    }
 
    public static IWebHostBuilder UseStaticWebAssets(this IWebHostBuilder builder)
    {
        builder.ConfigureAppConfiguration((context, configBuilder) =>
        {
            StaticWebAssetsLoader.UseStaticWebAssets(context.HostingEnvironment, context.Configuration);
        });
 
        return builder;
    }
}
```

- IHostingStartup

```C#
// HostingStartup 接口
// 用来定义强类型 Startup
public interface IHostingStartup
{
    void Configure(IWebHostBuilder builder);
}
```

## 中间件

- IStartupFilter

```C#
// 用来注册 IStartupFilter 服务
public interface IStartupFilter
{
    // 构建 Action<IApplicationBuilder> -> ... -> Action<IApplicationBuilder> 中间件建造者配置链
    Action<IApplicationBuilder> Configure(Action<IApplicationBuilder> next);
}
```

- IApplicationBuilder

```C#
// 中间件建造者
// 用来注册 Func<RequestDelegate, RequestDelegate> 形式的原始中间件
// 并最终将中间件构建成 RequestDelegate -> ... -> RequestDelegate 请求处理委托链
public interface IApplicationBuilder
{
    // 代表根容器的 IServiceProvider
    IServiceProvider ApplicationServices { get; set; }
    
    // 由服务器提供的特性集合
    IFeatureCollection ServerFeatures { get; }

    // 构建过程中用于共享的数据字典
    IDictionary<string, object?> Properties { get; }
    
    // 中间件的原始注册方法
    IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware);
 
    // 创建一个新的 IApplicationBuilder
    IApplicationBuilder New();
    
    // 构建请求处理委托链
    // 将收集到的 Func<RequestDelegate, RequestDelegate> 形式的中间件构建成请求处理委托链
    RequestDelegate Build();
}
```

- ApplicationBuilder

```C#
// IApplicationBuilder 的默认实现
public partial class ApplicationBuilder : IApplicationBuilder
{
    private const string ServerFeaturesKey = "server.Features";
    private const string ApplicationServicesKey = "application.Services";
    private const string MiddlewareDescriptionsKey = "__MiddlewareDescriptions";
    private const string RequestUnhandledKey = "__RequestUnhandled";
 
    private readonly List<Func<RequestDelegate, RequestDelegate>> _components = new();
    private readonly List<string>? _descriptions;
    private readonly IDebugger _debugger;
    
    public ApplicationBuilder(IServiceProvider serviceProvider) : this(serviceProvider, new FeatureCollection())
    {
    }
    
    // 表示中间件数量
    private int MiddlewareCount => _components.Count;
 
    // 利用 IApplicationBuilderFactory 创建 ApplicationBuilder 时调用的构造函数
    // 需要提供表示根容器的 IServiceProvider 和服务器提供的特性集合 IFeatureCollection
    public ApplicationBuilder(IServiceProvider serviceProvider, object server)
    {
        Properties = new Dictionary<string, object?>(StringComparer.Ordinal);
        ApplicationServices = serviceProvider;

        // 使用 "server.Features" 作为 Key 将 IFeatureCollection 特性集合保存到共享字典中
        SetProperty(ServerFeaturesKey, server);
 
        _debugger = (IDebugger?)serviceProvider?.GetService(typeof(IDebugger)) ?? DebuggerWrapper.Instance;
 
        if (_debugger.IsAttached)
        {
            _descriptions = new();
            SetProperty(MiddlewareDescriptionsKey, _descriptions);
        }
    }
 
    // 提供给 New 方法调用的私有构造函数，用于创建新的 ApplicationBuilder 时拷贝共享字典
    private ApplicationBuilder(ApplicationBuilder builder)
    {
        Properties = new CopyOnWriteDictionary<string, object?>(builder.Properties, StringComparer.Ordinal);
        _debugger = builder._debugger;
        if (_debugger.IsAttached)
        {
            _descriptions = new();
        }
    }
    
    // 使用 "application.Services" 作为 Key 存取表示根容器的 IServiceProvider
    public IServiceProvider ApplicationServices
    {
        get
        {
            return GetProperty<IServiceProvider>(ApplicationServicesKey)!;
        }
        set
        {
            SetProperty<IServiceProvider>(ApplicationServicesKey, value);
        }
    }
 
    // 使用 "server.Features" 作为 Key 从共享字典中获取由服务器提供的特性集合 IFeatureCollection
    public IFeatureCollection ServerFeatures
    {
        get
        {
            return GetProperty<IFeatureCollection>(ServerFeaturesKey)!;
        }
    }
 
    // ApplicationServices 和 ServerFeatures 两个属性的存取实际都是通过这个共享字典来完成的
    public IDictionary<string, object?> Properties { get; }
 
    private T? GetProperty<T>(string key)
    {
        return Properties.TryGetValue(key, out var value) ? (T?)value : default(T);
    }
 
    private void SetProperty<T>(string key, T value)
    {
        Properties[key] = value;
    }
 
    // 注册 Func<RequestDelegate, RequestDelegate> 形式的原始中间件
    public IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware)
    {
        // 收集原始中间件
        _components.Add(middleware);
        _descriptions?.Add(CreateMiddlewareDescription(middleware));
 
        return this;
    }
 
    // 得到原始中间件的名称
    private static string CreateMiddlewareDescription(Func<RequestDelegate, RequestDelegate> middleware)
    {
        if (middleware.Target != null)
        {
            if (middleware.Method.Name == "CreateMiddleware")
            {
                return middleware.Target.ToString()!;
            }
 
            return middleware.Target.GetType().FullName + "." + middleware.Method.Name;
        }
 
        return middleware.Method.Name.ToString();
    }
 
    // 利用自身创建一个新的 IApplicationBuilder
    public IApplicationBuilder New()
    {
        return new ApplicationBuilder(this);
    }
 
    // 构建请求处理委托链
    public RequestDelegate Build()
    {
        // 创建一个响应 404 状态码的 RequestDelegate，作为循环调用 Func<RequestDelegate, RequestDelegate> 创建请求处理委托链时的末端处理器
        // 如果前序的请求处理器没有返回，则最终会到达这个末端处理器，并响应 404 状态码
        RequestDelegate app = context =>
        {
            // 尝试从 HttpContext.Features 中获取 IEndpointFeature 特性对象
            var endpoint = context.GetEndpoint();
            // 得到表示终结点的请求处理器
            var endpointRequestDelegate = endpoint?.RequestDelegate;
            // 如果运行到这个末端处理器时候存在终结点，则表示可能没有通过 UseEndpoints 注册终结点处理器，或者有其他不可预知的问题发生
            // 因为使用 UseEndpoints 注册的终结点处理器会从 HttpContext.Features 特性集合中取出终结点处理并返回
            if (endpointRequestDelegate != null)
            {
                var message =
                    $"The request reached the end of the pipeline without executing the endpoint: '{endpoint!.DisplayName}'. " +
                    $"Please register the EndpointMiddleware using '{nameof(IApplicationBuilder)}.UseEndpoints(...)' if using " +
                    $"routing.";
                throw new InvalidOperationException(message);
            }
 
            // 返回 404 状态码
            // 表明没有任何终结点处理器处理这个请求
            if (!context.Response.HasStarted)
            {
                context.Response.StatusCode = StatusCodes.Status404NotFound;
            }
 
            // 通知前序的请求处理器这个请求没有被任何终结点处理器处理
            context.Items[RequestUnhandledKey] = true;
 
            return Task.CompletedTask;
        };

        // 利用末端处理器从后往前循环执行 Func<RequestDelegate, RequestDelegate> 原始中间件列表
        // 构建 RequestDelegate -> ... -> RequestDelegate 请求处理委托链
        for (var c = _components.Count - 1; c >= 0; c--)
        {
            app = _components[c](app);
        }

        // 返回位于头部的请求处理器
        return app;
    }
}
```

- IApplicationBuilderFactory

```C#
// 中间件构建者工厂的抽象表示
public interface IApplicationBuilderFactory
{
    // 利用特性集合创建 IApplicationBuilder
    IApplicationBuilder CreateBuilder(IFeatureCollection serverFeatures);
}
```

- ApplicationBuilderFactory

```C#
// IApplicationBuilderFactory 的默认实现
// 利用表示根容器的 IServiceProvider 和由服务器提供的特性集合 IFeatureCollection 创建 ApplicationBuilder
public class ApplicationBuilderFactory : IApplicationBuilderFactory
{
    private readonly IServiceProvider _serviceProvider;
 
    // 注入表示根容器的 IServiceProvider
    public ApplicationBuilderFactory(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
 
    public IApplicationBuilder CreateBuilder(IFeatureCollection serverFeatures)
    {
        return new ApplicationBuilder(_serviceProvider, serverFeatures);
    }
}
```

- RunExtensions

```C#
// 提供中间件注册的扩展方法
public static class RunExtensions
{
    // 注册末端中间件，属于短路操作
    // 因为返回的 RequestDelegate 请求处理器并未包含对传入的 RequestDelegate 请求处理器的调用
    public static void Run(this IApplicationBuilder app, RequestDelegate handler)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(handler);
 
        app.Use(_ => handler);
    }
}
```

- IMiddleware

```C#
// 强类型中间件的抽象表示
public interface IMiddleware
{
    Task InvokeAsync(HttpContext context, RequestDelegate next);
}
```

- IMiddlewareFactory

```C#
// 中间件工厂的抽象表示
public interface IMiddlewareFactory
{
    // 创建强类型中间件
    IMiddleware? Create(Type middlewareType);
    
    // 对创建的中间件进行回收
    void Release(IMiddleware middleware);
}
```

- MiddlewareFactory

```C#
// IMiddlewareFactory 的默认实现
public class MiddlewareFactory : IMiddlewareFactory
{
    // 表示范围容器的 IServiceProvider
    private readonly IServiceProvider _serviceProvider;
    
    // 此处注入的是表示范围容器的 IServiceProvider
    // 因为 IMiddlewareFactory 被注册为 Scoped 生命周期
    // 并且在请求处理阶段是由 HttpContext.RequestServices 表示的范围容器创建
    public MiddlewareFactory(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
    
    // 由范围容器创建强类型中间件
    public IMiddleware? Create(Type middlewareType)
    {
        // 强类型中间件在请求作用范围下唯一
        return _serviceProvider.GetRequiredService(middlewareType) as IMiddleware;
    }
    
    // 释放
    public void Release(IMiddleware middleware)
    {
        // 不做任何事情
        // 一般强类型中间件的释放由依赖注入容器管理
    }
}
```

- UseMiddlewareExtensions

```C#
// 提供扩展方法用来注册中间件
public static class UseMiddlewareExtensions
{
    // 约定的两个用来在中间件中定义的特定方法名
    internal const string InvokeMethodName = "Invoke";
    internal const string InvokeAsyncMethodName = "InvokeAsync";

    // 得到 UseMiddlewareExtensions.GetService 方法的 MethodInfo
    private static readonly MethodInfo GetServiceInfo = typeof(UseMiddlewareExtensions).GetMethod(nameof(GetService), BindingFlags.NonPublic | BindingFlags.Static)!;

    // 注册中间件
    // 使用泛型参数表示的中间件类型
    public static IApplicationBuilder UseMiddleware<TMiddleware>(this IApplicationBuilder app, params object?[] args)
    {
        return app.UseMiddleware(typeof(TMiddleware), args);
    }

    // 注册中间件
    // 分以下两种情况：
    // 1. 强类型中间件是由 HttpContext.RequestServices 表示的范围容器在请求处理阶段创建的，并且构造函数不支持传递外部参数列表，所有参数由依赖注入容器提供
    //    所以强类型中间可以基于每个请求作用范围创建独立的中间件实例
    // 2. 基于约定的中间件是在构建请求处理委托链时通过反射方式创建的，并且构造函数允许传递外部参数列表
    //    如果外部参数列表中不存在对应类型的参数时，还可以由 IApplicationBuilder.ApplicationServices 表示的根容器创建对应参数类型的实例
    //    另外在请求处理阶段，可以由 HttpContext.RequestServices 表示的范围容器创建除 HttpContext 类型参数以外的其他参数类型的实例
    //    所以基于约定的中间件在整个应用程序生命周期内只会创建一个实例
    public static IApplicationBuilder UseMiddleware(
        this IApplicationBuilder app,
        Type middleware,
        params object?[] args)
    {
        // 如果是强类型中间件，则不支持传递参数列表
        if (typeof(IMiddleware).IsAssignableFrom(middleware))
        {
            if (args.Length > 0)
            {
                throw new NotSupportedException(Resources.FormatException_UseMiddlewareExplicitArgumentsNotSupported(typeof(IMiddleware)));
            }

            // 使用 InterfaceMiddlewareBinder.CreateMiddleware 注册原始中间件
            var interfaceBinder = new InterfaceMiddlewareBinder(middleware);
            return app.Use(interfaceBinder.CreateMiddleware);
        }
 
        // 以下是将基于约定的中间件注册为原始中间件
        // 基于约定中间件必须满足以下条件：
        // 1. 检查中间件类型中是否存在名称为 "Invoke" 或 "InvokeAsync" 的公开实例方法（严格区分大小写）
        // 2. 不能定义 "Invoke" 或 "InvokeAsync" 方法的重载，并且 "Invoke" 和 "InvokeAsync" 方法之间也不能同时存在
        // 3. "Invoke" 或 "InvokeAsync" 方法返回类型必须是 Task
        // 4. "Invoke" 或 "InvokeAsync" 方法的第一个参数必须是 HttpContext 类型
        var methods = middleware.GetMethods(BindingFlags.Instance | BindingFlags.Public);
        MethodInfo? invokeMethod = null;
        foreach (var method in methods)
        {
            if (string.Equals(method.Name, InvokeMethodName, StringComparison.Ordinal) || 
                string.Equals(method.Name, InvokeAsyncMethodName, StringComparison.Ordinal))
            {
                if (invokeMethod is not null)
                {
                    throw new InvalidOperationException(Resources.FormatException_UseMiddleMutlipleInvokes(InvokeMethodName, InvokeAsyncMethodName));
                }

                invokeMethod = method;
            }
        }

        if (invokeMethod is null)
        {
            throw new InvalidOperationException(Resources.FormatException_UseMiddlewareNoInvokeMethod(InvokeMethodName, InvokeAsyncMethodName, middleware));
        }

        if (!typeof(Task).IsAssignableFrom(invokeMethod.ReturnType))
        {
            throw new InvalidOperationException(Resources.FormatException_UseMiddlewareNonTaskReturnType(InvokeMethodName, InvokeAsyncMethodName, nameof(Task)));
        }
 
        var parameters = invokeMethod.GetParameters();
        if (parameters.Length == 0 || parameters[0].ParameterType != typeof(HttpContext))
        {
            throw new InvalidOperationException(Resources.FormatException_UseMiddlewareNoParameters(InvokeMethodName, InvokeAsyncMethodName, nameof(HttpContext)));
        }

        // 使用 ReflectionMiddlewareBinder.CreateMiddleware 注册原始中间件
        var reflectionBinder = new ReflectionMiddlewareBinder(app, middleware, args, invokeMethod, parameters);
        return app.Use(reflectionBinder.CreateMiddleware);
    }

    // 强类型中间件绑定器
    private sealed class InterfaceMiddlewareBinder
    {
        private readonly Type _middlewareType;
 
        public InterfaceMiddlewareBinder(Type middlewareType)
        {
            _middlewareType = middlewareType;
        }
 
        // 中间件的原始形式
        public RequestDelegate CreateMiddleware(RequestDelegate next)
        {
            return async context =>
            {
                // 使用 HttpContext.RequestServices 表示的范围容器创建 IMiddlewareFactory
                var middlewareFactory = (IMiddlewareFactory?)context.RequestServices.GetService(typeof(IMiddlewareFactory));
                if (middlewareFactory == null)
                {
                    
                    throw new InvalidOperationException(Resources.FormatException_UseMiddlewareNoMiddlewareFactory(typeof(IMiddlewareFactory)));
                }

                // 强类型中间件是在请求处理阶段创建的，而且由于是使用 HttpContext.RequestServices 表示的范围容器创建中间件实例，所以中间件类型必须提前注册，并且可以是 Scoped 生命周期
                // 使用 IMiddlewareFactory 创建中间件实例
                var middleware = middlewareFactory.Create(_middlewareType);
                if (middleware == null)
                {
                    throw new InvalidOperationException(Resources.FormatException_UseMiddlewareUnableToCreateMiddleware(middlewareFactory.GetType(), _middlewareType));
                }
 
                try
                {
                    // 调用 IMiddleware.InvokeAsync 方法
                    await middleware.InvokeAsync(context, next);
                }
                finally
                {
                    middlewareFactory.Release(middleware);
                }
            };
        }
 
        public override string ToString() => _middlewareType.ToString();
    }

    // 基于约定的中间件绑定器
    private sealed class ReflectionMiddlewareBinder
    {
        private readonly IApplicationBuilder _app;
        private readonly Type _middleware;
        private readonly object?[] _args;
        private readonly MethodInfo _invokeMethod;
        private readonly ParameterInfo[] _parameters;
 
        public ReflectionMiddlewareBinder(
            IApplicationBuilder app,
            Type middleware,
            object?[] args,
            MethodInfo invokeMethod,
            ParameterInfo[] parameters)
        {
            _app = app;
            _middleware = middleware;
            _args = args;
            _invokeMethod = invokeMethod;
            _parameters = parameters;
        }

        // 中间件的原始形式
        public RequestDelegate CreateMiddleware(RequestDelegate next)
        {
            // 创建中间件的构造函数实参列表，包含代表后续请求处理器的 RequestDelegate 类型参数
            var ctorArgs = new object[_args.Length + 1];
            ctorArgs[0] = next;
            Array.Copy(_args, 0, ctorArgs, 1, _args.Length);
            // 基于约定的中间件是在构造请求处理委托链时创建的，所以在整个应用程序生命周期中基于约定的中间件实例是以单例形式存在的
            // 反射创建基于约定的中间件类型实例
            // 除了 RequestDelegate 类型参数外，其他参数优先从外部的实参列表获取，没有则利用根容器提供，如果还是没有则最终会尝试使用类型的默认值
            var instance = ActivatorUtilities.CreateInstance(_app.ApplicationServices, _middleware, ctorArgs);
            // 如果 "Invoke" 或 "InvokeAsync" 方法的参数个数为 1
            // 表明函数只有 HttpContext 类型参数，直接利用 MethodInfo 方法创建 RequestDelegate 委托返回
            if (_parameters.Length == 1)
            {
                return (RequestDelegate)_invokeMethod.CreateDelegate(typeof(RequestDelegate), instance);
            }
            
            // 如果 "Invoke" 或 "InvokeAsync" 方法存在其他参数，则先确定运行环境是否支持运行时动态代码编译
            // 如果支持会构建表达式树，并将表达式树编译成 Func<object, HttpContext, IServiceProvider, Task> 委托执行
            // 否则使用反射方式调用 "Invoke" 或 "InvokeAsync" 方法
            var factory = RuntimeFeature.IsDynamicCodeCompiled
                ? CompileExpression<object>(_invokeMethod, _parameters)
                : ReflectionFallback<object>(_invokeMethod, _parameters);

            return context =>
            {
                // 可以使用 HttpContext.RequestServices 表示的范围容器创建除 HttpContext 类型参数以外的其他参数实例
                var serviceProvider = context.RequestServices ?? _app.ApplicationServices;
                if (serviceProvider == null)
                {
                    throw new InvalidOperationException(Resources.FormatException_UseMiddlewareIServiceProviderNotAvailable(nameof(IServiceProvider)));
                }
 
                return factory(instance, context, serviceProvider);
            };
        }
 
        public override string ToString() => _middleware.ToString();
    }

    // 内部通过反射方式调用 "Invoke" 或 "InvokeAsync" 方法
    private static Func<T, HttpContext, IServiceProvider, Task> ReflectionFallback<T>(MethodInfo methodInfo, ParameterInfo[] parameters)
    {
        Debug.Assert(!RuntimeFeature.IsDynamicCodeSupported, "Use reflection fallback when dynamic code is not supported.");
 
        // 循环检查每个参数，不支持按地址传递的参数
        for (var i = 1; i < parameters.Length; i++)
        {
            var parameterType = parameters[i].ParameterType;
            if (parameterType.IsByRef)
            {
                throw new NotSupportedException(Resources.FormatException_InvokeDoesNotSupportRefOrOutParams(InvokeMethodName));
            }
        }
 
        return (middleware, context, serviceProvider) =>
        {
            var methodArguments = new object[parameters.Length];
            // 第一个实参必须是 HttpContext 类型参数
            methodArguments[0] = context;
            for (var i = 1; i < parameters.Length; i++)
            {
                // 利用范围容器创建其他参数
                methodArguments[i] = GetService(serviceProvider, parameters[i].ParameterType, methodInfo.DeclaringType!);
            }

            // 通过反射调用 "Invoke" 或 "InvokeAsync" 方法
            return (Task)methodInfo.Invoke(middleware, BindingFlags.DoNotWrapExceptions, binder: null, methodArguments, culture: null)!;
        };
    }
 
    // 构建表达式树并通过动态代码编译成委托执行 "Invoke" 或 "InvokeAsync" 方法
    private static Func<T, HttpContext, IServiceProvider, Task> CompileExpression<T>(MethodInfo methodInfo, ParameterInfo[] parameters)
    {
        Debug.Assert(RuntimeFeature.IsDynamicCodeSupported, "Use compiled expression when dynamic code is supported.");
 
        // 中间件的实际类型
        // 根据调用来看，此处是 object 类型
        var middleware = typeof(T);
 
        // 创建 Func<T, HttpContext, IServiceProvider, Task> 委托原型方法需要的三个入参
        // 1. 表示中间件实例，参数名 "middleware"，object 类型
        // 2. 表示请求上下文，参数名 "httpContext"，HttpContext 类型
        // 3. 表示范围容器，参数名 "serviceProvider"，IServiceProvider 类型
        var instanceArg = Expression.Parameter(middleware, "middleware");
        var httpContextArg = Expression.Parameter(typeof(HttpContext), "httpContext");
        var providerArg = Expression.Parameter(typeof(IServiceProvider), "serviceProvider");

        // 创建调用 "Invoke" 或 "InvokeAsync" 方法的实参列表
        var methodArguments = new Expression[parameters.Length];
        // 第一个实参必须是 HttpContext 类型参数
        methodArguments[0] = httpContextArg;
        for (var i = 1; i < parameters.Length; i++)
        {
            var parameterType = parameters[i].ParameterType;
            if (parameterType.IsByRef)
            {
                throw new NotSupportedException(Resources.FormatException_InvokeDoesNotSupportRefOrOutParams(InvokeMethodName));
            }
 
            // 为调用 UseMiddlewareExtensions.GetService 静态方法准备的参数列表
            var parameterTypeExpression = new Expression[]
            {
                providerArg,
                Expression.Constant(parameterType, typeof(Type)),
                Expression.Constant(methodInfo.DeclaringType, typeof(Type))
            };

            // 调用 UseMiddlewareExtensions.GetService 静态方法
            // 为 "Invoke" 或 "InvokeAsync" 方法创建除 HttpContext 类型参数以外的实参
            var getServiceCall = Expression.Call(GetServiceInfo, parameterTypeExpression);
            // 对实参进行强制类型转换并添加进实参列表
            methodArguments[i] = Expression.Convert(getServiceCall, parameterType);
        }
 
        Expression middlewareInstanceArg = instanceArg;
        if (methodInfo.DeclaringType != null && methodInfo.DeclaringType != typeof(T))
        {
            // 强制类型转换为中间件的实际类型
            middlewareInstanceArg = Expression.Convert(middlewareInstanceArg, methodInfo.DeclaringType);
        }
        
        // 通过中间件实例调用 "Invoke" 或 "InvokeAsync" 方法
        var body = Expression.Call(middlewareInstanceArg, methodInfo, methodArguments);
 
        // 创建 Expression<Func<T, HttpContext, IServiceProvider, Task>> 表达式
        var lambda = Expression.Lambda<Func<T, HttpContext, IServiceProvider, Task>>(body, instanceArg, httpContextArg, providerArg);

        // 将表达式编译成 Func<T, HttpContext, IServiceProvider, Task> 委托
        return lambda.Compile();
    }
 
    // 通过范围容器创建对应类型的实例
    private static object GetService(IServiceProvider sp, Type type, Type middleware)
    {
        var service = sp.GetService(type);
        if (service == null)
        {
            throw new InvalidOperationException(Resources.FormatException_InvokeMiddlewareNoService(type, middleware));
        }
 
        return service;
    }
}
```

- HttpContext

```C#
// HTTP 上下文的抽象表示
// DefaultHttpContext 是 HttpContext 的默认实现，但不负责具体属性值的提供，它的核心功能只是代理
// DefaultHttpContext 创建时由不同服务器传入 IFeatureCollection 特性集合，利用相应的特性类型（一般为接口类型）从特性集合中得到特性对象
public abstract class HttpContext
{
    // 不同服务器所提供的特性集合
    public abstract IFeatureCollection Features { get; }

    // 表示 HTTP 请求
    public abstract HttpRequest Request { get; }

    // 表示 HTTP 响应
    public abstract HttpResponse Response { get; }

    // 表示范围容器的 IServiceProvider
    // 为每个请求作用域提供服务
    public abstract IServiceProvider RequestServices { get; set; }

    // 表示当前用户身份的声明持有者
    public abstract ClaimsPrincipal User { get; set; }

    // 用来在请求处理阶段用于共享数据的字典
    public abstract IDictionary<object, object?> Items { get; set; }

    // 表示连接信息
    public abstract ConnectionInfo Connection { get; }

    // 表示当前会话
    public abstract ISession Session { get; set; }

    // 调试追踪 Id
    public abstract string TraceIdentifier { get; set; }
}
```

- HttpRequest

```C#
// HTTP 请求的抽象表示
// DefaultHttpRequest 是 HttpRequest 抽象类的默认实现
// DefaultHttpRequest 并不负责具体属性值的提供，它的核心功能只是代理
public abstract class HttpRequest
{
    public abstract HttpContext HttpContext { get; }
 
    // HTTP 请求方法谓词
    public abstract string Method { get; set; }
 
    // 表示请求的协议 "http" 或 "https"
    public abstract string Scheme { get; set; }
 
    // 是否是一个使用了 TSL/SSL 的 https 请求
    public abstract bool IsHttps { get; set; }
 
    // 请求时的的主机名（含端口号）
    public abstract HostString Host { get; set; }
 
    // 请求基础路径
    public abstract PathString PathBase { get; set; }
 
    // 相对于 PathBase 的路径
    public abstract PathString Path { get; set; }
 
    // 查询字符串的原始形式
    public abstract QueryString QueryString { get; set; }
    
    // 查询字符串的 Key/Value 形式
    // 由于查询字符串可以有多个相同的 Key，所以 Value 是一个字符串列表
    public abstract IQueryCollection Query { get; set; }
 
    // http 协议版本
    // 比如：HTTP/1.1 等
    public abstract string Protocol { get; set; }
    
    // 请求头，用 Key/Value 形式表示
    // 由于请求头可以有多个相同的 Key，所以 Value 是一个字符串列表
    public abstract IHeaderDictionary Headers { get; }
 
    // 请求携带的 Cookie 列表，用 Key/Value 形式表示
    public abstract IRequestCookieCollection Cookies { get; set; }
 
    // 请求主体内容的长度，单位字节
    public abstract long? ContentLength { get; set; }
 
    // 请求主体内容的媒体类型
    // 比如：text/html、text/json 等
    public abstract string? ContentType { get; set; }
 
    // 请求主体内容的输入流
    public abstract Stream Body { get; set; }
 
    // 是否为表单媒体类型
    // 表单媒体类型一般为 application/x-www-form-urlencoded 和 multipart/form-data
    public abstract bool HasFormContentType { get; }
 
    // 表单内容，用 Key/Value 形式表示
    // 由于表单内容可以有多个相同的 Key，所以 Value 是一个字符串列表
    public abstract IFormCollection Form { get; set; }
 
    // 读取表单内容
    public abstract Task<IFormCollection> ReadFormAsync(CancellationToken cancellationToken = new CancellationToken());
}
```

- HttpResponse

```C#
// 表示 HTTP 响应
// DefaultHttpResponse 是 HttpRequest 抽象类的默认实现
// DefaultHttpResponse 并不负责具体属性值的提供，它的核心功能只是代理
public abstract class HttpResponse
{
    public abstract HttpContext HttpContext { get; }
 
    // 响应状态码
    public abstract int StatusCode { get; set; }
 
    // 响应头，用 Key/Value 形式表示
    // 由于响应头可以有多个相同的 Key，所以 Value 是一个字符串列表
    public abstract IHeaderDictionary Headers { get; }
 
    // 响应主体内容的输出流
    public abstract Stream Body { get; set; }
 
    // 响应主体内容的长度，单位字节
    public abstract long? ContentLength { get; set; }
 
    // 响应主体内容的媒体类型
    public abstract string? ContentType { get; set; }
 
    // 用于设置响应 Cookie 列表，用 Key/Value 形式表示
    public abstract IResponseCookies Cookies { get; }
 
    // 响应首部是否已经开始发送
    public abstract bool HasStarted { get; }
 
    // 注册回调，在响应开始发送时触发
    public abstract void OnStarting(Func<object, Task> callback, object state);
 
    // 注册回调，在响应开始发送时触发
    public virtual void OnStarting(Func<Task> callback) => OnStarting(_callbackDelegate, callback);
 
    // 注册回调，在响应发送完成后触发
    public abstract void OnCompleted(Func<object, Task> callback, object state);

    // 注册回调，在响应发送完成后触发
    public virtual void OnCompleted(Func<Task> callback) => OnCompleted(_callbackDelegate, callback);
 
    // 注册响应完成后需要回收的对象
    public virtual void RegisterForDispose(IDisposable disposable) => OnCompleted(_disposeDelegate, disposable);
 
    // 注册响应完成后需要回收的对象
    public virtual void RegisterForDisposeAsync(IAsyncDisposable disposable) => OnCompleted(_disposeDelegate, disposable);
 
    // 发送针对指定地址的 302（临时）重定向响应消息
    public virtual void Redirect(string location) => Redirect(location, permanent: false);
 
    // 发送针对指定地址的 301（永久）或 302（临时）重定向响应消息
    public abstract void Redirect(string location, bool permanent);
}
```

- IFeatureCollection

```C#
// 表示由不同服务器提供的特性集合
// 本质是一个保存 Type/object 的字典
// Key 表示特性 TFeature 的类型（一般为接口类型）
// Value 表示特性 TFeature 类型对象
public interface IFeatureCollection : IEnumerable<KeyValuePair<Type, object>>
{
    // 是否只读
    // 实现类型应该永远返回 false，支持可读可写
    bool IsReadOnly { get; }
 
    // 特性集合的版本
    // 向特性集合添加或删除特性都应该自增版本
    int Revision { get; }
 
    // 利用特性类型通过索引器添加或得到特性对象
    object? this[Type key] { get; set; }
    
    // 通过 TFeature 泛型参数类型得到特性对象
    TFeature? Get<TFeature>();
 
    // 向特性集合添加指定 TFeature 泛型参数类型的特性对象
    void Set<TFeature>(TFeature? instance);
}
```

- FeatureCollection

```C#
// IFeatureCollection 的默认实现
public class FeatureCollection : IFeatureCollection
{
    private static readonly KeyComparer FeatureKeyComparer = new KeyComparer();
    private readonly IFeatureCollection? _defaults;
    private readonly int _initialCapacity;
    private IDictionary<Type, object>? _features;
    private volatile int _containerRevision;
    
    // 用来创建一个空特性集合
    public FeatureCollection()
    {
    }
    
    // 用来创建一个初始容量的空特性集合
    public FeatureCollection(int initialCapacity)
    {
        ArgumentOutOfRangeThrowHelper.ThrowIfNegative(initialCapacity);
 
        _initialCapacity = initialCapacity;
    }
    
    // 用来创建一个空特性集合
    // 并传入一个备用特性集合
    public FeatureCollection(IFeatureCollection defaults)
    {
        _defaults = defaults;
    }
 
    // 特性集合的版本
    // 每次添加或修改特性集合都会自增版本
    // 如果存在备用特性集合则版本号会加上备用特性集合的 Revision 属性值
    public virtual int Revision
    {
        get { return _containerRevision + (_defaults?.Revision ?? 0); }
    }
 
    // 永远返回 fasle
    public bool IsReadOnly { get { return false; } }
 
    public object? this[Type key]
    {
        get
        {
            ArgumentNullThrowHelper.ThrowIfNull(key);

            // 尝试得到特性对象，如果没有找到对应类型的特性对象则从备用特性集合中获取
            return _features != null && _features.TryGetValue(key, out var result) ? result : _defaults?[key];
        }
        set
        {
            ArgumentNullThrowHelper.ThrowIfNull(key);

            // 可以通过传 null 来删除对应类型的特性
            if (value == null)
            {
                if (_features != null && _features.Remove(key))
                {
                    // 版本自增
                    _containerRevision++;
                }
                return;
            }
 
            if (_features == null)
            {
                // 此处使用 Dictionary 来保存特性对象，也就决定了相同类型的特性对象只会存在一个
                _features = new Dictionary<Type, object>(_initialCapacity);
            }
            _features[key] = value;
            // 版本自增
            _containerRevision++;
        }
    }
 
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
 
    public IEnumerator<KeyValuePair<Type, object>> GetEnumerator()
    {
        if (_features != null)
        {
            foreach (var pair in _features)
            {
                yield return pair;
            }
        }
 
        if (_defaults != null)
        {
            // 从备用特性列表迭代，排除已经存在的特性类型的对象
            foreach (var pair in _features == null ? _defaults : _defaults.Except(_features, FeatureKeyComparer))
            {
                yield return pair;
            }
        }
    }
    
    // 内部是调用索引器得到指定特性类型的对象
    public TFeature? Get<TFeature>()
    {
        if (typeof(TFeature).IsValueType)
        {
            var feature = this[typeof(TFeature)];
            // 非可空值类型的特性类型必须得到特性对象，因为非可空值类型不能为 null
            if (feature is null && Nullable.GetUnderlyingType(typeof(TFeature)) is null)
            {
                throw new InvalidOperationException(
                    $"{typeof(TFeature).FullName} does not exist in the feature collection " +
                    $"and because it is a struct the method can't return null. Use 'featureCollection[typeof({typeof(TFeature).FullName})] is not null' to check if the feature exists.");
            }
            return (TFeature?)feature;
        }
        return (TFeature?)this[typeof(TFeature)];
    }
 
    // 内部是调用索引器添加指定类型的特性对象
    public void Set<TFeature>(TFeature? instance)
    {
        this[typeof(TFeature)] = instance;
    }
 
    private int GetCount() => this.Count();
 
    // 用于在通过迭代器返回时将自身特性集合和备用特性集合中相同的特性做去重处理
    private sealed class KeyComparer : IEqualityComparer<KeyValuePair<Type, object>>
    {
        public bool Equals(KeyValuePair<Type, object> x, KeyValuePair<Type, object> y)
        {
            return x.Key.Equals(y.Key);
        }
 
        public int GetHashCode(KeyValuePair<Type, object> obj)
        {
            return obj.Key.GetHashCode();
        }
    }
}
```

- IHttpContextAccessor

```C#
// 用于服务注册 IHttpContextAccessor 的接口
// 提供通过依赖注入方式访问 HttpContext 的能力
public interface IHttpContextAccessor
{
    HttpContext? HttpContext { get; set; }
}
```

- HttpContextAccessor

```C#
// IHttpContextAccessor 的默认实现
public class HttpContextAccessor : IHttpContextAccessor
{
    // 利用 AsyncLocal<HttpContextHolder> 保存 HttpContext 实现在不同线程间流动，支持异步编程模型
    private static readonly AsyncLocal<HttpContextHolder> _httpContextCurrent = new AsyncLocal<HttpContextHolder>();
 
    public HttpContext? HttpContext
    {
        get
        {
            return _httpContextCurrent.Value?.Context;
        }
        set
        {
            var holder = _httpContextCurrent.Value;
            // 每次赋值都会首先清空保存的 HttpContext
            // 所以可以通过传 null 来重置
            if (holder != null)
            {
                holder.Context = null;
            }
 
            if (value != null)
            {
                _httpContextCurrent.Value = new HttpContextHolder { Context = value };
            }
        }
    }
 
    private sealed class HttpContextHolder
    {
        public HttpContext? Context;
    }
}
```

- HttpServiceCollectionExtensions

```C#
// 用来注册 IHttpContextAccessor
public static class HttpServiceCollectionExtensions
{
    public static IServiceCollection AddHttpContextAccessor(this IServiceCollection services)
    {
        ArgumentNullException.ThrowIfNull(services);
 
        // 注册为 Singleton 生命周期
        // 因为本质是从当前线程的 ExecutionContext 中获取 HttpContext
        services.TryAddSingleton<IHttpContextAccessor, HttpContextAccessor>();
        return services;
    }
}
```

- IHttpContextFactory

```C#
// HttpContext 工厂的抽象表示
// 负责为每个请求创建 HttpContext，并在完成请求响应后释放
public interface IHttpContextFactory
{
    // 利用服务器提供的 IFeatureCollection 特性集合创建 HttpContext
    HttpContext Create(IFeatureCollection featureCollection);
    
    // 回收 HttpContext
    // 本质是将 IHttpContextAccessor.HttpContext 属性重置，也就是从当前线程的 ExecutionContext 中清空 HttpContext
    void Dispose(HttpContext httpContext);
}
```

- DefaultHttpContextFactory

```C#
// IHttpContextFactory 的默认实现
public class DefaultHttpContextFactory : IHttpContextFactory
{
    private readonly IHttpContextAccessor? _httpContextAccessor;
    private readonly FormOptions _formOptions;
    private readonly IServiceScopeFactory _serviceScopeFactory;
 
    // 因为 IHttpContextFactory 注册为 Singleton 生命周期，所以注入的是表示根容器的 IServiceProvider
    public DefaultHttpContextFactory(IServiceProvider serviceProvider)
    {
        _httpContextAccessor = serviceProvider.GetService<IHttpContextAccessor>();
        _formOptions = serviceProvider.GetRequiredService<IOptions<FormOptions>>().Value;
        // 如果使用的是默认的依赖注入框架，那么得到的 IServiceScopeFactory 就是 ServiceProvider.Root 属性保存的 ServiceProviderEngineScope
        _serviceScopeFactory = serviceProvider.GetRequiredService<IServiceScopeFactory>();
    }
 
    internal IHttpContextAccessor? HttpContextAccessor => _httpContextAccessor;
 
    public HttpContext Create(IFeatureCollection featureCollection)
    {
        ArgumentNullException.ThrowIfNull(featureCollection);

        // 利用服务器提供的 IFeatureCollection 特性集合创建并初始化 DefaultHttpContext
        var httpContext = new DefaultHttpContext(featureCollection);
        Initialize(httpContext, featureCollection);
        return httpContext;
    }
 
    // 初始化 HttpContext
    internal void Initialize(DefaultHttpContext httpContext, IFeatureCollection featureCollection)
    {
        Debug.Assert(featureCollection != null);
        Debug.Assert(httpContext != null);
 
        // 对 DefaultHttpContext 初始化
        httpContext.Initialize(featureCollection);
 
        if (_httpContextAccessor != null)
        {
            _httpContextAccessor.HttpContext = httpContext;
        }
 
        // 将表单选项赋给 HttpContext.FormOptions 属性
        httpContext.FormOptions = _formOptions;
        // 每个请求中表示范围容器的 IServiceProvider 都是由 IServiceScopeFactory 创建的
        // 保存在 HttpContext.RequestServices 属性中
        httpContext.ServiceScopeFactory = _serviceScopeFactory;
    }
 
    // 清除当前线程的 ExecutionContext 中保存的 HttpContext
    public void Dispose(HttpContext httpContext)
    {
        _httpContextAccessor?.HttpContext = null;
    }
    
    // 清除当前线程的 ExecutionContext 中保存的 HttpContext
    // 并对 DefaultHttpContext 进行反初始化
    internal void Dispose(DefaultHttpContext httpContext)
    {
        _httpContextAccessor?.HttpContext = null;
 
        httpContext.Uninitialize();
    }
}
```

- IServiceProvidersFeature

```C#
// 表示范围容器的特性接口
public interface IServiceProvidersFeature
{
    IServiceProvider RequestServices { get; set; }
}
```

- RequestServicesFeature

```C#
// IServiceProvidersFeature 的默认实现
// 主要功能：
// 1. 利用 IServiceScopeFactory 为每个请求创建表示范围容器的 IServiceProvider
// 2. 注册 HttpResponse.RegisterForDisposeAsync 为每个请求响应完成后执行回收操作，用来释放表示范围容器的 IServiceProvider
public class RequestServicesFeature : IServiceProvidersFeature, IDisposable, IAsyncDisposable
{
    private readonly IServiceScopeFactory? _scopeFactory;
    private IServiceProvider? _requestServices;
    private IServiceScope? _scope;
    private bool _requestServicesSet;
    private readonly HttpContext _context;
 
    public RequestServicesFeature(HttpContext context, IServiceScopeFactory? scopeFactory)
    {
        _context = context;
        _scopeFactory = scopeFactory;
    }
 
    // 利用 IServiceScopeFactory 创建范围容器
    public IServiceProvider RequestServices
    {
        get
        {
            // 针对每个请求只创建一次范围容器
            if (!_requestServicesSet && _scopeFactory != null)
            {
                // 注册自身为响应完成后回收的对象
                _context.Response.RegisterForDisposeAsync(this);
                _scope = _scopeFactory.CreateScope();
                _requestServices = _scope.ServiceProvider;
                _requestServicesSet = true;
            }
            return _requestServices!;
        }
        set
        {
            _requestServices = value;
            _requestServicesSet = true;
        }
    }
 
    // 响应完成后调用回收范围容器
    public ValueTask DisposeAsync()
    {
        switch (_scope)
        {
            case IAsyncDisposable asyncDisposable:
                var vt = asyncDisposable.DisposeAsync();
                if (!vt.IsCompletedSuccessfully)
                {
                    return Awaited(this, vt);
                }
                vt.GetAwaiter().GetResult();
                break;
            case IDisposable disposable:
                disposable.Dispose();
                break;
        }
 
        _scope = null;
        _requestServices = null;
 
        return default;
 
        static async ValueTask Awaited(RequestServicesFeature servicesFeature, ValueTask vt)
        {
            await vt;
            servicesFeature._scope = null;
            servicesFeature._requestServices = null;
        }
    }
    
    // 响应完成后调用，用于回收范围容器
    public void Dispose()
    {
        DisposeAsync().AsTask().GetAwaiter().GetResult();
    }
}
```

## 服务器

- IServer

```C#
// Web 服务器的抽象表示
public interface IServer : IDisposable
{
    // 服务器提供的特性集合
    IFeatureCollection Features { get; }
 
    // 启动服务器，主要流程如下：
    // 1. 调用 IHttpApplication<TContext>.CreateContext 方法创建 HttpContext
    // 2. 调用 IHttpApplication<TContext>.ProcessRequestAsync 方法将创建的 HttpContext 交由后续的请求处理器处理
    // 3. 调用 IHttpApplication<TContext>.DisposeContext 方法回收 HttpContext
    Task StartAsync<TContext>(IHttpApplication<TContext> application, CancellationToken cancellationToken) where TContext : notnull;
 
    // 停止服务器
    Task StopAsync(CancellationToken cancellationToken);
}
```

- IHttpApplication\<\>

```C#
// 表示用于处理请求的应用程序
public interface IHttpApplication<TContext> where TContext : notnull
{
    // 利用服务器提供的特性集合创建 TContext
    TContext CreateContext(IFeatureCollection contextFeatures);
 
    // 将创建的 TContext 交由后续的请求处理器处理
    Task ProcessRequestAsync(TContext context);
 
    // 响应完成后回收或反初始化 TContext
    void DisposeContext(TContext context, Exception? exception);
}
```

- HostingApplication

```C#
// IHttpApplication<TContext> 的默认实现
internal sealed class HostingApplication : IHttpApplication<HostingApplication.Context>
{
    // 表示通过中间件构建的请求处理委托链的头部请求处理器
    private readonly RequestDelegate _application;
    private readonly IHttpContextFactory? _httpContextFactory;
    private readonly DefaultHttpContextFactory? _defaultHttpContextFactory;
    private readonly HostingApplicationDiagnostics _diagnostics;
 
    public HostingApplication(
        RequestDelegate application,
        ILogger logger,
        DiagnosticListener diagnosticSource,
        ActivitySource activitySource,
        DistributedContextPropagator propagator,
        IHttpContextFactory httpContextFactory,
        HostingEventSource eventSource,
        HostingMetrics metrics)
    {
        _application = application;
        _diagnostics = new HostingApplicationDiagnostics(logger, diagnosticSource, activitySource, propagator, eventSource, metrics);
        if (httpContextFactory is DefaultHttpContextFactory factory)
        {
            _defaultHttpContextFactory = factory;
        }
        else
        {
            _httpContextFactory = httpContextFactory;
        }
    }
 
    public Context CreateContext(IFeatureCollection contextFeatures)
    {
        Context? hostContext;
        if (contextFeatures is IHostContextContainer<Context> container)
        {
            hostContext = container.HostContext;
            if (hostContext is null)
            {
                hostContext = new Context();
                container.HostContext = hostContext;
            }
        }
        else
        {
            hostContext = new Context();
        }
 
        HttpContext httpContext;
        if (_defaultHttpContextFactory != null)
        {
            var defaultHttpContext = (DefaultHttpContext?)hostContext.HttpContext;
            if (defaultHttpContext is null)
            {
                // 通过 DefaultHttpContextFactory 创建 DefaultHttpContext
                // 本质是利用服务器提供的 IFeatureCollection 特性集合创建 Context
                // IFeatureCollection 特性集合由具体的实现 IServer 的 Web 服务器提供
                httpContext = _defaultHttpContextFactory.Create(contextFeatures);
                // 保存到 Context.HttpContext 中
                hostContext.HttpContext = httpContext;
            }
            else
            {
                _defaultHttpContextFactory.Initialize(defaultHttpContext, contextFeatures);
                httpContext = defaultHttpContext;
            }
        }
        else
        {
            httpContext = _httpContextFactory!.Create(contextFeatures);
            hostContext.HttpContext = httpContext;
        }
 
        _diagnostics.BeginRequest(httpContext, hostContext);
        return hostContext;
    }
 
    public Task ProcessRequestAsync(Context context)
    {
        // 将 HttpContext 送入请求处理器管道
        return _application(context.HttpContext!);
    }
 
    public void DisposeContext(Context context, Exception? exception)
    {
        var httpContext = context.HttpContext!;
        _diagnostics.RequestEnd(httpContext, exception, context);
 
        if (_defaultHttpContextFactory != null)
        {
            // 通过 DefaultHttpContextFactory 释放 HttpContext
            // 本质是将当前线程的 ExecutionContext 中保存的 HttpContext 清空
            _defaultHttpContextFactory.Dispose((DefaultHttpContext)httpContext);
 
            if (_defaultHttpContextFactory.HttpContextAccessor != null)
            {
                context.HttpContext = null;
            }
        }
        else
        {
            _httpContextFactory!.Dispose(httpContext);
        }
 
        _diagnostics.ContextDisposed(context);
 
        context.Reset();
    }
 
    // 对 HttpContext 的封装，同时承载一些诊断相关的信息
    internal sealed class Context
    {
        public HttpContext? HttpContext { get; set; }
        public IDisposable? Scope { get; set; }
        public Activity? Activity
        {
            get => HttpActivityFeature?.Activity;
            set
            {
                if (HttpActivityFeature is null)
                {
                    if (value != null)
                    {
                        HttpActivityFeature = new HttpActivityFeature(value);
                    }
                }
                else
                {
                    HttpActivityFeature.Activity = value!;
                }
            }
        }
        internal HostingRequestStartingLog? StartLog { get; set; }
 
        public long StartTimestamp { get; set; }
        internal bool HasDiagnosticListener { get; set; }
        public bool MetricsEnabled { get; set; }
        public bool EventLogEnabled { get; set; }
 
        internal HttpActivityFeature? HttpActivityFeature;
        internal HttpMetricsTagsFeature? MetricsTagsFeature;
 
        public void Reset()
        {
            Scope = null;
            Activity = null;
            StartLog = null;
 
            StartTimestamp = 0;
            HasDiagnosticListener = false;
            MetricsEnabled = false;
            EventLogEnabled = false;
            MetricsTagsFeature?.TagsList.Clear();
        }
    }
}
```

- GenericWebHostServiceOptions

```C#
// 通用 Web 主机服务选项
internal sealed class GenericWebHostServiceOptions
{
    public Action<IApplicationBuilder>? ConfigureApplication { get; set; }
    
    public WebHostOptions WebHostOptions { get; set; } = default!;
 
    public AggregateException? HostingStartupExceptions { get; set; }
}
```

- GenericWebHostService

```C#
// 通用 Web 主机服务
internal sealed partial class GenericWebHostService : IHostedService
{
    public GenericWebHostService(IOptions<GenericWebHostServiceOptions> options,
                                 IServer server,
                                 ILoggerFactory loggerFactory,
                                 DiagnosticListener diagnosticListener,
                                 ActivitySource activitySource,
                                 DistributedContextPropagator propagator,
                                 IHttpContextFactory httpContextFactory,
                                 IApplicationBuilderFactory applicationBuilderFactory,
                                 IEnumerable<IStartupFilter> startupFilters,
                                 IConfiguration configuration,
                                 IWebHostEnvironment hostingEnvironment,
                                 HostingMetrics hostingMetrics)
    {
        Options = options.Value;
        Server = server;
        Logger = loggerFactory.CreateLogger("Microsoft.AspNetCore.Hosting.Diagnostics");
        LifetimeLogger = loggerFactory.CreateLogger("Microsoft.Hosting.Lifetime");
        DiagnosticListener = diagnosticListener;
        ActivitySource = activitySource;
        Propagator = propagator;
        HttpContextFactory = httpContextFactory;
        ApplicationBuilderFactory = applicationBuilderFactory;
        StartupFilters = startupFilters;
        Configuration = configuration;
        HostingEnvironment = hostingEnvironment;
        HostingMetrics = hostingMetrics;
    }
 
    public GenericWebHostServiceOptions Options { get; }
    public IServer Server { get; }
    public ILogger Logger { get; }
    public ILogger LifetimeLogger { get; }
    public DiagnosticListener DiagnosticListener { get; }
    public ActivitySource ActivitySource { get; }
    public DistributedContextPropagator Propagator { get; }
    public IHttpContextFactory HttpContextFactory { get; }
    public IApplicationBuilderFactory ApplicationBuilderFactory { get; }
    public IEnumerable<IStartupFilter> StartupFilters { get; }
    public IConfiguration Configuration { get; }
    public IWebHostEnvironment HostingEnvironment { get; }
    public HostingMetrics HostingMetrics { get; }
 
    public async Task StartAsync(CancellationToken cancellationToken)
    {
        HostingEventSource.Log.HostStart();
 
        var serverAddressesFeature = Server.Features.Get<IServerAddressesFeature>();
        var addresses = serverAddressesFeature?.Addresses;
        // 必须存在 IServerAddressesFeature 特性才会绑定监听地址和端口
        if (addresses != null && !addresses.IsReadOnly && addresses.Count == 0)
        {
            // 从配置中读取 "urls" 配置节表示的地址（包含端口），多个地址用 ";" 分割
            var urls = Configuration[WebHostDefaults.ServerUrlsKey];
 
            if (string.IsNullOrEmpty(urls))
            {
                // 从备用配置读取
                urls = Options.WebHostOptions.ServerUrls;
            }

            // 从配置中读取 "http_ports" 和 "https_ports" 配置节表示的端口，多个端口用 ";" 分割
            // 这两个配置的优先级比较低，只有在 "urls" 配置节不存在时启用
            // 并且会使用 "*" 通配符表示监听本机所有地址，包括环回地址
            var httpPorts = Configuration[WebHostDefaults.HttpPortsKey] ?? string.Empty;
            var httpsPorts = Configuration[WebHostDefaults.HttpsPortsKey] ?? string.Empty;
            if (string.IsNullOrEmpty(urls))
            {
                static string ExpandPorts(string ports, string scheme)
                {
                    return string.Join(';',
                        ports.Split(';', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries)
                        .Select(port => $"{scheme}://*:{port}"));
                }
 
                var httpUrls = ExpandPorts(httpPorts, Uri.UriSchemeHttp);
                var httpsUrls = ExpandPorts(httpsPorts, Uri.UriSchemeHttps);
                urls = $"{httpUrls};{httpsUrls}";
            }
            else if (!string.IsNullOrEmpty(httpPorts) || !string.IsNullOrEmpty(httpsPorts))
            {
                Logger.PortsOverridenByUrls(httpPorts, httpsPorts, urls);
            }
 
            if (!string.IsNullOrEmpty(urls))
            {
                // Kestrel 服务器提供了 ConfigureKestrel 扩展方法来注册 KestrelServerOptions 的选项配置
                // 通过调用 KesrelServerOptions.Listen 方法可以直接设置 ip 地址和 port 端口用于服务器监听
                // 如果从配置中读取 "preferHostingUrls" 配置节的值为 true，则会优先使用应用配置中的地址
                // 默认为 false，表明使用 KesrelServerOptions.Listen 方法直接设置地址时，则会优先使用该地址
                var preferHostingUrlsConfig = Configuration[WebHostDefaults.PreferHostingUrlsKey];
 
                if (!string.IsNullOrEmpty(preferHostingUrlsConfig))
                {
                    serverAddressesFeature!.PreferHostingUrls = WebHostUtilities.ParseBool(preferHostingUrlsConfig);
                }
                else
                {
                    serverAddressesFeature!.PreferHostingUrls = Options.WebHostOptions.PreferHostingUrls;
                }
 
                foreach (var value in urls.Split(';', StringSplitOptions.RemoveEmptyEntries))
                {
                    addresses.Add(value);
                }
            }
        }
 
        RequestDelegate? application = null;
 
        try
        {
            // 从 GenericWebHostServiceOptions 选项中取出 Action<IApplicationBuilder> 针对中间件建造者的配置
            var configure = Options.ConfigureApplication;
 
            if (configure == null)
            {
                throw new InvalidOperationException($"No application configured. Please specify an application via IWebHostBuilder.UseStartup, IWebHostBuilder.Configure, or specifying the startup assembly via {nameof(WebHostDefaults.StartupAssemblyKey)} in the web host configuration.");
            }

            // 利用服务器提供的特性集合创建 IApplicationBuilder
            var builder = ApplicationBuilderFactory.CreateBuilder(Server.Features);
 
            // 反转注册的 IStartupFilter 集合，保证先注册的配置后执行
            // 构建 Action<IApplicationBuilder> -> ... -> Action<IApplicationBuilder> 配置委托链
            // 并将 GenericWebHostServiceOptions.ConfigureApplication 保存的配置作为末端配置最后执行
            foreach (var filter in StartupFilters.Reverse())
            {
                configure = filter.Configure(configure);
            }

            // 执行配置委托链，注册中间件
            configure(builder);
 
            // 构建请求处理委托链并返回头部的请求处理器
            application = builder.Build();
        }
        catch (Exception ex)
        {
            Logger.ApplicationError(ex);
 
            if (!Options.WebHostOptions.CaptureStartupErrors)
            {
                throw;
            }
 
            var showDetailedErrors = HostingEnvironment.IsDevelopment() || Options.WebHostOptions.DetailedErrors;
 
            application = ErrorPageBuilder.BuildErrorPageApplication(HostingEnvironment.ContentRootFileProvider, Logger, showDetailedErrors, ex);
        }

        // 创建 HostingApplication（实现 IHttpApplication<HostingApplication.Context>）
        var httpApplication = new HostingApplication(application, Logger, DiagnosticListener, ActivitySource, Propagator, HttpContextFactory, HostingEventSource.Log, HostingMetrics);

        // 启动服务器
        await Server.StartAsync(httpApplication, cancellationToken);
        // 输出诊断日志
        HostingEventSource.Log.ServerReady();
 
        if (addresses != null)
        {
            foreach (var address in addresses)
            {
                Log.ListeningOnAddress(LifetimeLogger, address);
            }
        }
 
        if (Logger.IsEnabled(LogLevel.Debug))
        {
            foreach (var assembly in Options.WebHostOptions.GetFinalHostingStartupAssemblies())
            {
                Log.StartupAssemblyLoaded(Logger, assembly);
            }
        }
 
        if (Options.HostingStartupExceptions != null)
        {
            foreach (var exception in Options.HostingStartupExceptions.InnerExceptions)
            {
                Logger.HostingStartupAssemblyError(exception);
            }
        }
    }
 
    public async Task StopAsync(CancellationToken cancellationToken)
    {
        try
        {
            // 停止服务器
            await Server.StopAsync(cancellationToken);
        }
        finally
        {
            HostingEventSource.Log.HostStop();
        }
    }
 
    private static partial class Log
    {
        [LoggerMessage(14, LogLevel.Information,
            "Now listening on: {address}",
            EventName = "ListeningOnAddress")]
        public static partial void ListeningOnAddress(ILogger logger, string address);
 
        [LoggerMessage(13, LogLevel.Debug,
            "Loaded hosting startup assembly {assemblyName}",
            EventName = "HostingStartupAssemblyLoaded",
            SkipEnabledCheck = true)]
        public static partial void StartupAssemblyLoaded(ILogger logger, string assemblyName);
    }
}
```
