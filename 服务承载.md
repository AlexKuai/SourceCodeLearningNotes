# 服务承载

## 源码涉及的核心类型

- IHostedService  
- BackgroundService  
- ServiceCollectionHostedServiceExtensions  
- Environments  
- HostDefaults  
- IHostEnvironment  
- HostingEnvironment  
- HostBuilderContext  
- IHostBuilder  
- HostBuilder  
- HostingHostBuilderExtensions  
- IHostApplicationLifetime  
- ApplicationLifetime  
- IHostLifetime  
- ConsoleLifetime  
- Microsoft.Extensions.Hosting.Host  
- IHost  
- Microsoft.Extensions.Hosting.Internal.Host  
- HostingAbstractionsHostExtensions  

## 承载模型

- IHostedService

```C#
// 寄宿服务的抽象表示
// 表示一个长时间运行的服务
public interface IHostedService
{
    // 启动服务
    Task StartAsync(CancellationToken cancellationToken);

    // 停止服务
    Task StopAsync(CancellationToken cancellationToken);
}
```

- BackgroundService

```C#
// 实现 IHostedService 接口的抽象类
// 表示一个后台任务
public abstract class BackgroundService : IHostedService, IDisposable
{
    private Task? _executeTask;
    private CancellationTokenSource? _stoppingCts;

    // 返回一个长时间运行的任务
    public virtual Task? ExecuteTask => _executeTask;
 
    // 实现类重写该方法，返回一个长时间运行的任务
    protected abstract Task ExecuteAsync(CancellationToken stoppingToken);

    // 启动服务
    public virtual Task StartAsync(CancellationToken cancellationToken)
    {
        // 利用外部的 CancellationToken，创建一个被链接 CancellationTokenSource
        // 根据被链接 CancellationToken 数量有如下几个实现：
        // 1. Linked1CancellationTokenSource
        // 2. Linked2CancellationTokenSource
        // 3. LinkedNCancellationTokenSource
        _stoppingCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

        // 创建一个长时间运行的任务，由实现类重写
        // 此处传入的 CancellationToken 是被链接的 CancellationTokenSource 创建的
        _executeTask = ExecuteAsync(_stoppingCts.Token);

        // 如果任务同步完成，直接返回这个已经完成的 Task
        if (_executeTask.IsCompleted)
        {
            return _executeTask;
        }

        // 否则返回一个 Task.CompletedTask 创建的 Task
        // 注意：此处的完成仅表示启动完成
        return Task.CompletedTask;
    }

    // 停止服务
    public virtual async Task StopAsync(CancellationToken cancellationToken)
    {
        // 没有任务，直接返回
        if (_executeTask == null)
        {
            return;
        }

        try
        {
            // 停止服务是通过被链接的 CancellationTokenSource 调用 Cancel 方法发出取消任务通知
            _stoppingCts!.Cancel();
        }
        finally
        {
            // 创建一个任务完成源
            var tcs = new TaskCompletionSource<object>();
            using CancellationTokenRegistration registration 
                = cancellationToken.Register(s => ((TaskCompletionSource<object>)s!).SetCanceled(), tcs);
            // 可以不等待任务取消，通过外部取消任务完成源提前结束
            await Task.WhenAny(_executeTask, tcs.Task).ConfigureAwait(false);
        }
    }

    // 释放操作
    // 本质是通知任务取消
    public virtual void Dispose()
    {
        _stoppingCts?.Cancel();
    }
}
```

- ServiceCollectionHostedServiceExtensions

```C#
// 提供注册 IHostedService 服务的扩展方法
public static class ServiceCollectionHostedServiceExtensions
{
    public static IServiceCollection AddHostedService<THostedService>(this IServiceCollection services)
        where THostedService : class, IHostedService
    {
        services.TryAddEnumerable(ServiceDescriptor.Singleton<IHostedService, THostedService>());

        return services;
    }

    public static IServiceCollection AddHostedService<THostedService>(this IServiceCollection services, Func<IServiceProvider,THostedService> implementationFactory)
        where THostedService : class, IHostedService
    {
        services.TryAddEnumerable(ServiceDescriptor.Singleton<IHostedService>(implementationFactory));

        return services;
    }
}
```

- Environments

```C#
// 环境名称
public static class Environments
{
    // 开发
    public static readonly string Development = "Development";
    // 预发（测试）
    public static readonly string Staging = "Staging";
    // 生产
    public static readonly string Production = "Production";
}
```

- HostDefaults

```C#
// 默认配置键
public static class HostDefaults
{
    public static readonly string ApplicationKey = "applicationName";

    public static readonly string EnvironmentKey = "environment";

    public static readonly string ContentRootKey = "contentRoot";
}
```

- IHostEnvironment

```C#
// 宿主环境的抽象表示
public interface IHostEnvironment
{
    // 环境名称
    string EnvironmentName { get; set; }

    // 应用名称
    string ApplicationName { get; set; }

    // 根目录路径
    string ContentRootPath { get; set; }

    // 指向根目录的 IFileProvider
    IFileProvider ContentRootFileProvider { get; set; }
}
```

- HostingEnvironment

```C#
// IHostEnvironment 的默认实现
// 实现的 IHostingEnvironment 接口已作废，换用 IHostEnvironment 接口替代
#pragma warning disable CS0618 // Type or member is obsolete
public class HostingEnvironment : IHostingEnvironment, IHostEnvironment
#pragma warning restore CS0618 // Type or member is obsolete
{
    public string EnvironmentName { get; set; } = string.Empty;

    public string ApplicationName { get; set; } = string.Empty;

    public string ContentRootPath { get; set; } = string.Empty;

    public IFileProvider ContentRootFileProvider { get; set; } = null!;
}
```

- HostBuilderContext

```C#
// 宿主建造者上下文
public class HostBuilderContext
{
    public HostBuilderContext(IDictionary<object, object> properties)
    {
        ThrowHelper.ThrowIfNull(properties);

        Properties = properties;
    }

    // 宿主环境
    public IHostEnvironment HostingEnvironment { get; set; } = null!;

    // 初始表示针对宿主的配置
    // 最终会结合针对应用的配置
    public IConfiguration Configuration { get; set; } = null!;

    // 在宿主构建过程中用于共享的属性字典
    public IDictionary<object, object> Properties { get; }
}
```

- IHostBuilder

```C#
// 宿主建造者的抽象表示
public interface IHostBuilder
{
    // 在宿主构建过程中用于共享的属性字典
    IDictionary<object, object> Properties { get; }

    // 添加针对宿主的配置
    IHostBuilder ConfigureHostConfiguration(Action<IConfigurationBuilder> configureDelegate);

    // 添加针对应用的配置
    IHostBuilder ConfigureAppConfiguration(Action<HostBuilderContext, IConfigurationBuilder> configureDelegate);

    // 添加针对服务注册的配置
    IHostBuilder ConfigureServices(Action<HostBuilderContext, IServiceCollection> configureDelegate);

    // 使用指定的 IServiceProvider 工厂
    IHostBuilder UseServiceProviderFactory<TContainerBuilder>(IServiceProviderFactory<TContainerBuilder> factory) where TContainerBuilder : notnull;

    // 使用指定的 IServiceProvider 工厂
    // 利用 HostBuilderContext 得到 IServiceProvider 工厂
    IHostBuilder UseServiceProviderFactory<TContainerBuilder>(Func<HostBuilderContext, IServiceProviderFactory<TContainerBuilder>> factory)  where TContainerBuilder : notnull;

    // 添加针对容器建造者的配置
    IHostBuilder ConfigureContainer<TContainerBuilder>(Action<HostBuilderContext, TContainerBuilder> configureDelegate);

    // 构建 IHost
    IHost Build();
}
```

- HostBuilder

```C#
// IHostBuilder 的默认实现
// 通过收集针对宿主、应用、服务注册、容器建造者的配置来构建 IHost
public partial class HostBuilder : IHostBuilder
{
    // 创建 DiagnosticListener 的名称
    private const string HostBuildingDiagnosticListenerName = "Microsoft.Extensions.Hosting";
    // 通过 DiagnosticListener 发送的诊断日志事件名称
    private const string HostBuildingEventName = "HostBuilding";
    private const string HostBuiltEventName = "HostBuilt";

    // 收集针对宿主配置的列表
    private readonly List<Action<IConfigurationBuilder>> _configureHostConfigActions = new List<Action<IConfigurationBuilder>>();
    // 收集针对应用配置的列表
    private readonly List<Action<HostBuilderContext, IConfigurationBuilder>> _configureAppConfigActions 
        = new List<Action<HostBuilderContext, IConfigurationBuilder>>();
    // 收集针对服务注册配置的列表
    private readonly List<Action<HostBuilderContext, IServiceCollection>> _configureServicesActions 
        = new List<Action<HostBuilderContext, IServiceCollection>>();
    // 收集针对容器建造者配置的列表
    private readonly List<IConfigureContainerAdapter> _configureContainerActions = new List<IConfigureContainerAdapter>();
    // 针对 IServiceProviderFactory<> 的适配器
    private IServiceFactoryAdapter _serviceProviderFactory;
    // 构建完成标志，用于检查是否重复构建
    private bool _hostBuilt;
    // 宿主配置
    private IConfiguration? _hostConfiguration;
    // 应用配置
    // 构建应用配置时宿主配置会作为 ChainedConfigurationSource 配置源添加
    private IConfiguration? _appConfiguration;
    // 宿主建造者上下文
    private HostBuilderContext? _hostBuilderContext;
    // 通过宿主配置创建的 HostingEnvironment
    private HostingEnvironment? _hostingEnvironment;
    // 代表根容器的 IServiceProvider
    private IServiceProvider? _appServices;
    // 指向 IHostEnvironment.ContentRootPath 目录（一般为应用程序根目录 AppContext.BaseDirectory）的 IFileProvider
    // 此处的 IFileProvider 和 IHostEnvironment.ContentRootFileProvider 是同一个实例
    private PhysicalFileProvider? _defaultProvider;

    public HostBuilder()
    {
        // 利用 DefaultServiceProviderFactory 创建 IServiceFactoryAdapter
        // 如果在构建过程中没有调用 UseServiceProviderFactory 方法添加外部的 IServiceProvider 工厂
        // 则使用 DefaultServiceProviderFactory 作为默认的 IServiceProvider 工厂
        _serviceProviderFactory = new ServiceFactoryAdapter<IServiceCollection>(new DefaultServiceProviderFactory());
    }

    // 在宿主构建过程中用于共享的属性字典
    public IDictionary<object, object> Properties { get; } = new Dictionary<object, object>();

    // 收集针对宿主的配置
    public IHostBuilder ConfigureHostConfiguration(Action<IConfigurationBuilder> configureDelegate)
    {
        ThrowHelper.ThrowIfNull(configureDelegate);

        _configureHostConfigActions.Add(configureDelegate);
        return this;
    }

    // 收集针对应用的配置
    public IHostBuilder ConfigureAppConfiguration(Action<HostBuilderContext, IConfigurationBuilder> configureDelegate)
    {
        ThrowHelper.ThrowIfNull(configureDelegate);

        _configureAppConfigActions.Add(configureDelegate);
        return this;
    }

    // 收集针对服务注册的配置
    public IHostBuilder ConfigureServices(Action<HostBuilderContext, IServiceCollection> configureDelegate)
    {
        ThrowHelper.ThrowIfNull(configureDelegate);

        _configureServicesActions.Add(configureDelegate);
        return this;
    }

    // 使用指定的 IServiceProvider 工厂
    public IHostBuilder UseServiceProviderFactory<TContainerBuilder>(IServiceProviderFactory<TContainerBuilder> factory) where TContainerBuilder : notnull
    {
        ThrowHelper.ThrowIfNull(factory);

        // 利用 IServiceProviderFactory<> 适配器封装 IServiceProviderFactory<TContainerBuilder>
        _serviceProviderFactory = new ServiceFactoryAdapter<TContainerBuilder>(factory);
        return this;
    }

    // 根据 Func<HostBuilderContext, IServiceProviderFactory<TContainerBuilder>> 得到 IServiceProvider 工厂
    public IHostBuilder UseServiceProviderFactory<TContainerBuilder>(Func<HostBuilderContext, IServiceProviderFactory<TContainerBuilder>> factory) where TContainerBuilder : notnull
    {
        ThrowHelper.ThrowIfNull(factory);

        // 利用 IServiceProviderFactory<> 适配器封装 Func<HostBuilderContext, IServiceProviderFactory<TContainerBuilder>>
        _serviceProviderFactory = new ServiceFactoryAdapter<TContainerBuilder>(() => _hostBuilderContext!, factory);
        return this;
    }

    // 添加针对容器建造者的配置
    public IHostBuilder ConfigureContainer<TContainerBuilder>(Action<HostBuilderContext, TContainerBuilder> configureDelegate)
    {
        ThrowHelper.ThrowIfNull(configureDelegate);

        // 利用 IServiceProviderFactory<> 适配器封装针对 TContainerBuilder 的配置
        _configureContainerActions.Add(new ConfigureContainerAdapter<TContainerBuilder>(configureDelegate));
        return this;
    }

    // 构建 IHost
    public IHost Build()
    {
        // 不支持重复构建，否则抛出异常
        if (_hostBuilt)
        {
            throw new InvalidOperationException(SR.BuildCalled);
        }
        _hostBuilt = true;
 
        // 利用诊断日志创建名为 "Microsoft.Extensions.Hosting" 的 DiagnosticListener
        // 用于记录名为 "HostBuilding" 的诊断日志
        using DiagnosticListener diagnosticListener = LogHostBuilding(this);

        // 创建宿主配置
        InitializeHostConfiguration();
        // 利用宿主配置创建以下内容：
        // 1. 表示环境的 IHostEnvironment
        // 2. 指向 IHostEnvironment.ContentRootPath 的 IFileProvider
        InitializeHostingEnvironment();
        // 创建 HostBuilderContext
        InitializeHostBuilderContext();
        // 利用 HostBuilderContext 创建应用配置
        InitializeAppConfiguration();
        // 创建表示根容器的 IServiceProvider
        InitializeServiceProvider();
 
        // 创建 IHost
        return ResolveHost(_appServices, diagnosticListener);
    }

    // 创建宿主配置
    private void InitializeHostConfiguration()
    {
        // 默认添加一个空的内存配置源
        IConfigurationBuilder configBuilder = new ConfigurationBuilder().AddInMemoryCollection();

        // 遍历并执行收集的宿主配置
        foreach (Action<IConfigurationBuilder> buildAction in _configureHostConfigActions)
        {
            buildAction(configBuilder);
        }

        // 构建宿主配置
        _hostConfiguration = configBuilder.Build();
    }

    // 利用宿主配置创建 IHostEnvironment 与表示应用程序根目录的 IFileProvider
    private void InitializeHostingEnvironment()
    {
        (_hostingEnvironment, _defaultProvider) = CreateHostingEnvironment(_hostConfiguration!);
    }

    internal static (HostingEnvironment, PhysicalFileProvider) CreateHostingEnvironment(IConfiguration hostConfiguration)
    {
        var hostingEnvironment = new HostingEnvironment()
        {
            // HostDefaults.EnvironmentKey 表示的配置节不存，则环境默认为 Production 表示的生产环境
            EnvironmentName = hostConfiguration[HostDefaults.EnvironmentKey] ?? Environments.Production,
            // 存在以下三种情况：
            // 1. HostDefaults.ContentRootKey 表示的配置节不存在，则使用 AppContext.BaseDirectory 表示的应用程序根目录的绝对路径
            // 2. HostDefaults.ContentRootKey 表示的配置节的值为绝对路径，则使用 HostDefaults.ContentRootKey 配置节的值表示的绝对路径
            // 3. HostDefaults.ContentRootKey 表示的配置节的值为相对路径，则使用 AppContext.BaseDirectory 表示的应用程序根目录的绝对路径与 HostDefaults.ContentRootKey 配置节的值表示的相对路径拼接
            ContentRootPath = ResolveContentRootPath(hostConfiguration[HostDefaults.ContentRootKey], AppContext.BaseDirectory),
        };
 
        // 如果 HostDefaults.ApplicationKey 表示的配置节存在，则使用 HostDefaults.ApplicationKey 表示的配置节的值作为应用名称
        // 否则使用入口程序集的名称作为应用程序名称
        string? applicationName = hostConfiguration[HostDefaults.ApplicationKey];
        if (string.IsNullOrEmpty(applicationName))
        {
            applicationName = Assembly.GetEntryAssembly()?.GetName().Name;
        }
 
        if (applicationName is not null)
        {
            hostingEnvironment.ApplicationName = applicationName;
        }

        // 利用 IHostEnvironment.ContentRootPath 创建 IFileProvider
        var physicalFileProvider = new PhysicalFileProvider(hostingEnvironment.ContentRootPath);
        hostingEnvironment.ContentRootFileProvider = physicalFileProvider;
 
        return (hostingEnvironment, physicalFileProvider);
    }

    // 利用 IHostEnvironment 与宿主配置创建 HostBuilderContext
    private void InitializeHostBuilderContext()
    {
        _hostBuilderContext = new HostBuilderContext(Properties)
        {
            HostingEnvironment = _hostingEnvironment!,
            Configuration = _hostConfiguration!
        };
    }

    // 创建应用配置
    private void InitializeAppConfiguration()
    {
        // 利用 IHostEnvironment.ContentRootPath 创建共享的 IFileProvider 
        // 并且将宿主配置作为链接配置源添加
        IConfigurationBuilder configBuilder = new ConfigurationBuilder()
            .SetBasePath(_hostingEnvironment!.ContentRootPath)
            .AddConfiguration(_hostConfiguration!, shouldDisposeConfiguration: true);

        // 利用 HostBuilderContext 遍历执行收集的应用配置
        foreach (Action<HostBuilderContext, IConfigurationBuilder> buildAction in _configureAppConfigActions)
        {
            buildAction(_hostBuilderContext!, configBuilder);
        }
        _appConfiguration = configBuilder.Build();
        // 将 HostBuilderContext.Configuration 更换为应用配置
        _hostBuilderContext!.Configuration = _appConfiguration;
    }

    // 创建表示根容器的 IServiceProvider
    private void InitializeServiceProvider()
    {
        var services = new ServiceCollection();

        // 注册基础服务
        PopulateServiceCollection(
            services,
            _hostBuilderContext!,
            _hostingEnvironment!,
            _defaultProvider!,
            _appConfiguration!,
            () => _appServices!);

        // 遍历并执行收集的服务注册配置
        foreach (Action<HostBuilderContext, IServiceCollection> configureServicesAction in _configureServicesActions)
        {
            configureServicesAction(_hostBuilderContext!, services);
        }
 
        // 利用 IServiceProviderFactory<> 适配器创建容器建造者
        object containerBuilder = _serviceProviderFactory.CreateBuilder(services);
 
        // 遍历并执行收集的容器建造者配置
        foreach (IConfigureContainerAdapter containerAction in _configureContainerActions)
        {
            containerAction.ConfigureContainer(_hostBuilderContext!, containerBuilder);
        }

        // 利用容器建造者创建表示根容器的 IServiceProvider
        _appServices = _serviceProviderFactory.CreateServiceProvider(containerBuilder);
    }

    // 注册基础服务
    internal static void PopulateServiceCollection(
        IServiceCollection services,
        HostBuilderContext hostBuilderContext,
        HostingEnvironment hostingEnvironment,
        PhysicalFileProvider defaultFileProvider,
        IConfiguration appConfiguration,
        Func<IServiceProvider> serviceProviderGetter)
    {
#pragma warning disable CS0618 // IHostingEnvironment 已经作废，用 IHostEnvironment 替代
        services.AddSingleton<IHostingEnvironment>(hostingEnvironment);
#pragma warning restore CS0618
        // 注册 IHostEnvironment，使用 HostingEnvironment 实例
        services.AddSingleton<IHostEnvironment>(hostingEnvironment);
        // 注册 HostBuilderContext，使用 HostBuilderContext 实例
        services.AddSingleton(hostBuilderContext);
        // 注册 IConfiguration，使用 Func<IServiceProvider, IConfiguration> 工厂
        services.AddSingleton(_ => appConfiguration);
#pragma warning disable CS0618 // IApplicationLifetime 已经作废，用 IHostApplicationLifetime 替代
        services.AddSingleton(s => (IApplicationLifetime)s.GetRequiredService<IHostApplicationLifetime>());
#pragma warning restore CS0618 
        // 注册 IHostApplicationLifetime，使用 ApplicationLifetime 类型
        services.AddSingleton<IHostApplicationLifetime, ApplicationLifetime>();

        // 注册宿主生命周期服务
        AddLifetime(services);
 
        // 注册 IHost，使用 Func<IServiceProvider, Internal.Host> 工厂
        services.AddSingleton<IHost>(_ =>
        {
            // 利用闭包方式从 _appServices 中获取 IServiceProvider
            IServiceProvider appServices = serviceProviderGetter();
            return new Internal.Host(appServices,
                hostingEnvironment,
                defaultFileProvider,
                appServices.GetRequiredService<IHostApplicationLifetime>(),
                appServices.GetRequiredService<ILogger<Internal.Host>>(),
                appServices.GetRequiredService<IHostLifetime>(),
                appServices.GetRequiredService<IOptions<HostOptions>>());
        });
        // 注册选项的基础服务
        services
            .AddOptions()
            .Configure<HostOptions>(
                options => options.Initialize(hostBuilderContext.Configuration));
        // 注册日志的基础服务
        services.AddLogging();
        services.AddMetrics();
    }

    // 注册宿主生命周期服务
    private static void AddLifetime(IServiceCollection services)
    {
        // 非移动端情况下注册 IHostLifetime，使用 ConsoleLifetime 类型
        if (!OperatingSystem.IsAndroid() && !OperatingSystem.IsBrowser() && !OperatingSystem.IsIOS() && !OperatingSystem.IsTvOS())
        {
            services.AddSingleton<IHostLifetime, ConsoleLifetime>();
        }
        else
        {
            services.AddSingleton<IHostLifetime, NullLifetime>();
        }
    }

    // 创建 IHost
    internal static IHost ResolveHost(IServiceProvider serviceProvider, DiagnosticListener diagnosticListener)
    {
        if (serviceProvider is null)
        {
            throw new InvalidOperationException(SR.NullIServiceProvider);
        }

        // 利用根容器显式获取一次 IConfiguration，确保根容器存在
        _ = serviceProvider.GetService<IConfiguration>();
 
        // 利用根容器显式获取 IHost
        var host = serviceProvider.GetRequiredService<IHost>();

        // 利用诊断日志创建名为 "Microsoft.Extensions.Hosting" 的 DiagnosticListener
        // 用于记录名为 "HostBuilt" 的事件日志
        if (diagnosticListener.IsEnabled() && diagnosticListener.IsEnabled(HostBuiltEventName))
        {
            Write(diagnosticListener, HostBuiltEventName, host);
        }
 
        return host;
    }
}
```

- HostingHostBuilderExtensions

```C#
// 提供额外添加宿主构建配置的扩展方法
public static class HostingHostBuilderExtensions
{
    // 通过指定的环境名称，添加针对宿主的配置
    public static IHostBuilder UseEnvironment(this IHostBuilder hostBuilder, string environment)
    {
        return hostBuilder.ConfigureHostConfiguration(configBuilder =>
        {
            ThrowHelper.ThrowIfNull(environment);

            configBuilder.AddInMemoryCollection(new[]
            {
                new KeyValuePair<string, string?>(HostDefaults.EnvironmentKey, environment)
            });
        });
    }

    // 通过指定的工作目录路径，添加针对宿主的配置
    public static IHostBuilder UseContentRoot(this IHostBuilder hostBuilder, string contentRoot)
    {
        return hostBuilder.ConfigureHostConfiguration(configBuilder =>
        {
            ThrowHelper.ThrowIfNull(contentRoot);

            configBuilder.AddInMemoryCollection(new[]
            {
                new KeyValuePair<string, string?>(HostDefaults.ContentRootKey, contentRoot)
            });
        });
    }

    // 使用 ServiceProviderOptions 配置创建 DefaultServiceProviderFactory
    public static IHostBuilder UseDefaultServiceProvider(this IHostBuilder hostBuilder, Action<ServiceProviderOptions> configure)
        => hostBuilder.UseDefaultServiceProvider((context, options) => configure(options));

    // 使用 ServiceProviderOptions 配置创建 DefaultServiceProviderFactory
    public static IHostBuilder UseDefaultServiceProvider(this IHostBuilder hostBuilder, Action<HostBuilderContext, ServiceProviderOptions> configure)
    {
        return hostBuilder.UseServiceProviderFactory(context =>
        {
            var options = new ServiceProviderOptions();
            configure(context, options);
            return new DefaultServiceProviderFactory(options);
        });
    }
    
    // 添加针对容器建造者的配置
    public static IHostBuilder ConfigureContainer<TContainerBuilder>(this IHostBuilder hostBuilder, Action<TContainerBuilder> configureDelegate)
    {
        return hostBuilder.ConfigureContainer<TContainerBuilder>((context, builder) => configureDelegate(builder));
    }

    // 添加针对服务注册的配置
    public static IHostBuilder ConfigureServices(this IHostBuilder hostBuilder, Action<IServiceCollection> configureDelegate)
    {
        return hostBuilder.ConfigureServices((context, collection) => configureDelegate(collection));
    }

    // 添加针对日志的配置
    public static IHostBuilder ConfigureLogging(this IHostBuilder hostBuilder, Action<ILoggingBuilder> configureLogging)
    {
        return hostBuilder.ConfigureServices((context, collection) => collection.AddLogging(builder => configureLogging(builder)));
    }
    
    // 添加针对日志的配置
    public static IHostBuilder ConfigureLogging(this IHostBuilder hostBuilder, Action<HostBuilderContext, ILoggingBuilder> configureLogging)
    {
        return hostBuilder.ConfigureServices((context, collection) => collection.AddLogging(builder => configureLogging(context, builder)));
    }

    // 添加针对应用的配置
    public static IHostBuilder ConfigureAppConfiguration(this IHostBuilder hostBuilder, Action<IConfigurationBuilder> configureDelegate)
    {
        return hostBuilder.ConfigureAppConfiguration((context, builder) => configureDelegate(builder));
    }

    // 注册 HostOptions 选项配置
    public static IHostBuilder ConfigureHostOptions(this IHostBuilder hostBuilder, Action<HostBuilderContext, HostOptions> configureOptions)
    {
        return hostBuilder.ConfigureServices(
            (context, collection) => collection.Configure<HostOptions>(options => configureOptions(context, options)));
    }

    // 注册 HostOptions 选项配置
    public static IHostBuilder ConfigureHostOptions(this IHostBuilder hostBuilder, Action<HostOptions> configureOptions)
    {
        return hostBuilder.ConfigureServices(collection => collection.Configure(configureOptions));
    }

    // 添加默认配置
    public static IHostBuilder ConfigureDefaults(this IHostBuilder builder, string[]? args)
    {
        return builder
            .ConfigureHostConfiguration(config => ApplyDefaultHostConfiguration(config, args))
            .ConfigureAppConfiguration((hostingContext, config) => ApplyDefaultAppConfiguration(hostingContext, config, args))
            .ConfigureServices(AddDefaultServices)
            .UseServiceProviderFactory(context => new DefaultServiceProviderFactory(CreateDefaultServiceProviderOptions(context)));
    }

    // 应用默认宿主配置
    private static void ApplyDefaultHostConfiguration(IConfigurationBuilder hostConfigBuilder, string[]? args)
    {
        // 添加内存配置源
        // 设置默认的工作目录路径（一般为应用程序根目录）
        SetDefaultContentRoot(hostConfigBuilder);

        // 添加前缀为 DOTNET_ 的环境变量配置源
        hostConfigBuilder.AddEnvironmentVariables(prefix: "DOTNET_");
        // 添加命令行参数配置源
        AddCommandLineConfig(hostConfigBuilder, args);
    }

    internal static void SetDefaultContentRoot(IConfigurationBuilder hostConfigBuilder)
    {
        string cwd = Environment.CurrentDirectory;
        if (
#if NETFRAMEWORK
            Environment.OSVersion.Platform != PlatformID.Win32NT ||
#else
            !RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ||
#endif
            !string.Equals(cwd, Environment.SystemDirectory, StringComparison.OrdinalIgnoreCase))
        {
            hostConfigBuilder.AddInMemoryCollection(new[]
            {
                new KeyValuePair<string, string?>(HostDefaults.ContentRootKey, cwd),
            });
        }
    }

    internal static void AddCommandLineConfig(IConfigurationBuilder configBuilder, string[]? args)
    {
        if (args is { Length: > 0 })
        {
            configBuilder.AddCommandLine(args);
        }
    }

    // 应用默认应用配置
    internal static void ApplyDefaultAppConfiguration(HostBuilderContext hostingContext, IConfigurationBuilder appConfigBuilder, string[]? args)
    {
        IHostEnvironment env = hostingContext.HostingEnvironment;
        // 利用宿主的配置，确定是否需要打开针对文件变动的监控
        bool reloadOnChange = GetReloadConfigOnChangeValue(hostingContext);

        // 以可选形式添加名称为 appsettings.json 和 appsettings.{环境名称}.json 的文件配置源
        // 是否监控文件变动由 reloadOnChange 的值决定
        appConfigBuilder.AddJsonFile("appsettings.json", optional: true, reloadOnChange: reloadOnChange)
                .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true, reloadOnChange: reloadOnChange);

        // 如果是开发环境并且 ApplicationName 不为空，则添加用户机密配置源
        if (env.IsDevelopment() && env.ApplicationName is { Length: > 0 })
        {
            try
            {
                // 加载应用程序名称所对应的程序集
                var appAssembly = Assembly.Load(new AssemblyName(env.ApplicationName));
                // 如果程序集使用了 UserSecretsIdAttribute 特性
                // 则从 UserSecretsIdAttribute.UserSecretsId 中读取用户机密 ID
                // 根据不同的操作系统加载用户机密 ID 目录下的 secrets.json 文件作为配置源
                // 1. Windows 系统加载 %APPDATA%\Microsoft\UserSecrets\<用户机密 ID>\secrets.json
                // 2. Mac/Linux 系统加载 ~/.microsoft/usersecrets/<用户机密 ID>/secrets.json
                appConfigBuilder.AddUserSecrets(appAssembly, optional: true, reloadOnChange: reloadOnChange);
            }
            catch (FileNotFoundException)
            {
                // 没有找到程序集，跳过
            }
        }

        // 添加环境变量配置源（所有环境变量）
        appConfigBuilder.AddEnvironmentVariables();

        // 添加命令行配置源
        AddCommandLineConfig(appConfigBuilder, args);

        // 从宿主配置的 "hostBuilder:reloadConfigOnChange" 配置节确定是否需要打开针对文件配置源变动的监控
        static bool GetReloadConfigOnChangeValue(HostBuilderContext hostingContext) => hostingContext.Configuration.GetValue("hostBuilder:reloadConfigOnChange", defaultValue: true);
    }

    // 注册默认服务
    // 针对日志的服务注册
    internal static void AddDefaultServices(HostBuilderContext hostingContext, IServiceCollection services)
    {
        services.AddLogging(logging =>
        {
            bool isWindows =
#if NETCOREAPP
                OperatingSystem.IsWindows();
#elif NETFRAMEWORK
                Environment.OSVersion.Platform == PlatformID.Win32NT;
#else
                RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
#endif
 
            if (isWindows)
            {
                // 在 Windows 系统上添加针对 EventLogLoggerProvider 的日志过滤
                // 默认 EventLogLoggerProvider 的日志过滤级别不低于 Warning
                logging.AddFilter<EventLogLoggerProvider>(level => level >= LogLevel.Warning);
            }

            // 得到 Logging 配置节作为日志配置
            logging.AddConfiguration(hostingContext.Configuration.GetSection("Logging"));
#if NETCOREAPP
            if (!OperatingSystem.IsBrowser())
#endif
            {
                // 注册 ConsoleLoggerProvider
                logging.AddConsole();
            }
            // 注册 DebugLoggerProvider
            logging.AddDebug();
            // 注册 EventSourceLoggerProvider
            logging.AddEventSourceLogger();
 
            if (isWindows)
            {
                // 在 Windows 系统上注册 EventLogLoggerProvider
                logging.AddEventLog();
            }
 
            // 注册 ActivityTrackingOptions 选项配置
            // 使用 Activity 作为日志范围的活动跟踪
            logging.Configure(options =>
            {
                options.ActivityTrackingOptions =
                    ActivityTrackingOptions.SpanId |
                    ActivityTrackingOptions.TraceId |
                    ActivityTrackingOptions.ParentId;
            });
        });
 
        services.AddMetrics(metrics =>
        {
            metrics.AddConfiguration(hostingContext.Configuration.GetSection("Metrics"));
        });
    }

    // 配置默认 ServiceProviderOptions
    // 只在开发环境启用服务范围验证，并在构建时验证
    internal static ServiceProviderOptions CreateDefaultServiceProviderOptions(HostBuilderContext context)
    {
        bool isDevelopment = context.HostingEnvironment.IsDevelopment();
        return new ServiceProviderOptions
        {
            ValidateScopes = isDevelopment,
            ValidateOnBuild = isDevelopment,
        };
    }
}
```

- IHostApplicationLifetime

```C#
// 应用生命周期的抽象表示
public interface IHostApplicationLifetime
{
    // 用来在应用启动完成时候发出通知
    CancellationToken ApplicationStarted { get; }
 
    // 用来在应用开始停止时发出通知
    CancellationToken ApplicationStopping { get; }
 
    // 用来在应用停止完成时发出通知
    CancellationToken ApplicationStopped { get; }
 
    // 停止应用
    void StopApplication();
}
```

- ApplicationLifetime

```C#
// IHostApplicationLifetime 的默认实现
// IApplicationLifetime 已经作废，用 IHostApplicationLifetime 替代
#pragma warning disable CS0618
    public class ApplicationLifetime : IApplicationLifetime, IHostApplicationLifetime
#pragma warning restore CS0618
{
    private readonly CancellationTokenSource _startedSource = new CancellationTokenSource();
    private readonly CancellationTokenSource _stoppingSource = new CancellationTokenSource();
    private readonly CancellationTokenSource _stoppedSource = new CancellationTokenSource();
    // 日志类别为 "Microsoft.Extensions.Hosting.Internal.ApplicationLifetime" 的 ILogger
    private readonly ILogger<ApplicationLifetime> _logger;

    public ApplicationLifetime(ILogger<ApplicationLifetime> logger)
    {
        _logger = logger;
    }

    // 这三个属性用来通过对应的 CancellationTokenSource 得到 CancellationToken
    public CancellationToken ApplicationStarted => _startedSource.Token;

    public CancellationToken ApplicationStopping => _stoppingSource.Token;

    public CancellationToken ApplicationStopped => _stoppedSource.Token;

    // 开始停止应用
    public void StopApplication()
    {
        // 此处需要同步调用 CancellationTokenSource.Cancel 方法
        lock (_stoppingSource)
        {
            try
            {
                // 开始停止应用，触发回调
                _stoppingSource.Cancel();
            }
            catch (Exception ex)
            {
                _logger.ApplicationError(LoggerEventIds.ApplicationStoppingException, "An error occurred stopping the application", ex);
            }
        }
    }

    // 通知应用启动完成
    public void NotifyStarted()
    {
        try
        {
            // 应用启动完成，触发回调
            _startedSource.Cancel();
        }
        catch (Exception ex)
        {
            _logger.ApplicationError(LoggerEventIds.ApplicationStartupException, "An error occurred starting the application", ex);
        }
    }

    // 通知应用停止完成
    public void NotifyStopped()
    {
        try
        {
            // 应用停止完成，触发回调
            _stoppedSource.Cancel();
        }
        catch (Exception ex)
        {
            _logger.ApplicationError(LoggerEventIds.ApplicationStoppedException, "An error occurred stopping the application", ex);
        }
    }
}
```

- IHostLifetime

```C#
// 宿主生命周期的抽象表示
public interface IHostLifetime
{
    // 等待寄宿的应用启动完成
    Task WaitForStartAsync(CancellationToken cancellationToken);
    
    // 停止宿主并停止寄宿的应用
    Task StopAsync(CancellationToken cancellationToken);
}
```

- ConsoleLifetime

```C#
// 基于控制台的宿主生命周期
public partial class ConsoleLifetime : IHostLifetime, IDisposable
{
    // 注册 IHostApplicationLifetime.ApplicationStarted 回调后得到
    private CancellationTokenRegistration _applicationStartedRegistration;
    // 注册 IHostApplicationLifetime.ApplicationStopping 回调后得到
    private CancellationTokenRegistration _applicationStoppingRegistration;

    public ConsoleLifetime(
        IOptions<ConsoleLifetimeOptions> options, 
        IHostEnvironment environment, 
        IHostApplicationLifetime applicationLifetime, 
        IOptions<HostOptions> hostOptions)
            : this(options, environment, applicationLifetime, hostOptions, NullLoggerFactory.Instance) { }

    public ConsoleLifetime(
        IOptions<ConsoleLifetimeOptions> options, 
        IHostEnvironment environment, 
        IHostApplicationLifetime applicationLifetime, 
        IOptions<HostOptions> hostOptions, 
        ILoggerFactory loggerFactory)
    {
        ThrowHelper.ThrowIfNull(options?.Value, nameof(options));
        ThrowHelper.ThrowIfNull(applicationLifetime);
        ThrowHelper.ThrowIfNull(environment);
        ThrowHelper.ThrowIfNull(hostOptions?.Value, nameof(hostOptions));
        ThrowHelper.ThrowIfNull(loggerFactory);
 
        Options = options.Value
        Environment = environment;
        ApplicationLifetime = applicationLifetime;
        HostOptions = hostOptions.Value;
        // 创建日志类别为 "Microsoft.Hosting.Lifetime" 的 ILogger
        Logger = loggerFactory.CreateLogger("Microsoft.Hosting.Lifetime");
    }

    private ConsoleLifetimeOptions Options { get; }
 
    private IHostEnvironment Environment { get; }
 
    private IHostApplicationLifetime ApplicationLifetime { get; }
 
    private HostOptions HostOptions { get; }
 
    private ILogger Logger { get; }

    // 等待寄宿的应用启动完成
    // 本质是利用 IHostApplicationLifetime.ApplicationStarted 与 IHostApplicationLifetime.ApplicationStopping 注册回调
    public Task WaitForStartAsync(CancellationToken cancellationToken)
    {
        // 根据 ConsoleLifetimeOptions.SuppressStatusMessages 决定是否注册回调
        if (!Options.SuppressStatusMessages)
        {
            // 注册 IHostApplicationLifetime.ApplicationStarted 回调
            _applicationStartedRegistration = ApplicationLifetime.ApplicationStarted.Register(state =>
            {
                // 输出应用启动完成日志
                ((ConsoleLifetime)state!).OnApplicationStarted();
            },
            this);
            // 注册 IHostApplicationLifetime.ApplicationStopping 的回调
            _applicationStoppingRegistration = ApplicationLifetime.ApplicationStopping.Register(state =>
            {
                // 输出应用开始停止日志
                ((ConsoleLifetime)state!).OnApplicationStopping();
            },
            this);
        }

        // 注册对 "Ctrl + C" 快捷键的处理，用于停止宿主
        RegisterShutdownHandlers();
 
        return Task.CompletedTask;
    }

    // 注册对 "Ctrl + C" 快捷键处理
    private partial void RegisterShutdownHandlers();

    // 输出应用启动完成日志
    private void OnApplicationStarted()
    {
        Logger.LogInformation("Application started. Press Ctrl+C to shut down.");
        Logger.LogInformation("Hosting environment: {EnvName}", Environment.EnvironmentName);
        Logger.LogInformation("Content root path: {ContentRoot}", Environment.ContentRootPath);
    }

    // 输出应用开始停止日志
    private void OnApplicationStopping()
    {
        Logger.LogInformation("Application is shutting down...");
    }

    // 不支持 ConsoleLifetime 通过调用 IHostLifetime.StopAsync 方法停止宿主
    public Task StopAsync(CancellationToken cancellationToken)
    {
        return Task.CompletedTask;
    }

    // 取消回调的注册
    public void Dispose()
    {
        UnregisterShutdownHandlers();
 
        _applicationStartedRegistration.Dispose();
        _applicationStoppingRegistration.Dispose();
    }
 
    private partial void UnregisterShutdownHandlers();
}
```

- Microsoft.Extensions.Hosting.Host

```C#
// 静态 Host
public static class Host
{
    // 创建 IHostBuilder 并添加默认配置
    public static IHostBuilder CreateDefaultBuilder() =>
        CreateDefaultBuilder(args: null);

    // 创建 IHostBuilder 并添加默认配置并接收命令行参数
    public static IHostBuilder CreateDefaultBuilder(string[]? args)
    {
        HostBuilder builder = new();
        return builder.ConfigureDefaults(args);
    }
}
```

- IHost

```C#
/// <summary>
/// 宿主的抽象表示
/// </summary>
public interface IHost : IDisposable
{
    // 表示根容器的 IServiceProvider
    IServiceProvider Services { get; }

    // 启动宿主
    Task StartAsync(CancellationToken cancellationToken = default);

    // 停止宿主
    Task StopAsync(CancellationToken cancellationToken = default);
}
```

- Microsoft.Extensions.Hosting.Internal.Host

```C#
// IHost 的默认实现
internal sealed class Host : IHost, IAsyncDisposable
{
    // 日志类别为 "Microsoft.Extensions.Hosting.Internal.Host" 的 ILogger
    private readonly ILogger<Host> _logger;
    private readonly IHostLifetime _hostLifetime;
    private readonly ApplicationLifetime _applicationLifetime;
    // 宿主的配置选项
    private readonly HostOptions _options;
    private readonly IHostEnvironment _hostEnvironment;
    private readonly PhysicalFileProvider _defaultProvider;
    private IEnumerable<IHostedService>? _hostedServices;
    private IEnumerable<IHostedLifecycleService>? _hostedLifecycleServices;
    // 标记宿主启动开始
    private bool _hostStarting;
    // 标记宿主停止开始
    private volatile bool _stopCalled;
    // 标记宿主停止完成
    private bool _hostStopped;

    public Host(IServiceProvider services,
                IHostEnvironment hostEnvironment,
                PhysicalFileProvider defaultProvider,
                IHostApplicationLifetime applicationLifetime,
                ILogger<Host> logger,
                IHostLifetime hostLifetime,
                IOptions<HostOptions> options)
    {
        ThrowHelper.ThrowIfNull(services);
        ThrowHelper.ThrowIfNull(applicationLifetime);
        ThrowHelper.ThrowIfNull(logger);
        ThrowHelper.ThrowIfNull(hostLifetime);
 
        Services = services;
        _applicationLifetime = (applicationLifetime as ApplicationLifetime)!;
        _hostEnvironment = hostEnvironment;
        _defaultProvider = defaultProvider;
 
        if (_applicationLifetime is null)
        {
            throw new ArgumentException(SR.IHostApplicationLifetimeReplacementNotSupported, nameof(applicationLifetime));
        }
        _logger = logger;
        _hostLifetime = hostLifetime;
        _options = options?.Value ?? throw new ArgumentNullException(nameof(options));
    }

    // 代表根容器的 IServiceProvider
    public IServiceProvider Services { get; }

    // 启动宿主
    public async Task StartAsync(CancellationToken cancellationToken = default)
    {
        // 用来输出 Debug 日志级别的消息
        _logger.Starting();

        // 创建基于链接的 CancellationTokenSource
        using (var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, _applicationLifetime.ApplicationStopping))
        {
            // 根据 HostOptions.StartupTimeout 设置启动超时时间
            if (_options.StartupTimeout != Timeout.InfiniteTimeSpan)
                cts.CancelAfter(_options.StartupTimeout);

            cancellationToken = cts.Token;

            await _hostLifetime.WaitForStartAsync(cancellationToken).ConfigureAwait(false);
            cancellationToken.ThrowIfCancellationRequested();

            // 用于收集启动过程中的异常
            List<Exception> exceptions = new();
            // 得到所有注册的 IHostedService 服务
            _hostedServices ??= Services.GetRequiredService<IEnumerable<IHostedService>>();
            // 筛选出实现 IHostedLifecycleService 接口的所有服务
            _hostedLifecycleServices = GetHostLifecycles(_hostedServices);
            // 标记启动中
            _hostStarting = true;

            // 根据 HostOptions.ServicesStartConcurrently 决定服务是否并发启动
            bool concurrent = _options.ServicesStartConcurrently;
            // 如果不是并发启动服务则在遇到第一个服务启动发生错误时抛出异常
            bool abortOnFirstException = !concurrent;

            // 得到所有注册的 IStartupValidator 服务
            IStartupValidator? validator = Services.GetService<IStartupValidator>();
            if (validator is not null)
            {
                try
                {
                    // 启动验证
                    validator.Validate();
                }
                catch (Exception ex)
                {
                    exceptions.Add(ex);

                    LogAndRethrow();
                }
            }

            // 遍历并调用所有的 IHostedLifecycleService.StartingAsync 方法
            if (_hostedLifecycleServices is not null)
            {
                await ForeachService(_hostedLifecycleServices, cancellationToken, concurrent, abortOnFirstException, exceptions,
                    (service, token) => service.StartingAsync(token)).ConfigureAwait(false);

                LogAndRethrow();
            }

            // 遍历并调用所有的 IHostedService.StartAsync 方法
            await ForeachService(_hostedServices, cancellationToken, concurrent, abortOnFirstException, exceptions,
                async (service, token) =>
                {
                    await service.StartAsync(token).ConfigureAwait(false);
 
                    if (service is BackgroundService backgroundService)
                    {
                        // 执行继承 BackgroundService 类型的服务
                        _ = TryExecuteBackgroundServiceAsync(backgroundService);
                    }
                }).ConfigureAwait(false);

            // 遍历并调用所有的 IHostedLifecycleService.StartedAsync 方法
            if (_hostedLifecycleServices is not null)
            {
                await ForeachService(_hostedLifecycleServices, cancellationToken, concurrent, abortOnFirstException, exceptions,
                    (service, token) => service.StartedAsync(token)).ConfigureAwait(false);
            }

            LogAndRethrow();

            // 触发回调，输出应用启动完成日志
            _applicationLifetime.NotifyStarted();
        }

        // 用来输出 Debug 日志级别的消息
        _logger.Started();
    }

    // 停止宿主
    // 过程与启动宿主的过程类似
    public async Task StopAsync(CancellationToken cancellationToken = default)
    {
        // 标记停止开始
        _stopCalled = true;
        // 用来输出 Debug 日志级别的消息
        _logger.Stopping();
 
        CancellationTokenSource? cts = null;
        if (_options.ShutdownTimeout != Timeout.InfiniteTimeSpan)
        {
            cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(_options.ShutdownTimeout);
            cancellationToken = cts.Token;
        }
 
        using (cts)
        {
            List<Exception> exceptions = new();
            if (!_hostStarting)
            {
                // 不是启动中时，触发回调，输出应用停止开始日志
                _applicationLifetime.StopApplication();
            }
            else
            {
                Debug.Assert(_hostedServices != null, "Hosted services are resolved when host is started.");
 
                // 先进后出方式停止所有服务，即先启动的后停止
                IEnumerable<IHostedService> reversedServices = _hostedServices.Reverse();
                IEnumerable<IHostedLifecycleService>? reversedLifetimeServices = _hostedLifecycleServices?.Reverse();
                // 根据 HostOptions.ServicesStopConcurrently 的值设置所有服务是否并发停止
                bool concurrent = _options.ServicesStopConcurrently;
 
                // 遍历并调用所有的 IHostedLifecycleService.StoppingAsync 方法
                if (reversedLifetimeServices is not null)
                {
                    await ForeachService(reversedLifetimeServices, cancellationToken, concurrent, abortOnFirstException: false, exceptions,
                        (service, token) => service.StoppingAsync(token)).ConfigureAwait(false);
                }

                // 触发回调，输出应用开始停止日志
                _applicationLifetime.StopApplication();
 
                // 遍历并调用所有的 IHostedService.StopAsync 方法
                await ForeachService(reversedServices, cancellationToken, concurrent, abortOnFirstException: false, exceptions, (service, token) =>
                    service.StopAsync(token)).ConfigureAwait(false);
 
                // 遍历并调用所有的 IHostedLifecycleService.StoppedAsync 方法
                if (reversedLifetimeServices is not null)
                {
                    await ForeachService(reversedLifetimeServices, cancellationToken, concurrent, abortOnFirstException: false, exceptions, (service, token) =>
                        service.StoppedAsync(token)).ConfigureAwait(false);
                }
            }
 
            // 触发回调，输出应用停止完成日志
            _applicationLifetime.NotifyStopped();
        }

        // 用来输出 Debug 日志级别的消息
        _logger.Stopped();
    }

    // 执行 BackgroundService 类型的服务时需要等待实际的后台任务完成
    private async Task TryExecuteBackgroundServiceAsync(BackgroundService backgroundService)
    {
        Task? backgroundTask = backgroundService.ExecuteTask;
        if (backgroundTask is null)
        {
            return;
        }
 
        try
        {
            // 等待后台任务完成
            await backgroundTask.ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            if (_stopCalled && backgroundTask.IsCanceled && ex is OperationCanceledException)
            {
                return;
            }
 
            _logger.BackgroundServiceFaulted(ex);
            if (_options.BackgroundServiceExceptionBehavior == BackgroundServiceExceptionBehavior.StopHost)
            {
                _logger.BackgroundServiceStoppingHost(ex);
 
                _applicationLifetime.StopApplication();
            }    
        }
    }

    // 遍历 IHostedService 或 IHostedLifecycleService 服务，并通过指定的委托调用他们定义的某个以 Start 或 Stop 为前缀的方法
    private static async Task ForeachService<T>(
        IEnumerable<T> services,
        CancellationToken token,
        bool concurrent,
        bool abortOnFirstException,
        List<Exception> exceptions,
        Func<T, CancellationToken, Task> operation)
    {
        if (concurrent)
        {
            // 并发启动时用来收集所有代表任务启动的 Task
            List<Task>? tasks = null;
 
            foreach (T service in services)
            {
                Task task;
                try
                {
                    // 不等前一个服务启动完成就启动下一个服务
                    task = operation(service, token);
                }
                catch (Exception ex) // 捕获同步发生的异常
                {
                    exceptions.Add(ex);
                    continue;
                }
 
                // 任务同步完成
                if (task.IsCompleted) 
                {
                    if (task.Exception is not null)
                    {
                        // 收集异步发生的异常
                        // 保存在 AggregateException.InnerExceptions 中
                        exceptions.AddRange(task.Exception.InnerExceptions);
                    }
                }
                else
                {
                    tasks ??= new();
                    // 收集所有代表任务启动的 Task
                    tasks.Add(task);
                }
            }
 
            if (tasks is not null)
            {
                Task groupedTasks = Task.WhenAll(tasks);
 
                try
                {
                    // 等待所有代表任务启动的 Task 完成
                    await groupedTasks.ConfigureAwait(false);
                }
                catch (Exception ex)
                {
                    // 基于 async/await 的异步函数发生异常时，为了简化异常处理
                    // 会从 Task.Exception 这个 AggregateException 异常中取出 AggregateException.InnerExceptions 的第一个异常抛出
                    // 所以如果要得到所有的异常，则直接从 Task.Exception.InnerExceptions 中取出即可
                    if (groupedTasks.IsFaulted)
                    {
                        exceptions.AddRange(groupedTasks.Exception.InnerExceptions);
                    }
                    else
                    {
                        exceptions.Add(ex);
                    }
                }
            }
        }
        else
        {
            foreach (T service in services)
            {
                try
                {
                    // 等前一个服务启动完成后再启动下一个服务
                    await operation(service, token).ConfigureAwait(false);
                }
                catch (Exception ex)
                {
                    exceptions.Add(ex);
                    if (abortOnFirstException)
                    {
                        return;
                    }
                }
            }
        }
    }
}
```

- HostingAbstractionsHostExtensions

```C#
// 提供针对宿主启动停止的扩展方法
public static class HostingAbstractionsHostExtensions
{
    // 同步方式启动宿主
    // 阻塞主线程直到全部服务启动完成
    // 这个方法不适合那些需要长时间运行的服务，因为主线程在所有服务启动完成后就会结束阻塞
    public static void Start(this IHost host)
    {
        host.StartAsync().GetAwaiter().GetResult();
    }
 
    // 异步方式停止宿主
    // 支持通过指定停止等待超时时间，在所有服务停止完成前提前结束 StopAsync 方法
    public static async Task StopAsync(this IHost host, TimeSpan timeout)
    {
        using CancellationTokenSource cts = new CancellationTokenSource(timeout);
        await host.StopAsync(cts.Token).ConfigureAwait(false);
    }
    
    // 同步方式启动宿主
    // 这是为长时间运行的服务准备的启动方法
    // 阻塞主线程，直到调用 IHostApplicationLifetime.StopApplication 方法触发回调
    public static void Run(this IHost host)
    {
        host.RunAsync().GetAwaiter().GetResult();
    }
    
    // 异步方式启动宿主
    // 这是为长时间运行的服务准备的启动方法
    // 等待 WaitForShutdownAsync 方法，直到调用 IHostApplicationLifetime.StopApplication 方法触发回调
    public static async Task RunAsync(this IHost host, CancellationToken token = default)
    {
        try
        {
            await host.StartAsync(token).ConfigureAwait(false);

            // 同步 Run 方法的阻塞位置
            // 异步 RunAsync 方法的等待位置
            await host.WaitForShutdownAsync(token).ConfigureAwait(false);
        }
        finally
        {
            if (host is IAsyncDisposable asyncDisposable)
            {
                await asyncDisposable.DisposeAsync().ConfigureAwait(false);
            }
            else
            {
                host.Dispose();
            }
        }
    }

    // 同步等待停止宿主方法
    public static void WaitForShutdown(this IHost host)
    {
        host.WaitForShutdownAsync().GetAwaiter().GetResult();
    }
    
    // 异步等待停止宿主方法
    public static async Task WaitForShutdownAsync(this IHost host, CancellationToken token = default)
    {
        IHostApplicationLifetime applicationLifetime = host.Services.GetRequiredService<IHostApplicationLifetime>();
 
        // 注册回调，支持通过外部 CancellationTokenSource 结束等待停止宿主
        token.Register(state =>
        {
            ((IHostApplicationLifetime)state!).StopApplication();
        },
        applicationLifetime);
 
        var waitForStop = new TaskCompletionSource<object?>(TaskCreationOptions.RunContinuationsAsynchronously);
        // 注册回调，支持通过调用 IHostApplicationLifetime.StopApplication 结束等待
        applicationLifetime.ApplicationStopping.Register(obj =>
        {
            var tcs = (TaskCompletionSource<object?>)obj!;
            tcs.TrySetResult(null);
        }, waitForStop);
 
        // 实际等待位置
        await waitForStop.Task.ConfigureAwait(false);
 
        // 停止宿主
        await host.StopAsync(CancellationToken.None).ConfigureAwait(false);
    }
}
```
