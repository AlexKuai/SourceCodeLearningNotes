## 源码涉及的核心类型
- ServiceDescriptor  
- IServiceCollection  
- ServiceCollection  
- ServiceCollectionDescriptorExtensions  
- ServiceCollectionServiceExtensions  
- ServiceCollectionContainerBuilderExtensions  
- ServiceProviderOptions  
- IServiceProvider  
- ServiceProvider  
- DynamicServiceProviderEngine  
- IServiceScope  
- IServiceScopeFactory  
- ServiceProviderEngineScope  
- CallSiteFactory  
- ServiceDescriptorCacheItem  
- ServiceCacheKey  
- ResultCache  
- ServiceCallSite  
- CallSiteVisitor\<,\>  
- CallSiteRuntimeResolver  
- RuntimeResolverContext  
- RuntimeResolverLock  
- ServiceProviderServiceExtensions  
- IServiceProviderFactory\<\>  
- DefaultServiceProviderFactory  

## 服务注册

- ServiceDescriptor  
```C#
// 描述服务生命周期、服务注册类型、实现注册类型、实现工厂、实例
public class ServiceDescriptor
{
    // 生命周期
    public ServiceLifetime Lifetime { get; }
 
    // 服务注册类型
    // 注册的可能是开放泛型类型
    public Type ServiceType { get; }
 
    // 实现注册类型
    // 注册的可能是开放泛型类型
    public Type? ImplementationType { get; }

    // 实现工厂
    // 实际的实现工厂类型可能满足泛型委托的协变
    public Func<IServiceProvider, object>? ImplementationFactory { get; }

    // 实例
    public object? ImplementationInstance { get; }

    // 得到实现注册类型
    internal Type GetImplementationType()
    {
        if (ImplementationType != null)
        {
            // 实现注册类型
            return ImplementationType;
        }
        else if (ImplementationInstance != null)
        {
            // 实例类型
            return ImplementationInstance.GetType();
        }
        else if (ImplementationFactory != null)
        {
            Type[]? typeArguments = ImplementationFactory.GetType().GenericTypeArguments;
 
            Debug.Assert(typeArguments.Length == 2);

            // 实现工厂委托的第二个泛型参数类型（即返回值类型）作为实现类型
            return typeArguments[1];
        }
 
        Debug.Assert(false, "ImplementationType, ImplementationInstance or ImplementationFactory must be non null");
        return null;
    }

    // 针对不同生命周期的 ServiceDescriptor 创建方法，内部大部分最终都是调用 Describe 静态方法创建 ServiceDescriptor
    public static ServiceDescriptor Transient<...>(...);
    public static ServiceDescriptor Scoped<...>(...);
    public static ServiceDescriptor Singleton<...>(...);

    private static ServiceDescriptor Describe<TService, TImplementation>(ServiceLifetime lifetime)
        where TService : class
        where TImplementation : class, TService
    {
         return Describe(typeof(TService), typeof(TImplementation), lifetime: lifetime);
    }
 
    public static ServiceDescriptor Describe(Type serviceType, Type implementationType, ServiceLifetime lifetime)
    {
        return new ServiceDescriptor(serviceType, implementationType, lifetime);
    }
 
    public static ServiceDescriptor Describe(Type serviceType, Func<IServiceProvider, object> implementationFactory, ServiceLifetime lifetime)
    {
        return new ServiceDescriptor(serviceType, implementationFactory, lifetime);
    }
}
```

- IServiceCollection  
```C#
// 表示 ServiceDescriptor 集合
public interface IServiceCollection : IList<ServiceDescriptor>
{
}

// IServiceCollection 的默认实现
public class ServiceCollection : IServiceCollection
{
    private readonly List<ServiceDescriptor> _descriptors = new List<ServiceDescriptor>();
    private bool _isReadOnly;
 
    // 实现 ICollection<T>
    public int Count => _descriptors.Count;
 
    // 实现 ICollection<T>
    public bool IsReadOnly => _isReadOnly;
 
    // 实现 IList<T>
    public ServiceDescriptor this[int index]
    {
        get
        {
            return _descriptors[index];
        }
        set
        {
            CheckReadOnly();
            _descriptors[index] = value;
        }
    }

    // 实现 IList<T>
    public int IndexOf(ServiceDescriptor item)
    {
        return _descriptors.IndexOf(item);
    }
    
    // 实现 IList<T>
    public void Insert(int index, ServiceDescriptor item)
    {
        CheckReadOnly();
        _descriptors.Insert(index, item);
    }
    
    // 实现 IList<T>
    public void RemoveAt(int index)
    {
        CheckReadOnly();
        _descriptors.RemoveAt(index);
    }

    // 实现 ICollection<T>
    void ICollection<ServiceDescriptor>.Add(ServiceDescriptor item)
    {
        CheckReadOnly();
        _descriptors.Add(item);
    }
    
    // 实现 ICollection<T>
    public void Clear()
    {
        CheckReadOnly();
        _descriptors.Clear();
    }
    
    // 实现 ICollection<T>
    public bool Contains(ServiceDescriptor item)
    {
        return _descriptors.Contains(item);
    }
 
    // 实现 ICollection<T>
    public void CopyTo(ServiceDescriptor[] array, int arrayIndex)
    {
        _descriptors.CopyTo(array, arrayIndex);
    }
 
    // 实现 ICollection<T>
    public bool Remove(ServiceDescriptor item)
    {
        CheckReadOnly();
        return _descriptors.Remove(item);
    }
    
    // 实现 IEnumerable<T>
    public IEnumerator<ServiceDescriptor> GetEnumerator()
    {
        return _descriptors.GetEnumerator();
    }
    
    // 显示实现 IEnumerable
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
 
    // 设置为只读
    public void MakeReadOnly()
    {
        _isReadOnly = true;
    }
    
    // 检查是否已设置为只读
    // 如果设置为只读，所有对字段 _descriptors 引用的集合的修改都会抛出 InvalidOperationException
    private void CheckReadOnly()
    {
        if (_isReadOnly)
        {
            throw new InvalidOperationException(SR.ServiceCollectionReadOnly);
        }
    }
}
```

- ServiceCollectionDescriptorExtensions  
```C#
// 通过服务描述注册服务的扩展方法
// 内部最终调用 ICollection<T>.Add 方法添加 ServiceDescriptor
public static class ServiceCollectionDescriptorExtensions
{
    public static IServiceCollection Add(this IServiceCollection collection, ...);
    public static void TryAdd(this IServiceCollection collection, ...)
    {
        int count = collection.Count;
        for (int i = 0; i < count; i++)
        {
            // 如果已经存在服务注册类型的 ServiceDescriptor，则忽略
            if (collection[i].ServiceType == descriptor.ServiceType)
            {
                return;
            }
        }
    }

    public static void TryAddTransient(this IServiceCollection collection, ...);
    public static void TryAddScoped(this IServiceCollection collection, ...);
    public static void TryAddSingleton(this IServiceCollection collection, ...);

    public static void TryAddEnumerable(this IServiceCollection services, ...)
    {
        // 得到实现注册类型
        Type? implementationType = descriptor.GetImplementationType();
 
        // 实现注册类型是 object 类型或者服务注册类型和实现注册类型相同，则抛出 ArgumentException
        // 1. new ServiceCollection().TryAddEnumerable(ServiceDescriptor.Singleton<IFoo>(_ => new Foo()));
        //    这种方式最终编译器生成的 IL 指令会创建 Func<IServiceProvider, IFoo> 类型的委托
        //    服务注册类型和实现注册类型相同，则抛出 ArgumentException
        // 2. Func<IServiceProvider, Foo> func = _ => new Foo();
        //    new ServiceCollection().TryAddEnumerable(ServiceDescriptor.Singleton<IFoo>(func));
        //    这种方式通过创建 Func<IServiceProvider, Foo> 类型的委托并利用了泛型委托的协变
        //    服务注册类型和实现注册类型不相同，运行正常
        if (implementationType == typeof(object) || implementationType == descriptor.ServiceType)
        {
            throw new ArgumentException(
                SR.Format(SR.TryAddIndistinguishableTypeToEnumerable,
                    implementationType,
                    descriptor.ServiceType),
                nameof(descriptor));
        }
 
        int count = services.Count;
        for (int i = 0; i < count; i++)
        {
            ServiceDescriptor service = services[i];
            // 如果已经存在服务注册类型和实现注册类型的 ServiceDescriptor，则忽略
            if (service.ServiceType == descriptor.ServiceType && service.GetImplementationType() == implementationType)
            {
                return;
            }
        }
    }

    public static IServiceCollection Replace(this IServiceCollection collection, ServiceDescriptor descriptor)
    {
        int count = collection.Count;
        for (int i = 0; i < count; i++)
        {
            // 服务注册类型存在，则删除
            if (collection[i].ServiceType == descriptor.ServiceType)
            {
                collection.RemoveAt(i);
                break;
            }
        }

        // 最终通过末尾添加新的 ServiceDescriptor
        collection.Add(descriptor);

        ...
    }

    public static IServiceCollection RemoveAll<T>(this IServiceCollection collection);
    public static IServiceCollection RemoveAll(this IServiceCollection collection, Type ServiceType)
    {
        for (int i = collection.Count - 1; i >= 0; i--)
        {
            ServiceDescriptor? descriptor = collection[i];
            // 根据服务注册类型删除所有 ServiceDescriptor
            if (descriptor.ServiceType == serviceType)
            {
                collection.RemoveAt(i);
            }
        }

        ...
    }
}
```

- ServiceCollectionServiceExtensions  
```C#
// 通过服务注册类型、实现注册类型、实现工厂、实例等参数注册服务的扩展方法
// 内部最终调用 ICollection<T>.Add 方法添加 ServiceDescriptor
public static class ServiceCollectionServiceExtensions
{
    // 内部大部分最终调用 Add 扩展方法
    // 泛型方法需要满足 where TImplementation : class, TService 泛型约束
    public static IServiceCollection AddTransient<...>(this IServiceCollection services, ...);
    public static IServiceCollection AddScoped<...>(this IServiceCollection services, ...);
    public static IServiceCollection AddSingleton<...>(this IServiceCollection services, ...);

    private static IServiceCollection Add(
        IServiceCollection collection, 
        Type serviceType, 
        Type implementationType, 
        ServiceLifetime lifetime)
    {
        var descriptor = new ServiceDescriptor(serviceType, implementationType, lifetime);
        collection.Add(descriptor);
        return collection;
    }
 
    private static IServiceCollection Add(
        IServiceCollection collection,
        Type serviceType,
        Func<IServiceProvider, object> implementationFactory,
        ServiceLifetime lifetime)
    {
        var descriptor = new ServiceDescriptor(serviceType, implementationFactory, lifetime);
        collection.Add(descriptor);
        return collection;
    }
}
```

## 服务消费

- ServiceCollectionContainerBuilderExtensions  
```C#
// 使用 IServiceCollection 构建默认 ServiceProvider 的扩展方法
public static class ServiceCollectionContainerBuilderExtensions
{
    public static ServiceProvider BuildServiceProvider(this IServiceCollection services)
    {
        return BuildServiceProvider(services, ServiceProviderOptions.Default);
    }

    public static ServiceProvider BuildServiceProvider(this IServiceCollection services, bool validateScopes)
    {
        return services.BuildServiceProvider(new ServiceProviderOptions { ValidateScopes = validateScopes });
    }

    public static ServiceProvider BuildServiceProvider(this IServiceCollection services, ServiceProviderOptions options)
    {
        if (services is null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        if (options is null)
        {
            throw new ArgumentNullException(nameof(options));
        }
 
        return new ServiceProvider(services, options);
    }
}
```

- ServiceProviderOptions  
```C#
// 配置默认 ServiceProvider 的行为选项
public class ServiceProviderOptions
{
    // 默认行为，不验证服务范围并且所有服务是否可以被解析不在 ServiceProvider 构造函数执行时验证
    internal static readonly ServiceProviderOptions Default = new ServiceProviderOptions();

    // 验证服务范围
    // Singleton 生命周期的服务不能依赖 Scoped 周期的服务（即根容器不能解析 Scoped 生命周期的服务）
    public bool ValidateScopes { get; set; }

    // 在 ServiceProvider 构造函数执行时验证所有服务是否可以被解析
    public bool ValidateOnBuild { get; set; }
}
```

- IServiceProvider  
```C#
// 服务容器的抽象表示
public interface IServiceProvider
{
    object? GetService(Type serviceType);
}
```

- ServiceProvider  
```C#
// IServiceProvider 的默认实现
public sealed class ServiceProvider : IServiceProvider, IDisposable, IAsyncDisposable
{
    // 服务验证器
    // 继承 CallSiteVisitor<TArgument, TResult>
    // 用来验证是否存在通过根容器解析 Scoped 生命周期的服务
    private readonly CallSiteValidator? _callSiteValidator;

    // 服务解析引擎
    // 核心方法 RealizeService 的作用是根据 ServiceCallSite 得到 Func<ServiceProviderEngineScope, object?>> 委托
    // 实现类型：
    // 1. CompiledServiceProviderEngine
    //      DynamicServiceProviderEngine
    // 2. ExpressionsServiceProviderEngine
    // 3. ILEmitServiceProviderEngine
    // 4. RuntimeServiceProviderEngine
    internal ServiceProviderEngine _engine;

    // 如果 _realizedServices 没有对应服务类型的 Func<ServiceProviderEngineScope, object?>> 委托就通过 _createServiceAccessor 创建
    private readonly Func<Type, Func<ServiceProviderEngineScope, object?>> _createServiceAccessor;
    // 用来缓存服务类型和其对应的 Func<ServiceProviderEngineScope, object?> 委托
    // 当缓存中没有对应的服务类型的键时，将通过 _createServiceAccessor 创建 Func<ServiceProviderEngineScope, object?> 委托
    // 服务实例的解析最终利用服务类型对应的 Func<ServiceProviderEngineScope, object?> 委托来完成的
    private ConcurrentDictionary<Type, Func<ServiceProviderEngineScope, object?>> _realizedServices;

    // ServiceCallSite 工厂
    internal CallSiteFactory CallSiteFactory { get; }

    // 根容器（服务范围）
    internal ServiceProviderEngineScope Root { get; }

    internal ServiceProvider(ICollection<ServiceDescriptor> serviceDescriptors, ServiceProviderOptions options)
    {
        // 创建根容器
        Root = new ServiceProviderEngineScope(this, isRootScope: true);

        // 根据运行时情况决定服务解析引擎的实现类型
        _engine = GetEngine();

        // 使用 CreateServiceAccessor 方法创建 Func<Type, Func<ServiceProviderEngineScope, object?>> 委托
        _createServiceAccessor = CreateServiceAccessor;
        _realizedServices = new ConcurrentDictionary<Type, Func<ServiceProviderEngineScope, object?>>();

        // 使用注册的 ServiceDescriptor 集合创建 ServiceCallSite 工厂
        CallSiteFactory = new CallSiteFactory(serviceDescriptors);

        // 添加三个特殊服务类型的 ServiceCallSite
        // 针对 IServiceProvider 的 ServiceCallSite
        // 根据解析服务类型时对应的 ServiceProviderEngineScope 决定
        CallSiteFactory.Add(typeof(IServiceProvider), new ServiceProviderCallSite());
        // 使用根容器自己作为服务解析实例提供
        CallSiteFactory.Add(typeof(IServiceScopeFactory), new ConstantCallSite(typeof(IServiceScopeFactory), Root));
        CallSiteFactory.Add(typeof(IServiceProviderIsService), new ConstantCallSite(typeof(IServiceProviderIsService), CallSiteFactory));

        // 判断是否启用服务范围验证
        if (options.ValidateScopes)
        {
            // 创建服务范围验证器
            _callSiteValidator = new CallSiteValidator();
        }

        // 判断是否立即验证所有服务可以被解析
        if (options.ValidateOnBuild)
        {
            foreach (ServiceDescriptor serviceDescriptor in serviceDescriptors)
            {
                try
                {
                    ValidateService(serviceDescriptor);
                }
                catch (Exception e)
                {
                    exceptions ??= new List<Exception>();
                    exceptions.Add(e);
                }
            }
        }

        ...
    }

    // 验证服务是否可以被解析
    // 在调用 GetService 方法得到服务时，会先通过调用 GetCallSite 方法得到 ServiceCallSite，如果存在依赖的服务类型未被注册，则抛出异常
    // 启用 ValidateOnBuild 的本质就是遍历收集的所有 ServiceDescriptor，使用 ServiceType 作为服务类型调用 GetCallSite 方法
    // 检测在得到 ServiceCallSite 的过程中是否存在异常
    private void ValidateService(ServiceDescriptor descriptor)
    {
        // 由于服务注册类型有可能是开放泛型类型，不能直接作为服务类型解析服务
        // 所以如果服务注册类型是泛型类型并且泛型类型未被构建（开放泛型类型），则忽略验证
        if (descriptor.ServiceType.IsGenericType && !descriptor.ServiceType.IsConstructedGenericType)
        {
            return;
        }

        try
        {
            // 根据服务描述得到对应的 ServiceCallSite
            // 创建 ConstructorCallSite 时需要填充 CallSiteChain 中的 CallSiteChain._callSiteChain 字典（可能存在参数）
            // 在根据构造函数参数类型得到对应的 ServiceCallSite 时用来判断是否存在循环依赖
            // 在得到 ServiceCallSite 的过程中如果存在 CallSiteFactory._descriptorLookup 服务注册类型查找表中不存在的服务注册类型，则抛出异常
            // 个人理解依赖注入框架不需要也不应该解决循环依赖问题，反面教材就是 Spring 利用三级缓存处理循环依赖（新版本已经默认不启用）
            ServiceCallSite? callSite = CallSiteFactory.GetCallSite(descriptor, new CallSiteChain());
            if (callSite != null)
            {
                // 验证服务范围
                // 如果存在 Singleton 生命周期的服务依赖 Scoped 生命周期的服务，则抛出 InvalidOperationException
                _callSiteValidator?.ValidateCallSite(callSite);
            }
        }
        catch (Exception e)
        {
            throw new InvalidOperationException($"Error while validating the service descriptor '{descriptor}': {e.Message}", e);
        }
    }

    // 实现 IServiceProvider
    // 根据服务类型得到实例
    public object? GetService(Type serviceType) => GetService(serviceType, Root);

    // 内部实际解析服务的方法
    internal object? GetService(Type serviceType, ServiceProviderEngineScope serviceProviderEngineScope)
    {
        // 创建对应服务的 Func<ServiceProviderEngineScope, object?> 委托
        Func<ServiceProviderEngineScope, object?> realizedService = _realizedServices.GetOrAdd(serviceType, _createServiceAccessor);
        // 如果通过根容器得到服务（serviceProviderEngineScope == Root），则验证服务范围
        // 用来验证是否存在通过根容器解析 Scoped 生命周期的服务
        _callSiteValidator?.ValidateResolution(serviceType, serviceProviderEngineScope, Root);
        // 使用 Func<ServiceProviderEngineScope, object?> 委托和 serviceProviderEngineScope 解析服务
        var result = realizedService.Invoke(serviceProviderEngineScope);
        return result;
    }

    private Func<ServiceProviderEngineScope, object?> CreateServiceAccessor(Type serviceType)
    {
        // 根据服务类型得到对应的 ServiceCallSite
        // 创建 ConstructorCallSite 时需要填充 CallSiteChain 中的 CallSiteChain._callSiteChain 字典
        // 在根据构造函数参数类型得到对应的 ServiceCallSite 时用来判断是否存在循环依赖
        // 在得到 ServiceCallSite 的过程中如果存在 CallSiteFactory._descriptorLookup 服务注册类型查找表中不存在的服务注册类型，则抛出异常
        ServiceCallSite? callSite = CallSiteFactory.GetCallSite(serviceType, new CallSiteChain());
        if (callSite != null)
        {
            // 验证服务范围
            _callSiteValidator?.ValidateCallSite(callSite);

            // 如果服务缓存位置是根容器
            if (callSite.Cache.Location == CallSiteResultCacheLocation.Root)
            {
                // 使用 CallSiteRuntimeResolver 直接解析服务
                object? value = CallSiteRuntimeResolver.Instance.Resolve(callSite, Root);
                // 下次解析对应的服务时直接返回（为注册为 Singleton 生命周期的服务提供解析优化，提高性能）
                return scope => value;
            }

            // 使用解析引擎得到 Func<ServiceProviderEngineScope, object?> 委托
            return _engine.RealizeService(callSite);
        }

        return _ => null;
    }

    private ServiceProviderEngine GetEngine()
    {
        ServiceProviderEngine engine;

#if NETFRAMEWORK || NETSTANDARD2_0
            // 动态决定解析服务方式
            engine = new DynamicServiceProviderEngine(this);
#else
        if (RuntimeFeature.IsDynamicCodeCompiled)
        {
            engine = new DynamicServiceProviderEngine(this);
        }
        else
        {
            // 反射方式解析服务
            engine = RuntimeServiceProviderEngine.Instance;
        }
#endif
        return engine;
    }
}
```

- DynamicServiceProviderEngine  
```C#
// 动态服务解析引擎
// 根据服务解析的次数决定是否从反射方式得到服务替换为性能更高的 ILEmit 方式得到服务
internal sealed class DynamicServiceProviderEngine : CompiledServiceProviderEngine
{
    private readonly ServiceProvider _serviceProvider;
 
    public DynamicServiceProviderEngine(ServiceProvider serviceProvider): base(serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
 
    public override Func<ServiceProviderEngineScope, object?> RealizeService(ServiceCallSite callSite)
    {
        return scope =>
        {
            var result = CallSiteRuntimeResolver.Instance.Resolve(callSite, scope);
            
            // 如果对某个服务类型的 ServiceCallSite 有多于一次的解析，则通过异步方式替换使用 ILEmit 方式解析服务
            if (Interlocked.Increment(ref callCount) == 2)
            {
                _ = ThreadPool.UnsafeQueueUserWorkItem(_ =>
                {
                    try
                    {
                        // 将 CallSiteRuntimeResolver 替换为 ILEmitResolverBuilder
                        // 它们都继承 CallSiteVisitor<TArgument, TResult>
                        _serviceProvider.ReplaceServiceAccessor(callSite, base.RealizeService(callSite));
                    }
                    catch (Exception ex)
                    {
                        DependencyInjectionEventSource.Log.ServiceRealizationFailed(ex, _serviceProvider.GetHashCode());
 
                        Debug.Fail($"We should never get exceptions from the background compilation.{Environment.NewLine}{ex}");
                    }
                },
                null);
            }
 
            return result;
        };
    }
}
```

- IServiceScope  
```C#
// 服务范围的抽象表示
public interface IServiceScope
{
    IServiceProvider ServiceProvider { get; }
}
```

- IServiceScopeFactory  
```C#
// 服务范围工厂的抽象表示
public interface IServiceScopeFactory
{
    IServiceScope CreateScope();
}
```

- ServiceProviderEngineScope  
```C#
// 集服务容器、服务范围、服务范围工厂三种角色于一体
// 扮演服务范围工厂时，通过 CreateScope 方式创建新的服务范围（服务容器）
// 每个 ServiceProviderEngineScope 直接引用在逻辑上扮演根容器的 ServiceProvider 而不是调用 CreateScope 方法的 ServiceProviderEngineScope
// 即 ServiceProviderEngineScope 之间不存在树形依赖结构
internal sealed class ServiceProviderEngineScope : IServiceScope, IServiceProvider, IAsyncDisposable, IServiceScopeFactory
{
    // 是否已经执行 DisposeAsync 或 Dispose 方法
    private bool _disposed;
    // 由当前容器解析的，并且实现了 IDisposable 或 IAsyncDisposable 接口的服务，则会保存在此集合中
    private List<object>? _disposables;

    public ServiceProviderEngineScope(ServiceProvider provider, bool isRootScope)
    {
        ResolvedServices = new Dictionary<ServiceCacheKey, object?>();
        RootProvider = provider;
        IsRootScope = isRootScope;
    }

    // 由当前容器（服务范围）解析的，并且为 Scoped 生命周期的服务，则保存在此字典中
    // 如果是 ServiceProvider 内部引用的 ServiceProviderEngineScope 根容器（服务范围）
    // 则解析的服务实际保存在每个 ServiceCallSite 的 Value 属性中，而不会使用此字典
    internal Dictionary<ServiceCacheKey, object?> ResolvedServices { get; }

    // 同步锁（在并发情况下对 ResolvedServices 的同步访问）
    internal object Sync => ResolvedServices;
    
    // 是否是根容器（服务范围）
    public bool IsRootScope { get; }
    
    // 引用默认的根容器 ServiceProvider
    internal ServiceProvider RootProvider { get; }

    // 通过服务类型得到服务实例
    public object? GetService(Type serviceType)
    {
        if (_disposed)
        {
            ThrowHelper.ThrowObjectDisposedException();
        }

        // 实际的服务解析交由 ServiceProvider 执行
        return RootProvider.GetService(serviceType, this);
    }
    
    // 扮演服务容器
    public IServiceProvider ServiceProvider => this;
    
    // 扮演服务范围工厂
    public IServiceScope CreateScope() => RootProvider.CreateScope();

    // 捕获解析的服务是否需要放入 _disposed 集合
    internal object? CaptureDisposable(object? service)
    {
        ...
    }

    // 支持异步方式执行释放操作
    // 实现 IAsyncDisposable 接口的服务
    // 如果执行 DisposeAsync 方法非同步完成，则通过异步方式执行
    public ValueTask DisposeAsync()
    {
        try
        {
            for (int i = toDispose.Count - 1; i >= 0; i--)
            {
                object disposable = toDispose[i];
                if (disposable is IAsyncDisposable asyncDisposable)
                {
                    ValueTask vt = asyncDisposable.DisposeAsync();
                    // 非同步完成
                    if (!vt.IsCompletedSuccessfully)
                    {
                        // 剩余的服务使用异步方式执行释放
                        return Await(i, vt, toDispose);
                    }

                    // 同步完成，继续循环
                    vt.GetAwaiter().GetResult();
                }
                else
                {
                    ((IDisposable)disposable).Dispose();
                }
            }
        }
        catch (Exception ex)
        {
            return new ValueTask(Task.FromException(ex));
        }

        return default;

        // 剩余的服务通过异步方式执行释放
        static async ValueTask Await(int i, ValueTask vt, List<object> toDispose)
        {
            // 等待第一个非同步完成的释放操作
            await vt.ConfigureAwait(false);
            i--;

            for (; i >= 0; i--)
            {
                object disposable = toDispose[i];
                if (disposable is IAsyncDisposable asyncDisposable)
                {
                    await asyncDisposable.DisposeAsync().ConfigureAwait(false);
                }
                else
                {
                    ((IDisposable)disposable).Dispose();
                }
            }
        }
    }
}
```

- CallSiteFactory  
```C#
// 用来创建对应服务的 ServiceCallSite 工厂
internal sealed class CallSiteFactory : IServiceProviderIsService
{
    // 默认槽位
    private const int DefaultSlot = 0;
    // 服务描述
    private readonly ServiceDescriptor[] _descriptors;
    // ServiceCallSite 缓存表
    // ServiceCacheKey 的唯一性由内部的服务类型和槽位决定
    private readonly ConcurrentDictionary<ServiceCacheKey, ServiceCallSite> _callSiteCache 
        = new ConcurrentDictionary<ServiceCacheKey, ServiceCallSite>();
    // 服务注册类型查找表
    private readonly Dictionary<Type, ServiceDescriptorCacheItem> _descriptorLookup = new Dictionary<Type, ServiceDescriptorCacheItem>();
    // 针对不同服务类型创建 ServiceCallSite 时的同步锁
    private readonly ConcurrentDictionary<Type, object> _callSiteLocks = new ConcurrentDictionary<Type, object>();

    public CallSiteFactory(ICollection<ServiceDescriptor> descriptors)
    {
        // 拷贝服务描述
        _descriptors = new ServiceDescriptor[descriptors.Count];
        descriptors.CopyTo(_descriptors, 0);

        // 遍历 ServiceDescriptor 集合，构建服务注册类型查找表
        Populate();
    }

    // 构建服务注册类型查找表
    private void Populate()
    {
        foreach (ServiceDescriptor descriptor in _descriptors)
        {
            Type serviceType = descriptor.ServiceType;
            // 如果服务注册类型是开放泛型类型（未被构建的）
            if (serviceType.IsGenericTypeDefinition)
            {
                Type? implementationType = descriptor.ImplementationType;

                // 服务注册类型是开放泛型类型时实现注册类型也必须是开放泛型类型，否则抛出 ArgumentException
                // 因为需要通过得到实现注册类型的 ConstructorCallSite 来解析实例
                if (implementationType == null || !implementationType.IsGenericTypeDefinition)
                {
                    throw new ArgumentException(
                        SR.Format(SR.OpenGenericServiceRequiresOpenGenericImplementation, serviceType),
                        "descriptors");
                }

                // 所以实现注册类型不能是抽象类型或接口等开放类型（无法实例化），否则抛出 ArgumentException
                if (implementationType.IsAbstract || implementationType.IsInterface)
                {
                    throw new ArgumentException(
                        SR.Format(SR.TypeCannotBeActivated, implementationType, serviceType));
                }

                Type[] serviceTypeGenericArguments = serviceType.GetGenericArguments();
                Type[] implementationTypeGenericArguments = implementationType.GetGenericArguments();
                // 泛型参数的数量必须一致，否则抛出 ArgumentException
                if (serviceTypeGenericArguments.Length != implementationTypeGenericArguments.Length)
                {
                    throw new ArgumentException(
                        SR.Format(SR.ArityOfOpenGenericServiceNotEqualArityOfOpenGenericImplementation, serviceType, implementationType), "descriptors");
                }
            }
            else if (descriptor.ImplementationInstance == null && descriptor.ImplementationFactory == null)
            {
                // 服务注册类型是封闭类型并且实现实例和实现工厂为 null 时必须具有实现注册类型
                Debug.Assert(descriptor.ImplementationType != null);
                Type implementationType = descriptor.ImplementationType;

                // 实现注册类型不能是开放泛型类型、抽象类型、接口这些开放类型，否则抛出 ArgumentException
                if (implementationType.IsGenericTypeDefinition ||
                    implementationType.IsAbstract ||
                    implementationType.IsInterface)
                {
                    throw new ArgumentException(
                        SR.Format(SR.TypeCannotBeActivated, implementationType, serviceType));
                }
            }

            // 相同服务注册类型的多个 ServiceDescriptor 会被封装为 ServiceDescriptorCacheItem
            // 并且具有如下引用逻辑
            // 1. ServiceDescriptorCacheItem.Last 指向最后添加的服务注册类型
            // 2. ServiceDescriptorCacheItem._item 指向最早添加的服务注册类型
            // 3. ServiceDescriptorCacheItem._items 保存除 ServiceDescriptorCacheItem._item 以外的注册链
            Type cacheKey = serviceType;
            _descriptorLookup.TryGetValue(cacheKey, out ServiceDescriptorCacheItem cacheItem);
            _descriptorLookup[cacheKey] = cacheItem.Add(descriptor);
        }
    }

    // 根据服务类型和默认槽 0（基于最后注册的 ServiceDescriptor）得到 ServiceCallSite
    internal ServiceCallSite? GetCallSite(Type serviceType, CallSiteChain callSiteChain) =>
        _callSiteCache.TryGetValue(new ServiceCacheKey(serviceType, DefaultSlot), out ServiceCallSite? site) ? site :
        CreateCallSite(serviceType, callSiteChain);
    
    // 根据 ServiceDescriptor 的服务注册类型得到 ServiceCallSite
    // 不支持 ServiceDescriptor 的服务注册类型是开放泛型类型
    // 所以调用此方法前需要判断 ServiceDescriptor 的服务注册类型是否为开放泛型类型
    internal ServiceCallSite? GetCallSite(ServiceDescriptor serviceDescriptor, CallSiteChain callSiteChain)
    {
        if (_descriptorLookup.TryGetValue(serviceDescriptor.ServiceType, out ServiceDescriptorCacheItem descriptor))
        {
            // 由于使用的是 ServiceDescriptor 中的服务注册类型作为服务类型尝试解析得到 ServiceCallSite
            // 所以只支持针对封闭类型的 TryCreateExact 方法
            // 因为服务类型是开放类型时无法得到 ServiceCallSite
            return TryCreateExact(serviceDescriptor, serviceDescriptor.ServiceType, callSiteChain, descriptor.GetSlot(serviceDescriptor));
        }
 
        Debug.Fail("_descriptorLookup didn't contain requested serviceDescriptor");
        return null;
    }

    private ServiceCallSite? CreateCallSite(Type serviceType, CallSiteChain callSiteChain)
    {
        if (!_stackGuard.TryEnterOnCurrentStack())
        {
            return _stackGuard.RunOnEmptyStack(CreateCallSite, serviceType, callSiteChain);
        }

        // 针对每个服务类型得到同步锁
        var callsiteLock = _callSiteLocks.GetOrAdd(serviceType, static _ => new object());

        // 由于需要更新 _callSiteCache，所以针对每个服务类型得到 ServiceCallSite 过程需要同步完成
        // 比如如下的服务依赖关系 C、E 依赖 D、A：
        // C -> D -> A
        // E -> D -> A
        // 在并发创建服务 C、E 对应的 ServiceCallSite 的过程中需要保证他们依赖的服务 D、A 所对应的 ServiceCallSite 是同一个实例
        lock (callsiteLock)
        {
            // 检查循环依赖
            callSiteChain.CheckCircularDependency(serviceType);

            // 通过服务类型得到 ServiceCallSite 通过三种方式
            // 1. 针对封闭类型的 TryCreateExact
            // 2. 针对开放泛型类型的 TryCreateOpenGeneric
            // 3. 针对 IEnumerable<> 类型的 TryCreateEnumerable
            ServiceCallSite? callSite = TryCreateExact(serviceType, callSiteChain) ??
                                    TryCreateOpenGeneric(serviceType, callSiteChain) ??
                                    TryCreateEnumerable(serviceType, callSiteChain);

            return callSite;
        }
    }

    // 针对封闭类型创建 ServiceCallSite
    private ServiceCallSite? TryCreateExact(Type serviceType, CallSiteChain callSiteChain)
    {
        // 根据服务注册类型查找表得到 ServiceDescriptor
        if (_descriptorLookup.TryGetValue(serviceType, out ServiceDescriptorCacheItem descriptor))
        {
            // 尝试使用最后注册的 ServiceDescriptor 和默认默认槽 0 创建 ServiceCallSite
            return TryCreateExact(descriptor.Last, serviceType, callSiteChain, DefaultSlot);
        }
 
        return null;
    }

    private ServiceCallSite? TryCreateExact(ServiceDescriptor descriptor, Type serviceType, CallSiteChain callSiteChain, int slot)
    {
        // 封闭类型的服务注册类型和服务类型必须相同
        if (serviceType == descriptor.ServiceType)
        {
            // 利用服务类型和指定槽位创建 ServiceCacheKey
            ServiceCacheKey callSiteKey = new ServiceCacheKey(serviceType, slot);
            // 已经存在直接返回
            if (_callSiteCache.TryGetValue(callSiteKey, out ServiceCallSite? serviceCallSite))
            {
                return serviceCallSite;
            }

            ServiceCallSite callSite;
            // 创建结果缓存
            // 用来指明利用 ServiceCallSite 解析服务后的实例保存位置
            var lifetime = new ResultCache(descriptor.Lifetime, serviceType, slot);
            if (descriptor.ImplementationInstance != null)
            {
                // 根据实现实例得到 ConstantCallSite
                // 创建 ConstantCallSite 不需要使用 ResultCache 指明实例保存位置
                // 因为已经将 ServiceDescriptor.ImplementationInstance 的值保存到 ServiceCallSite.Value 中
                callSite = new ConstantCallSite(descriptor.ServiceType, descriptor.ImplementationInstance);
            }
            else if (descriptor.ImplementationFactory != null)
            {
                // 根据实现工厂得到 FactoryCallSite
                callSite = new FactoryCallSite(lifetime, descriptor.ServiceType, descriptor.ImplementationFactory);
            }
            else if (descriptor.ImplementationType != null)
            {
                // 根据实现类型创建 ConstructorCallSite
                // 创建 ConstructorCallSite 时需要使用 callSiteChain 来检测是否存在循环依赖
                // 因为使用 ConstructorCallSite 解析服务时可能存在针对构造函数参数类型的服务解析
                // 在这一过程中可能发生循环依赖造成反复创建相同服务类型的 ServiceCallSite
                callSite = CreateConstructorCallSite(lifetime, descriptor.ServiceType, descriptor.ImplementationType, callSiteChain);
            }
            else
            {
                throw new InvalidOperationException(SR.InvalidServiceDescriptor);
            }

            // 根据 ServiceCacheKey 缓存 ServiceCallSite
            return _callSiteCache[callSiteKey] = callSite;
        }

        return null;
    }

    // 创建 ConstructorCallSite
    private ServiceCallSite CreateConstructorCallSite(
            ResultCache lifetime,
            Type serviceType,
            Type implementationType,
            CallSiteChain callSiteChain)
    {
        try
        {
            // 首先往 callSiteChain 添加服务类型和实现类型
            callSiteChain.Add(serviceType, implementationType);
            // 得到实现类型为 public 的实例构造函数的定义元数据（BindingFlags.Public | BindingFlags.Instance）
            ConstructorInfo[] constructors = implementationType.GetConstructors();

            ServiceCallSite[]? parameterCallSites = null;

            // 没有候选构造函数，则抛出 InvalidOperationException
            if (constructors.Length == 0)
            {
                throw new InvalidOperationException(SR.Format(SR.NoConstructorMatch, implementationType));
            }
            else if (constructors.Length == 1)
            {
                // 唯一的候选构造函数
                ConstructorInfo constructor = constructors[0];
                // 得到构造函数参数的定义元数据
                ParameterInfo[] parameters = constructor.GetParameters();
                if (parameters.Length == 0)
                {
                    // 没有参数
                    // 即存在默认构造函数
                    return new ConstructorCallSite(lifetime, serviceType, constructor);
                }

                // 候选构造函数存在参数
                // 根据所有参数类型得到对应的 ServiceCallSite
                // 只要存在无法解析的参数类型，则抛出异常异常
                // 可以利用 throwIfCallSiteNotFound 来控制是否抛出异常，默认值为 true
                parameterCallSites = CreateArgumentCallSites(
                    implementationType,
                    callSiteChain,
                    parameters,
                    throwIfCallSiteNotFound: true)!;

                return new ConstructorCallSite(lifetime, serviceType, constructor, parameterCallSites);
            }

            // 如果候选构造函数多于一个，需要选择最优的构造函数
            // 最优匹配原则：
            // 1. 优先选择参数列表长度最长的
            // 2. 所有参数类型可以解析（可以通过服务注册类型查找表找到，并且可以得到 ServiceCallSite）
            // 3. 所有候选构造函数的参数列表必须是最优构造函数的参数列表的子集（即最优构造函数的参数列表是所有候选构造函数参数列表的超集）

            // 根据构造函数参数长度进行降序排序
            Array.Sort(constructors,
                (a, b) => b.GetParameters().Length.CompareTo(a.GetParameters().Length));
            
            ConstructorInfo? bestConstructor = null;
            HashSet<Type>? bestConstructorParameterTypes = null;
            for (int i = 0; i < constructors.Length; i++)
            {
                ParameterInfo[] parameters = constructors[i].GetParameters();

                // 根据所有参数类型得到对应的 ServiceCallSite
                // 如果存在无法解析的参数类型，则返回 null
                // 因为 throwIfCallSiteNotFound 指定为 false，所以不会抛出异常
                ServiceCallSite[]? currentParameterCallSites = CreateArgumentCallSites(
                    implementationType,
                    callSiteChain,
                    parameters,
                    throwIfCallSiteNotFound: false);

                // 所有参数类型可以解析
                if (currentParameterCallSites != null)
                {
                    // 因为数组元素已经降序排列（最长参数列表）
                    // 所以首次参数解析成功的构造函数即为候选最优构造函数
                    if (bestConstructor == null)
                    {
                        bestConstructor = constructors[i];
                        parameterCallSites = currentParameterCallSites;
                    }
                    else
                    {
                        // 将候选最优构造函数的参数类型提取出来
                        // 用来和本次候选构造函数参数对比
                        if (bestConstructorParameterTypes == null)
                        {
                            bestConstructorParameterTypes = new HashSet<Type>();
                            foreach (ParameterInfo p in bestConstructor.GetParameters())
                            {
                                bestConstructorParameterTypes.Add(p.ParameterType);
                            }
                        }

                        foreach (ParameterInfo p in parameters)
                        {
                            // 后续的候选构造函数的参数如果存在参数类型不在候选最优构造函数的参数列表中（不满足子集原则），则抛出 InvalidOperationException
                            if (!bestConstructorParameterTypes.Contains(p.ParameterType))
                            {
                                throw new InvalidOperationException(string.Join(
                                    Environment.NewLine,
                                    SR.Format(SR.AmbiguousConstructorException, implementationType),
                                    bestConstructor,
                                    constructors[i]));
                            }
                        }
                    }
                }
            }

            // 没有找到最优构造函数，则抛出 InvalidOperationException
            if (bestConstructor == null)
            {
                throw new InvalidOperationException(
                    SR.Format(SR.UnableToActivateTypeException, implementationType));
            }
            else
            {
                // 多于一个公开实例构造函数的类型至少存在一个非默认构造函数，所以一定会执行参数解析
                // 要么属于候选最优构造函数，要门不满足子集原则，则抛出 InvalidOperationException
                // 所以此处可以用断言判断是否解析参数列表成功
                Debug.Assert(parameterCallSites != null);
                return new ConstructorCallSite(lifetime, serviceType, bestConstructor, parameterCallSites);
            }
        }
        finally
        {
            // 完成后从 callSiteChain 移除服务类型
            callSiteChain.Remove(serviceType);
        }
    }

    // 根据参数类型创建 ServiceCallSite
    private ServiceCallSite[]? CreateArgumentCallSites(
            Type implementationType,
            CallSiteChain callSiteChain,
            ParameterInfo[] parameters,
            bool throwIfCallSiteNotFound)
    {
        var parameterCallSites = new ServiceCallSite[parameters.Length];
        for (int index = 0; index < parameters.Length; index++)
        {
            // 得到参数类型
            Type parameterType = parameters[index].ParameterType;
            // 使用参数类型作为服务类型调用 GetCallSite 得到 ServiceCallSite
            ServiceCallSite? callSite = GetCallSite(parameterType, callSiteChain);

            // 没有得到 ServiceCallSite 时尝试得到服务类型的默认值
            if (callSite == null && ParameterDefaultValue.TryGetDefaultValue(parameters[index], out object? defaultValue))
            {
                // 使用默认值创建 ConstantCallSite
                callSite = new ConstantCallSite(parameterType, defaultValue);
            }

            if (callSite == null)
            {
                // 没有得到 ServiceCallSite 时是否需要抛出异常
                if (throwIfCallSiteNotFound)
                {
                    throw new InvalidOperationException(SR.Format(SR.CannotResolveService,
                        parameterType,
                        implementationType));
                }

                // 如果不抛出异常，则只要存在参数类型无法得到 ServiceCallSite 时就直接返回 null
                return null;
            }

            parameterCallSites[index] = callSite;
        }

        return parameterCallSites;
    }

    // 针对开放泛型类型创建 ServiceCallSite
    private ServiceCallSite? TryCreateOpenGeneric(Type serviceType, CallSiteChain callSiteChain)
    {
        // 服务类型必须是被构造的泛型类型（封闭类型）并且在服务注册类型查找表中存在该泛型类型定义（开放泛型类型）的服务注册类型
        if (serviceType.IsConstructedGenericType
            && _descriptorLookup.TryGetValue(serviceType.GetGenericTypeDefinition(), out ServiceDescriptorCacheItem descriptor))
        {
            // 尝试使用最后注册的 ServiceDescriptor 和默认默认槽 0 创建 ServiceCallSite
            return TryCreateOpenGeneric(descriptor.Last, serviceType, callSiteChain, DefaultSlot, true);
        }
 
        return null;
    }

    private ServiceCallSite? TryCreateOpenGeneric(ServiceDescriptor descriptor, Type serviceType, CallSiteChain callSiteChain, int slot, bool throwOnConstraintViolation)
    {
        // 服务类型是被构造的泛型类型（封闭类型）并且服务类型的泛型类型定义（开放泛型类型）与服务注册类型相同
        if (serviceType.IsConstructedGenericType &&
            serviceType.GetGenericTypeDefinition() == descriptor.ServiceType)
        {
            // 利用服务类型和槽位创建 ServiceCacheKey
            ServiceCacheKey callSiteKey = new ServiceCacheKey(serviceType, slot);
            // 已经存在直接返回
            if (_callSiteCache.TryGetValue(callSiteKey, out ServiceCallSite? serviceCallSite))
            {
                return serviceCallSite;
            }

            Debug.Assert(descriptor.ImplementationType != null, "descriptor.ImplementationType != null");
            // 创建结果缓存
            var lifetime = new ResultCache(descriptor.Lifetime, serviceType, slot);
            Type closedType;
            try
            {
                // 根据服务类型的泛型实参构建实现注册类型（开放泛型类型）的封闭类型
                closedType = descriptor.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments);
            }
            catch (ArgumentException)
            {
                if (throwOnConstraintViolation)
                {
                    throw;
                }

                return null;
            }

            // 根据 closedType 创建 ConstructorCallSite
            // 开放泛型类型作为服务注册类型时，在得到封闭实现类型创建 ServiceCallSite 时只能是基于构造函数的 ConstructorCallSite
            // 因为需要利用服务类型的泛型实参构建封闭实现类型，所以在服务注册时只能通过 ImplementationType 指定实现注册类型
            // 并通过构造函数创建实例
            return _callSiteCache[callSiteKey] = CreateConstructorCallSite(lifetime, serviceType, closedType, callSiteChain);
        }

        return null;
    }

    // 针对 IEnumerable<> 类型创建 ServiceCallSite
    private ServiceCallSite? TryCreateEnumerable(Type serviceType, CallSiteChain callSiteChain)
    {
        // 利用服务类型和槽位创建 ServiceCacheKey
        ServiceCacheKey callSiteKey = new ServiceCacheKey(serviceType, DefaultSlot);
        // 已经存在直接返回
        if (_callSiteCache.TryGetValue(callSiteKey, out ServiceCallSite? serviceCallSite))
        {
            return serviceCallSite;
        }

        try
        {
            // 首先往 callSiteChain 添加服务类型
            callSiteChain.Add(serviceType);

            // 确定 IEnumerable<> 的泛型实参是封闭类型
            if (serviceType.IsConstructedGenericType &&
                serviceType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
            {
                // 得到泛型实参的类型
                Type itemType = serviceType.GenericTypeArguments[0];
                // 先假设默认缓存位置是根容器
                CallSiteResultCacheLocation cacheLocation = CallSiteResultCacheLocation.Root;

                var callSites = new List<ServiceCallSite>();

                // 如果 itemType 不是被构造的泛型类型（开放泛型类型或者非泛型封闭类型）
                // 此处基于前面的判断 IEnumerable<> 的泛型实参是封闭类型，所以不可能是开放泛型类型
                // 利用 itemType 查找服务注册类型查找表得到 ServiceDescriptorCacheItem
                if (!itemType.IsConstructedGenericType &&
                    _descriptorLookup.TryGetValue(itemType, out ServiceDescriptorCacheItem descriptors))
                {
                    // 从最早注册的 ServiceDescriptor 开始遍历
                    // 所以对于非泛型封闭类型，越早注册的 ServiceDescriptor，最终解析得到的实例会出现在返回数组的前面
                    for (int i = 0; i < descriptors.Count; i++)
                    {
                        ServiceDescriptor descriptor = descriptors[i];

                        // ServiceDescriptorCacheItem._item 槽位最大（Count - 1），依次递减，最后添加的 ServiceDescriptorCacheItem.Last 槽位最小（0）
                        int slot = descriptors.Count - i - 1;
                        // 此处基于前面的两个判断 IEnumerable<> 的泛型实参类型是封闭类型和泛型实参类型不是被构造的泛型类型
                        // 所以 itemType 只可能是封闭类型，直接调用 TryCreateExact 尝试创建 ServiceCallSite
                        ServiceCallSite? callSite = TryCreateExact(descriptor, itemType, callSiteChain, slot);
                        Debug.Assert(callSite != null);

                        // 使用基础类型值最大的作为最终缓存位置
                        // 基础类型值从小到大依次为 Root -> Scope -> Dispose -> None
                        cacheLocation = GetCommonCacheLocation(cacheLocation, callSite.Cache.Location);
                        callSites.Add(callSite);
                    }
                }
                else
                {
                    // 如果 itemType 是被构造的泛型类型（泛型封闭类型）
                    // 可能不能直接通过服务注册类型查找表得到 ServiceDescriptorCacheItem
                    // 因为服务注册可能是通过开放泛型类型注册的
                    int slot = 0;
                    // 从后往前遍历所有 ServiceDescriptor
                    // 所以对于泛型封闭类型，越早注册的 ServiceDescriptor，最终解析得到的实例会出现在返回数组的后面
                    for (int i = _descriptors.Length - 1; i >= 0; i--)
                    {
                        ServiceDescriptor descriptor = _descriptors[i];
                        // 被构造的泛型类型（泛型封闭类型）可能通过 TryCreateExact 和 TryCreateOpenGeneric 得到 ServiceCallSite
                        // 1. 如果 descriptor.ServiceType 服务注册类型是开放泛型类型
                        //    TryCreateExact 会通过 descriptor.ServiceType == itemType 过滤
                        // 2. TryCreateOpenGeneric 会通过 
                        //      itemType.IsConstructedGenericType 
                        //      && itemType.GetGenericTypeDefinition() == descriptor.ServiceType
                        //    检查是不是 itemType 的泛型定义存在对应的 descriptor.ServiceType 服务注册类型
                        ServiceCallSite? callSite = TryCreateExact(descriptor, itemType, callSiteChain, slot) ??
                                    TryCreateOpenGeneric(descriptor, itemType, callSiteChain, slot, false);

                        if (callSite != null)
                        {
                            // 因为是从后往前遍历，所以槽位递增
                            slot++;

                            cacheLocation = GetCommonCacheLocation(cacheLocation, callSite.Cache.Location);
                            callSites.Add(callSite);
                        }
                    }

                    // 反转列表
                    // 保证越早注册的 ServiceDescriptor，最终解析得到的实例会出现在返回数组的前面
                    callSites.Reverse();
                }


                ResultCache resultCache = ResultCache.None;
                // 如果缓存位置是 Scope 或 Root
                if (cacheLocation == CallSiteResultCacheLocation.Scope || cacheLocation == CallSiteResultCacheLocation.Root)
                {
                    // 创建结果缓存
                    // 具体结果缓存位置由泛型实参类型解析过程中得到的每个 ServiceCallSite.Cache.Location 决定
                    resultCache = new ResultCache(cacheLocation, callSiteKey);
                }

                // 创建 IEnumerableCallSite
                return _callSiteCache[callSiteKey] = new IEnumerableCallSite(resultCache, itemType, callSites.ToArray());
            }

            return null;
        }
        finally
        {
            // 完成后从 callSiteChain 移除服务类型
            callSiteChain.Remove(serviceType);
        }
    }

    // 直接添加 ServiceCallSite
    // 针对特殊服务注册
    public void Add(Type type, ServiceCallSite serviceCallSite)
    {
        _callSiteCache[new ServiceCacheKey(type, DefaultSlot)] = serviceCallSite;
    }

    // 表示相同服务注册类型的多个 ServiceDescriptor 组成的链表
    private struct ServiceDescriptorCacheItem
    {
        // 最早添加的 ServiceDescriptor
        private ServiceDescriptor? _item;

        // 除最早添加的 ServiceDescriptor 集合
        private List<ServiceDescriptor>? _items;

        // 最后添加的 ServiceDescriptor
        public ServiceDescriptor Last
        {
            get
            {
                if (_items != null && _items.Count > 0)
                {
                    // 返回集合中最后的元素
                    return _items[_items.Count - 1];
                }

                Debug.Assert(_item != null);
                // 如果集合没有元素就返回唯一的最早添加的
                return _item;
            }
        }

        // 添加的 ServiceDescriptor 总数
        public int Count
        {
            get
            {
                if (_item == null)
                {
                    Debug.Assert(_items == null);
                    return 0;
                }

                return 1 + (_items?.Count ?? 0);
            }
        }

        // 根据索引得到 ServiceDescriptor
        public ServiceDescriptor this[int index]
        {
            get
            {
                if (index >= Count)
                {
                    throw new ArgumentOutOfRangeException(nameof(index));
                }

                if (index == 0)
                {
                    return _item!;
                }

                return _items![index - 1];
            }
        }

        // 槽位根据添加顺序的倒序表示
        // 最后添加的槽位为 0
        // 最早添加的槽位为 Count - 1
        public int GetSlot(ServiceDescriptor descriptor)
        {
            if (descriptor == _item)
            {
                return Count - 1;
            }

            if (_items != null)
            {
                int index = _items.IndexOf(descriptor);
                if (index != -1)
                {
                    return _items.Count - (index + 1);
                }
            }

            throw new InvalidOperationException(SR.ServiceDescriptorNotExist);
        }

        // 添加 ServiceDescriptor
        public ServiceDescriptorCacheItem Add(ServiceDescriptor descriptor)
        {
            // 每次添加都初始化新的 ServiceDescriptorCacheItem，保证其不可变性
            var newCacheItem = default(ServiceDescriptorCacheItem);
            if (_item == null)
            {
                Debug.Assert(_items == null);
                newCacheItem._item = descriptor;
            }
            else
            {
                newCacheItem._item = _item;
                newCacheItem._items = _items ?? new List<ServiceDescriptor>();
                newCacheItem._items.Add(descriptor);
            }
            return newCacheItem;
        }
    }
}
```

- ServiceCacheKey  
```C#
// 表示服务缓存键
// 由服务类型和槽位决定
internal readonly struct ServiceCacheKey : IEquatable<ServiceCacheKey>
{
    public static ServiceCacheKey Empty { get; } = new ServiceCacheKey(null, 0);

    // 服务类型
    public Type? Type { get; }

    // 槽位
    public int Slot { get; }

    public ServiceCacheKey(Type? type, int slot)
    {
        Type = type;
        Slot = slot;
    }

    public bool Equals(ServiceCacheKey other) =>
        Type == other.Type && Slot == other.Slot;

    // 重写 Equals
    public override bool Equals([NotNullWhen(true)] object? obj) =>
        obj is ServiceCacheKey other && Equals(other);

    // 重写 GetHashcode
    public override int GetHashCode()
    {
        unchecked
        {
            return ((Type?.GetHashCode() ?? 23) * 397) ^ Slot;
        }
    }
}
```

- ResultCache  
```C#
// 表示结果缓存
internal struct ResultCache
{   
    // 无缓存
    public static ResultCache None { get; } = new ResultCache(CallSiteResultCacheLocation.None, ServiceCacheKey.Empty);

    internal ResultCache(CallSiteResultCacheLocation lifetime, ServiceCacheKey cacheKey)
    {
        Location = lifetime;
        Key = cacheKey;
    }

    // 不同生命周期对应的缓存位置
    public ResultCache(ServiceLifetime lifetime, Type? type, int slot)
    {
        Debug.Assert(lifetime == ServiceLifetime.Transient || type != null);

        switch (lifetime)
        {
            case ServiceLifetime.Singleton:
                Location = CallSiteResultCacheLocation.Root;
                break;
            case ServiceLifetime.Scoped:
                Location = CallSiteResultCacheLocation.Scope;
                break;
            case ServiceLifetime.Transient:
                Location = CallSiteResultCacheLocation.Dispose;
                break;
            default:
                Location = CallSiteResultCacheLocation.None;
                break;
        }
        Key = new ServiceCacheKey(type, slot);
    }

    public CallSiteResultCacheLocation Location { get; set; }

    public ServiceCacheKey Key { get; set; }
}
```

- ServiceCallSite  
```C#
// 实现类型：
// 1. ConstantCallSite 针对常量值或者 ServiceDescriptor.ImplementationInstance 服务消费
// 2. ConstructorCallSite 针对 ServiceDescriptor.ImplementationType 服务消费
// 3. FactoryCallSite 针对 ServiceDescriptor.ImplementationFactory 服务消费
// 4. IEnumerableCallSite 针对 IEnumerable<> 服务消费
// 5. ServiceProviderCallSite 针对 IServiceProvider 服务消费
internal abstract class ServiceCallSite
{
    protected ServiceCallSite(ResultCache cache)
    {
        Cache = cache;
    }
    
    // 服务类型
    public abstract Type ServiceType { get; }
    // 实现类型
    public abstract Type? ImplementationType { get; }
    // CallSite 类别，分别对应 ServiceCallSite 同名的实现类型
    public abstract CallSiteKind Kind { get; }
    // 结果缓存
    public ResultCache Cache { get; }
    // 保存如下服务实例：
    // 1. 通过 ConstantCallSite 保存服务默认值
    // 2. 通过 ConstantCallSite 保存 ServiceDescriptor.ImplementationInstance
    // 3. 生命周期为 Singleton 的服务
    public object? Value { get; set; }

    // 捕获实现类型实现了 IDisposable 或 IAsyncDisposable 接口的服务
    public bool CaptureDisposable =>
        ImplementationType == null ||
        typeof(IDisposable).IsAssignableFrom(ImplementationType) ||
        typeof(IAsyncDisposable).IsAssignableFrom(ImplementationType);
}
```

- CallSiteVisitor\<,\>  
```C#
// 使用访问者模式读取 ServiceCallSite 解析服务
// 实现类型：
// 1. CallSiteValidator 开启 ServiceProviderOptions 选项中的 ValidateScopes 配置时验证服务范围的有效性
// 2. CallSiteRuntimeResolver 使用反射方式解析服务
// 3. ILEmitResolverBuilder 使用 ILEmit 方式解析服务
// 4. ExpressionResolverBuilder 使用表达式树方式解析服务
internal abstract class CallSiteVisitor<TArgument, TResult>
{
    private readonly StackGuard _stackGuard;

    protected CallSiteVisitor()
    {
        _stackGuard = new StackGuard();
    }

    // 根据不同的结果缓存位置读取 ServiceCallSite
    protected virtual TResult VisitCallSite(ServiceCallSite callSite, TArgument argument)
    {
        if (!_stackGuard.TryEnterOnCurrentStack())
        {
            return _stackGuard.RunOnEmptyStack(VisitCallSite, callSite, argument);
        }

        // 根据不同的结果缓存位置调用对应的方法
        switch (callSite.Cache.Location)
        {
            case CallSiteResultCacheLocation.Root:
                return VisitRootCache(callSite, argument);
            case CallSiteResultCacheLocation.Scope:
                return VisitScopeCache(callSite, argument);
            case CallSiteResultCacheLocation.Dispose:
                return VisitDisposeCache(callSite, argument);
            case CallSiteResultCacheLocation.None:
                return VisitNoCache(callSite, argument);
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    // 根据不同的 CallSite 类别调用对应的方法
    protected virtual TResult VisitCallSiteMain(ServiceCallSite callSite, TArgument argument)
    {
        switch (callSite.Kind)
        {
            case CallSiteKind.Factory:
                return VisitFactory((FactoryCallSite)callSite, argument);
            case CallSiteKind.IEnumerable:
                return VisitIEnumerable((IEnumerableCallSite)callSite, argument);
            case CallSiteKind.Constructor:
                return VisitConstructor((ConstructorCallSite)callSite, argument);
            case CallSiteKind.Constant:
                return VisitConstant((ConstantCallSite)callSite, argument);
            case CallSiteKind.ServiceProvider:
                return VisitServiceProvider((ServiceProviderCallSite)callSite, argument);
            default:
                throw new NotSupportedException(SR.Format(SR.CallSiteTypeNotSupported, callSite.GetType()));
        }
    }

    protected virtual TResult VisitNoCache(ServiceCallSite callSite, TArgument argument)
    {
        return VisitCallSiteMain(callSite, argument);
    }

    protected virtual TResult VisitDisposeCache(ServiceCallSite callSite, TArgument argument)
    {
        return VisitCallSiteMain(callSite, argument);
    }

    protected virtual TResult VisitRootCache(ServiceCallSite callSite, TArgument argument)
    {
        return VisitCallSiteMain(callSite, argument);
    }

    protected virtual TResult VisitScopeCache(ServiceCallSite callSite, TArgument argument)
    {
        return VisitCallSiteMain(callSite, argument);
    }

    protected abstract TResult VisitConstructor(ConstructorCallSite constructorCallSite, TArgument argument);

    protected abstract TResult VisitConstant(ConstantCallSite constantCallSite, TArgument argument);

    protected abstract TResult VisitServiceProvider(ServiceProviderCallSite serviceProviderCallSite, TArgument argument);

    protected abstract TResult VisitIEnumerable(IEnumerableCallSite enumerableCallSite, TArgument argument);

    protected abstract TResult VisitFactory(FactoryCallSite factoryCallSite, TArgument argument);
}
```

- CallSiteRuntimeResolver  
```C#
// 反射方式解析服务
internal sealed class CallSiteRuntimeResolver : CallSiteVisitor<RuntimeResolverContext, object?>
{
    // 单例模式
    public static CallSiteRuntimeResolver Instance { get; } = new();

    private CallSiteRuntimeResolver()
    {
    }

    // 解析服务
    public object? Resolve(ServiceCallSite callSite, ServiceProviderEngineScope scope)
    {
        // 本次服务解析的服务范围是根容器，则会首先尝试从 ServiceCallSite.Value 中得到服务，提升性能
        if (scope.IsRootScope && callSite.Value is object cached)
        {
            return cached;
        }

        // 读取 ServiceCallSite
        return VisitCallSite(callSite, new RuntimeResolverContext
        {
            Scope = scope
        });
    }

    // 访问 Root 服务范围解析服务
    protected override object? VisitRootCache(ServiceCallSite callSite, RuntimeResolverContext context)
    {
        // 尝试从 ServiceCallSite.Value 中得到服务，提升性能
        if (callSite.Value is object value)
        {
            return value;
        }

        var lockType = RuntimeResolverLock.Root;
        // 统一将服务范围切换为根容器
        ServiceProviderEngineScope serviceProviderEngine = context.Scope.RootProvider.Root;

        // 在并发访问的情况下，保证同步访问 ServiceCallSite 解析得到实例
        lock (callSite)
        {
            // 再次尝试从 ServiceCallSite.Value 中得到服务，因为当前线程可能刚刚从阻塞状态恢复
            if (callSite.Value is object callSiteValue)
            {
                return callSiteValue;
            }

            // 如果服务范围内还没有针对 ServiceCallSite 的服务实例就执行实际的解析方法
            object? resolved = VisitCallSiteMain(callSite, new RuntimeResolverContext
            {
                Scope = serviceProviderEngine,
                // 按位或操作，当前解析上下文添加上锁定范围
                AcquiredLocks = context.AcquiredLocks | lockType
            });
            // 捕获服务是否需要放入服务范围的 ServiceProviderEngineScope._disposables 集合中
            serviceProviderEngine.CaptureDisposable(resolved);
            // 服务范围是根容器解析的服务实际上并不保存在 ServiceProviderEngineScope.ResolvedServices 字典中
            // 而是保存在 ServiceCallSite 的 Value 属性中
            callSite.Value = resolved;
            return resolved;
        }
    }

    // 访问 Scope 服务范围解析服务
    // 如果 context 中的 Scope 是根服务范围，则访问 Root 服务范围解析服务
    protected override object? VisitScopeCache(ServiceCallSite callSite, RuntimeResolverContext context)
    {
        // 如果当前解析服务的服务范围是根容器，则调用 VisitRootCache
        return context.Scope.IsRootScope ?
            VisitRootCache(callSite, context) :
            VisitCache(callSite, context, context.Scope, RuntimeResolverLock.Scope);
    }

    private object? VisitCache(
        ServiceCallSite callSite, 
        RuntimeResolverContext context, 
        ServiceProviderEngineScope serviceProviderEngine, 
        RuntimeResolverLock lockType)
    {
        bool lockTaken = false;
        object sync = serviceProviderEngine.Sync;
        Dictionary<ServiceCacheKey, object?> resolvedServices = serviceProviderEngine.ResolvedServices;

        // 当前线程首次通过 Visit 访问 ServiceProviderEngineScope.ResolvedServices 时，则需要对 ServiceProviderEngineScope.ResolvedServices 加锁
        // 在同一线程只需对 ServiceProviderEngineScope.ResolvedServices 锁定一次，因为后续的 Visit 操作一定是同步完成的
        // 不同线程对 ServiceProviderEngineScope.ResolvedServices 的访问需要通过同步量 ServiceProviderEngineScope.ResolvedServices 同步访问
        if ((context.AcquiredLocks & lockType) == 0)
        {
            Monitor.Enter(sync, ref lockTaken);
        }

        try
        {
            // 从服务范围的 ServiceProviderEngineScope.ResolvedServices 中尝试得到服务
            if (resolvedServices.TryGetValue(callSite.Cache.Key, out object? resolved))
            {
                return resolved;
            }

            // 如果服务范围内还没有针对 ServiceCallSite 的服务实例就执行实际的解析方法
            resolved = VisitCallSiteMain(callSite, new RuntimeResolverContext
            {
                Scope = serviceProviderEngine,
                // 按位或操作，当前解析上下文添加上锁定范围
                AcquiredLocks = context.AcquiredLocks | lockType
            });

            // 捕获服务是否需要送入服务范围的 ServiceProviderEngineScope._disposables 集合中
            serviceProviderEngine.CaptureDisposable(resolved);
            // 解析得到的服务存入 ServiceProviderEngineScope.ResolvedServices 字典中
            resolvedServices.Add(callSite.Cache.Key, resolved);
            return resolved;
        }
        finally
        {
            // 如果加锁，则释放
            if (lockTaken)
            {
                Monitor.Exit(sync);
            }
        }
    }

    protected override object? VisitDisposeCache(ServiceCallSite transientCallSite, RuntimeResolverContext context)
    {
        // 执行实际的解析方法并尝试捕获服务是否需要送入服务范围的 ServiceProviderEngineScope._disposables 集合中
        return context.Scope.CaptureDisposable(VisitCallSiteMain(transientCallSite, context));
    }

    // 使用实例工厂得到服务
    protected override object VisitFactory(FactoryCallSite factoryCallSite, RuntimeResolverContext context)
    {
        return factoryCallSite.Factory(context.Scope);
    }

    // 使用常量实例得到服务
    protected override object? VisitConstant(ConstantCallSite constantCallSite, RuntimeResolverContext context)
    {
        // DefaultValue 实质上就是在创建 ConstantCallSite 时将 ServiceDescriptor.ImplementationInstance 赋值给 ServiceCallSite.Value 的值
        return constantCallSite.DefaultValue;
    }

    // 直接返回当前服务范围
    protected override object VisitServiceProvider(ServiceProviderCallSite serviceProviderCallSite, RuntimeResolverContext context)
    {
        return context.Scope;
    }

    // 使用构造函数得到服务（反射方式）
    // 在替换为 ILEmit 方式（ILEmitResolverBuilder）后则是通过运行时编织 IL 指令方式调用构造函数创建实例
    protected override object VisitConstructor(ConstructorCallSite constructorCallSite, RuntimeResolverContext context)
    {
        object?[] parameterValues;
        // 没有参数
        if (constructorCallSite.ParameterCallSites.Length == 0)
        {
            parameterValues = Array.Empty<object>();
        }
        else
        {
            parameterValues = new object?[constructorCallSite.ParameterCallSites.Length];
            for (int index = 0; index < parameterValues.Length; index++)
            {
                // 根据每个参数对应的 ServiceCallSite 调用 VisitCallSite 得到服务实例
                parameterValues[index] = VisitCallSite(constructorCallSite.ParameterCallSites[index], context);
            }
        }

    #if NETFRAMEWORK || NETSTANDARD2_0
                try
                {
                    // 通过反射方式调用构造函数创建服务实例
                    return constructorCallSite.ConstructorInfo.Invoke(parameterValues);
                }
                catch (Exception ex) when (ex.InnerException != null)
                {
                    ExceptionDispatchInfo.Capture(ex.InnerException).Throw();
                    throw;
                }
    #else
        return constructorCallSite.ConstructorInfo.Invoke(BindingFlags.DoNotWrapExceptions, binder: null, parameters: parameterValues, culture: null);
    #endif
    }

    protected override object VisitIEnumerable(IEnumerableCallSite enumerableCallSite, RuntimeResolverContext context)
    {
        // 使用 IEnumerable<> 方式得到的服务实例最终都是存放在 T[] 类型数组中（T 代表服务类型）
        var array = Array.CreateInstance(
            enumerableCallSite.ItemType,
            enumerableCallSite.ServiceCallSites.Length);
 
        for (int index = 0; index < enumerableCallSite.ServiceCallSites.Length; index++)
        {
            // 遍历每个 ServiceCallSite 调用 VisitCallSite 得到服务实例
            object? value = VisitCallSite(enumerableCallSite.ServiceCallSites[index], context);
            // 添加数组元素
            array.SetValue(value, index);
        }
        return array;
    }
}

internal struct RuntimeResolverContext
{
    // 服务范围
    public ServiceProviderEngineScope Scope { get; set; }
    
    // 保证每一个 Scope 服务范围内服务的单例性
    public RuntimeResolverLock AcquiredLocks { get; set; }
}

[Flags]
internal enum RuntimeResolverLock
{
    Scope = 1,
    Root = 2
}
```

- ServiceProviderServiceExtensions  
```C#

// IServiceProvider 的扩展方法
public static class ServiceProviderServiceExtensions
{
    
    // 根据泛型强类型得到服务
    public static T? GetService<T>(this IServiceProvider provider)
    {
        ThrowHelper.ThrowIfNull(provider);

        return (T?)provider.GetService(typeof(T));
    }

    // 得到必要服务，如果为 null，则抛出 InvalidOperationException
    public static object GetRequiredService(this IServiceProvider provider, Type serviceType)
    {
        ThrowHelper.ThrowIfNull(provider);
        ThrowHelper.ThrowIfNull(serviceType);

        if (provider is ISupportRequiredService requiredServiceSupportingProvider)
        {
            return requiredServiceSupportingProvider.GetRequiredService(serviceType);
        }

        object? service = provider.GetService(serviceType);
        if (service == null)
        {
            throw new InvalidOperationException(SR.Format(SR.NoServiceRegistered, serviceType));
        }

        return service;
    }

    // 根据泛型强类型得到必要服务，如果为 null，则抛出 InvalidOperationException
    public static T GetRequiredService<T>(this IServiceProvider provider) where T : notnull
    {
        ThrowHelper.ThrowIfNull(provider);

        return (T)provider.GetRequiredService(typeof(T));
    }

    // 得到 IEnumerable<> 承载的多个 T 服务类型的服务
    public static IEnumerable<T> GetServices<T>(this IServiceProvider provider)
    {
        ThrowHelper.ThrowIfNull(provider);

        // 因为最终会调用 CallSiteVisitor.VisitIEnumerable 方法解析得到服务实例
        // CallSiteVisitor.VisitIEnumerable 实现方法内部最终会根据 ServiceCallSite 集合长度创建数组
        // 所以可能存在 ServiceCallSite 集合长度为 0 的情况（这时候就会创建长度为 0 的数组）
        // 最终返回空数组
        return provider.GetRequiredService<IEnumerable<T>>();
    }

    // 同上
    // T 类型由 serviceType 参数表示
    public static IEnumerable<object?> GetServices(this IServiceProvider provider, Type serviceType)
    {
        ThrowHelper.ThrowIfNull(provider);
        ThrowHelper.ThrowIfNull(serviceType);

        // 构造 IEnumerable<> 封闭类型
        Type? genericEnumerable = typeof(IEnumerable<>).MakeGenericType(serviceType);
        return (IEnumerable<object>)provider.GetRequiredService(genericEnumerable);
    }

    // 根据 IServiceProvider 得到子服务范围
    public static IServiceScope CreateScope(this IServiceProvider provider)
    {
        // 通过调用 GetRequiredService 获取 IServiceScopeFactory 服务实例
        return provider.GetRequiredService<IServiceScopeFactory>().CreateScope();
    }

    ...
}
```

- IServiceProviderFactory\<\>  
```C#
// 服务容器工厂的抽象表示
// 用来适配第三方依赖注入框架
public interface IServiceProviderFactory<TContainerBuilder> where TContainerBuilder : notnull
{
    // 根据 IServiceCollection 创建 TContainerBuilder 容器建造者
    TContainerBuilder CreateBuilder(IServiceCollection services);
    
    // 使用 CreateBuilder 方法创建的 TContainerBuilder 容器建造者创建 IServiceProvider 服务容器
    IServiceProvider CreateServiceProvider(TContainerBuilder containerBuilder);
}
```

- DefaultServiceProviderFactory  
```C#
// ASP.NET Core 框架内建的默认服务容器工厂
public class DefaultServiceProviderFactory : IServiceProviderFactory<IServiceCollection>
{
    private readonly ServiceProviderOptions _options;

    public DefaultServiceProviderFactory() : this(ServiceProviderOptions.Default)
    {
        
    }

    public DefaultServiceProviderFactory(ServiceProviderOptions options)
    {
        // 必须指定 ServiceProviderOptions
        _options = options ?? throw new ArgumentNullException(nameof(options));
    }

    // 使用 IServiceCollection 作为容器建造者
    public IServiceCollection CreateBuilder(IServiceCollection services)
    {
        return services;
    }

    // 使用 IServiceCollection 创建 ServiceProvider 作为根容器
    public IServiceProvider CreateServiceProvider(IServiceCollection containerBuilder)
    {
        return containerBuilder.BuildServiceProvider(_options);
    }
}
```