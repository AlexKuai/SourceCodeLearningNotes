# 依赖注入

## 源码涉及的核心类型

- ServiceDescriptor  
- IServiceCollection  
- ServiceCollection  
- ServiceCollectionDescriptorExtensions  
- ServiceCollectionServiceExtensions  
- ServiceCollectionContainerBuilderExtensions  
- ServiceProviderOptions  
- IServiceProvider  
- ServiceProvider  
- CompiledServiceProviderEngine  
- DynamicServiceProviderEngine  
- IServiceScope  
- IServiceScopeFactory  
- ServiceProviderEngineScope  
- CallSiteFactory  
- ServiceDescriptorCacheItem  
- ServiceCacheKey  
- ResultCache  
- ServiceCallSite  
- CallSiteVisitor\<,\>  
- CallSiteRuntimeResolver  
- RuntimeResolverContext  
- RuntimeResolverLock  
- ServiceProviderServiceExtensions  
- IServiceProviderFactory\<\>  
- DefaultServiceProviderFactory  

## 服务注册

- ServiceDescriptor  

```C#
// 描述服务生命周期、服务注册类型、实现注册类型、实现工厂、实例
public class ServiceDescriptor
{
    // 生命周期
    public ServiceLifetime Lifetime { get; }
 
    // 服务注册类型
    // 注册的可能是开放泛型类型
    public Type ServiceType { get; }
 
    // 实现注册类型
    // 注册的可能是开放泛型类型
    public Type? ImplementationType { get; }

    // 实现工厂
    // 实际的实现工厂类型可能满足泛型委托的协变
    public Func<IServiceProvider, object>? ImplementationFactory { get; }

    // 实例
    public object? ImplementationInstance { get; }

    // 得到实现注册类型
    internal Type GetImplementationType()
    {
        if (ImplementationType != null)
        {
            // 实现注册类型
            return ImplementationType;
        }
        else if (ImplementationInstance != null)
        {
            // 实例类型
            return ImplementationInstance.GetType();
        }
        else if (ImplementationFactory != null)
        {
            // 实际的实现工厂委托类型可能满足泛型委托的协变
            // 所以使用工厂委托的第二个泛型参数类型（即返回值类型）作为实现类型
            Type[]? typeArguments = ImplementationFactory.GetType().GenericTypeArguments;
 
            Debug.Assert(typeArguments.Length == 2);

            return typeArguments[1];
        }
 
        Debug.Assert(false, "ImplementationType, ImplementationInstance or ImplementationFactory must be non null");
        return null;
    }

    // 针对不同生命周期的 ServiceDescriptor 创建方法，内部大部分最终都是调用 Describe 静态方法创建 ServiceDescriptor
    public static ServiceDescriptor Transient<...>(...);
    public static ServiceDescriptor Scoped<...>(...);
    public static ServiceDescriptor Singleton<...>(...);

    private static ServiceDescriptor Describe<TService, TImplementation>(ServiceLifetime lifetime)
        where TService : class
        where TImplementation : class, TService
    {
         return Describe(typeof(TService), typeof(TImplementation), lifetime: lifetime);
    }
 
    public static ServiceDescriptor Describe(Type serviceType, Type implementationType, ServiceLifetime lifetime)
    {
        return new ServiceDescriptor(serviceType, implementationType, lifetime);
    }
 
    public static ServiceDescriptor Describe(Type serviceType, Func<IServiceProvider, object> implementationFactory, ServiceLifetime lifetime)
    {
        return new ServiceDescriptor(serviceType, implementationFactory, lifetime);
    }
}
```

- IServiceCollection  

```C#
// 表示 ServiceDescriptor 集合
public interface IServiceCollection : IList<ServiceDescriptor>
{
}

// IServiceCollection 的默认实现
public class ServiceCollection : IServiceCollection
{
    private readonly List<ServiceDescriptor> _descriptors = new List<ServiceDescriptor>();
    private bool _isReadOnly;
 
    // 实现 ICollection<T>
    public int Count => _descriptors.Count;
 
    // 实现 ICollection<T>
    public bool IsReadOnly => _isReadOnly;
 
    // 实现 IList<T>
    public ServiceDescriptor this[int index]
    {
        get
        {
            return _descriptors[index];
        }
        set
        {
            CheckReadOnly();
            _descriptors[index] = value;
        }
    }

    // 实现 IList<T>
    public int IndexOf(ServiceDescriptor item)
    {
        return _descriptors.IndexOf(item);
    }
    
    // 实现 IList<T>
    public void Insert(int index, ServiceDescriptor item)
    {
        CheckReadOnly();
        _descriptors.Insert(index, item);
    }
    
    // 实现 IList<T>
    public void RemoveAt(int index)
    {
        CheckReadOnly();
        _descriptors.RemoveAt(index);
    }

    // 实现 ICollection<T>
    void ICollection<ServiceDescriptor>.Add(ServiceDescriptor item)
    {
        CheckReadOnly();
        _descriptors.Add(item);
    }
    
    // 实现 ICollection<T>
    public void Clear()
    {
        CheckReadOnly();
        _descriptors.Clear();
    }
    
    // 实现 ICollection<T>
    public bool Contains(ServiceDescriptor item)
    {
        return _descriptors.Contains(item);
    }
 
    // 实现 ICollection<T>
    public void CopyTo(ServiceDescriptor[] array, int arrayIndex)
    {
        _descriptors.CopyTo(array, arrayIndex);
    }
 
    // 实现 ICollection<T>
    public bool Remove(ServiceDescriptor item)
    {
        CheckReadOnly();
        return _descriptors.Remove(item);
    }
    
    // 实现 IEnumerable<T>
    public IEnumerator<ServiceDescriptor> GetEnumerator()
    {
        return _descriptors.GetEnumerator();
    }
    
    // 显示实现 IEnumerable
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
 
    // 设置为只读
    public void MakeReadOnly()
    {
        _isReadOnly = true;
    }
    
    // 检查是否已设置为只读
    // 如果设置为只读，所有对字段 _descriptors 引用的集合的修改都会抛出 InvalidOperationException
    private void CheckReadOnly()
    {
        if (_isReadOnly)
        {
            throw new InvalidOperationException(SR.ServiceCollectionReadOnly);
        }
    }
}
```

- ServiceCollectionDescriptorExtensions  

```C#
// 直接使用 ServiceDescriptor 注册服务的扩展方法
// 内部最终调用 ICollection<T>.Add 方法添加 ServiceDescriptor
// 一般配合 ServiceDescriptor.Transient、ServiceDescriptor.Scoped、ServiceDescriptor.Singleton 等静态方法使用
public static class ServiceCollectionDescriptorExtensions
{
    public static IServiceCollection Add(this IServiceCollection collection, ...);
    public static void TryAdd(this IServiceCollection collection, ...)
    {
        int count = collection.Count;
        for (int i = 0; i < count; i++)
        {
            // 如果已经存在服务注册类型的 ServiceDescriptor，则忽略
            if (collection[i].ServiceType == descriptor.ServiceType)
            {
                return;
            }
        }
    }

    public static void TryAddTransient(this IServiceCollection collection, ...);
    public static void TryAddScoped(this IServiceCollection collection, ...);
    public static void TryAddSingleton(this IServiceCollection collection, ...);

    public static void TryAddEnumerable(this IServiceCollection services, ...)
    {
        // 得到实现注册类型
        Type? implementationType = descriptor.GetImplementationType();
 
        // 实现注册类型是 object 类型或者服务注册类型和实现注册类型相同，则抛出 ArgumentException
        // 1. new ServiceCollection().TryAddEnumerable(ServiceDescriptor.Singleton<IFoo>(_ => new Foo()));
        //    这种方式最终编译器生成的 IL 指令会创建 Func<IServiceProvider, IFoo> 类型的委托
        //    服务注册类型和实现注册类型相同，则抛出 ArgumentException
        // 2. Func<IServiceProvider, Foo> func = _ => new Foo();
        //    new ServiceCollection().TryAddEnumerable(ServiceDescriptor.Singleton<IFoo>(func));
        //    这种方式通过创建 Func<IServiceProvider, Foo> 类型的委托并利用了泛型委托的协变
        //    服务注册类型和实现注册类型不相同，运行正常
        if (implementationType == typeof(object) || implementationType == descriptor.ServiceType)
        {
            throw new ArgumentException(
                SR.Format(SR.TryAddIndistinguishableTypeToEnumerable,
                    implementationType,
                    descriptor.ServiceType),
                nameof(descriptor));
        }
 
        int count = services.Count;
        for (int i = 0; i < count; i++)
        {
            ServiceDescriptor service = services[i];
            // 如果已经存在服务注册类型和实现注册类型的 ServiceDescriptor，则忽略
            if (service.ServiceType == descriptor.ServiceType && service.GetImplementationType() == implementationType)
            {
                return;
            }
        }
    }

    public static IServiceCollection Replace(this IServiceCollection collection, ServiceDescriptor descriptor)
    {
        int count = collection.Count;
        for (int i = 0; i < count; i++)
        {
            // 服务注册类型存在，则删除
            if (collection[i].ServiceType == descriptor.ServiceType)
            {
                collection.RemoveAt(i);
                break;
            }
        }

        // 最终在末尾添加新的 ServiceDescriptor
        collection.Add(descriptor);

        ...
    }

    public static IServiceCollection RemoveAll<T>(this IServiceCollection collection);
    public static IServiceCollection RemoveAll(this IServiceCollection collection, Type ServiceType)
    {
        for (int i = collection.Count - 1; i >= 0; i--)
        {
            ServiceDescriptor? descriptor = collection[i];
            // 根据服务注册类型删除所有 ServiceDescriptor
            if (descriptor.ServiceType == serviceType)
            {
                collection.RemoveAt(i);
            }
        }

        ...
    }
}
```

- ServiceCollectionServiceExtensions  

```C#
// 使用服务类型、实现类型、实现工厂、实例等参数创建 ServiceDescriptor 注册服务的扩展方法
// 内部最终调用 ICollection<T>.Add 方法添加 ServiceDescriptor
public static class ServiceCollectionServiceExtensions
{
    // 内部大部分最终调用 Add 扩展方法
    // 泛型方法需要满足 where TImplementation : class, TService 泛型约束
    public static IServiceCollection AddTransient<...>(this IServiceCollection services, ...);
    public static IServiceCollection AddScoped<...>(this IServiceCollection services, ...);
    public static IServiceCollection AddSingleton<...>(this IServiceCollection services, ...);

    private static IServiceCollection Add(
        IServiceCollection collection, 
        Type serviceType, 
        Type implementationType, 
        ServiceLifetime lifetime)
    {
        var descriptor = new ServiceDescriptor(serviceType, implementationType, lifetime);
        collection.Add(descriptor);
        return collection;
    }
 
    private static IServiceCollection Add(
        IServiceCollection collection,
        Type serviceType,
        Func<IServiceProvider, object> implementationFactory,
        ServiceLifetime lifetime)
    {
        var descriptor = new ServiceDescriptor(serviceType, implementationFactory, lifetime);
        collection.Add(descriptor);
        return collection;
    }
}
```

## 服务消费

- ServiceCollectionContainerBuilderExtensions  

```C#
// 使用 IServiceCollection 构建默认 ServiceProvider 的扩展方法
public static class ServiceCollectionContainerBuilderExtensions
{
    public static ServiceProvider BuildServiceProvider(this IServiceCollection services)
    {
        return BuildServiceProvider(services, ServiceProviderOptions.Default);
    }

    public static ServiceProvider BuildServiceProvider(this IServiceCollection services, bool validateScopes)
    {
        return services.BuildServiceProvider(new ServiceProviderOptions { ValidateScopes = validateScopes });
    }

    public static ServiceProvider BuildServiceProvider(this IServiceCollection services, ServiceProviderOptions options)
    {
        if (services is null)
        {
            throw new ArgumentNullException(nameof(services));
        }
        if (options is null)
        {
            throw new ArgumentNullException(nameof(options));
        }
 
        return new ServiceProvider(services, options);
    }
}
```

- ServiceProviderOptions  

```C#
// 配置默认 ServiceProviderOptions 选项
public class ServiceProviderOptions
{
    // 默认行为，不验证服务范围并且所有服务是否可以被解析不在 ServiceProvider 构造函数执行时验证
    internal static readonly ServiceProviderOptions Default = new ServiceProviderOptions();

    // 验证服务范围
    // 即不能由根容器解析 Scoped 生命周期的服务
    public bool ValidateScopes { get; set; }

    // 如果设置为 true，则在 ServiceProvider 构造函数执行时验证所有已注册服务的服务范围
    // 否则，则会在实际通过 GetService 方法获取服务实例时验证服务范围
    public bool ValidateOnBuild { get; set; }
}
```

- IServiceProvider  

```C#
// IoC 容器的抽象表示
// 只提供唯一的 GetService 方法
public interface IServiceProvider
{
    object? GetService(Type serviceType);
}
```

- ServiceProvider  

```C#
// IServiceProvider 的默认实现
public sealed class ServiceProvider : IServiceProvider, IDisposable, IAsyncDisposable
{
    // 服务范围验证器
    // 继承 CallSiteVisitor<TArgument, TResult>
    // 用来验证是否存在通过根容器解析 Scoped 生命周期的服务
    private readonly CallSiteValidator? _callSiteValidator;

    // 服务解析引擎
    // 核心方法 RealizeService 的作用是根据 ServiceCallSite 创建 Func<ServiceProviderEngineScope, object?>> 委托
    // 实现类型：
    // 1. CompiledServiceProviderEngine
    //      DynamicServiceProviderEngine
    // 2. ExpressionsServiceProviderEngine
    // 3. ILEmitServiceProviderEngine
    // 4. RuntimeServiceProviderEngine
    internal ServiceProviderEngine _engine;

    // 如果 _realizedServices 没有对应服务类型的 Func<ServiceProviderEngineScope, object?> 委托就通过 _createServiceAccessor 创建
    private readonly Func<Type, Func<ServiceProviderEngineScope, object?>> _createServiceAccessor;
    // 用来缓存服务类型和其对应的 Func<ServiceProviderEngineScope, object?> 委托
    // 当缓存中没有对应的服务类型时，将通过 _createServiceAccessor 创建 Func<ServiceProviderEngineScope, object?> 委托
    // 服务实例最终是利用 Func<ServiceProviderEngineScope, object?> 委托来创建的
    private ConcurrentDictionary<Type, Func<ServiceProviderEngineScope, object?>> _realizedServices;

    // ServiceCallSite 工厂
    internal CallSiteFactory CallSiteFactory { get; }

    // 根容器（服务范围）
    internal ServiceProviderEngineScope Root { get; }

    internal ServiceProvider(ICollection<ServiceDescriptor> serviceDescriptors, ServiceProviderOptions options)
    {
        // 创建根容器
        Root = new ServiceProviderEngineScope(this, isRootScope: true);

        // 根据运行时情况决定服务解析引擎的实现类型
        _engine = GetEngine();

        // 使用 CreateServiceAccessor 方法创建 Func<Type, Func<ServiceProviderEngineScope, object?>> 委托
        _createServiceAccessor = CreateServiceAccessor;
        _realizedServices = new ConcurrentDictionary<Type, Func<ServiceProviderEngineScope, object?>>();

        // 使用注册的 ServiceDescriptor 集合创建 ServiceCallSite 工厂
        CallSiteFactory = new CallSiteFactory(serviceDescriptors);

        // 添加三个特殊服务类型的 ServiceCallSite
        
        // 针对 IServiceProvider 的 ServiceProviderCallSite
        // 本质是在使用 Func<ServiceProviderEngineScope, object?> 解析服务实例时根据传入的 ServiceProviderEngineScope 决定
        CallSiteFactory.Add(typeof(IServiceProvider), new ServiceProviderCallSite());
        // 针对 IServiceScopeFactory 的 ConstantCallSite
        // 使用 ServiceProviderEngineScope 根容器自己作为服务解析实例提供
        CallSiteFactory.Add(typeof(IServiceScopeFactory), new ConstantCallSite(typeof(IServiceScopeFactory), Root));
        // 针对 IServiceProviderIsService 的 ConstantCallSite
        // 使用 CallSiteFactory 作为服务解析实例提供
        CallSiteFactory.Add(typeof(IServiceProviderIsService), new ConstantCallSite(typeof(IServiceProviderIsService), CallSiteFactory));

        // 判断是否启用服务范围验证
        if (options.ValidateScopes)
        {
            // 启用则创建服务范围验证器
            _callSiteValidator = new CallSiteValidator();
        }

        // 判断是否现在立即验证所有的服务注册可以得到对应的 ServiceCallSite
        // 而不是等到调用 IServiceProvider.GetService 方法解析服务实例时验证
        if (options.ValidateOnBuild)
        {
            foreach (ServiceDescriptor serviceDescriptor in serviceDescriptors)
            {
                try
                {
                    ValidateService(serviceDescriptor);
                }
                catch (Exception e)
                {
                    exceptions ??= new List<Exception>();
                    exceptions.Add(e);
                }
            }
        }

        ...
    }

    // 验证服务注册可以得到对应的 ServiceCallSite
    // 否则抛出 InvalidOperationException 异常
    private void ValidateService(ServiceDescriptor descriptor)
    {
        // 此时无法验证使用泛型开放类型注册的服务，只能等到实际解析服务实例时验证
        if (descriptor.ServiceType.IsGenericType && !descriptor.ServiceType.IsConstructedGenericType)
        {
            return;
        }

        try
        {
            // 尝试得到对应服务注册的 ServiceCallSite
            // 使用 CallSiteChain 来检查是否存在循环依赖问题，存在则抛出 InvalidOperationException 异常
            ServiceCallSite? callSite = CallSiteFactory.GetCallSite(descriptor, new CallSiteChain());
            if (callSite != null)
            {
                // 如果服务范围验证器被创建
                // 验证是否存在通过根容器解析 Scoped 生命周期的服务
                _callSiteValidator?.ValidateCallSite(callSite);
            }
        }
        catch (Exception e)
        {
            throw new InvalidOperationException($"Error while validating the service descriptor '{descriptor}': {e.Message}", e);
        }
    }

    // 实现 IServiceProvider
    // 根据服务类型解析服务实例
    public object? GetService(Type serviceType) => GetService(serviceType, Root);

    // 内部实际解析服务实例的方法
    // 需要传入实际用来解析服务实例的 ServiceProviderEngineScope
    internal object? GetService(Type serviceType, ServiceProviderEngineScope serviceProviderEngineScope)
    {
        // 创建对应服务的 Func<ServiceProviderEngineScope, object?> 委托
        Func<ServiceProviderEngineScope, object?> realizedService = _realizedServices.GetOrAdd(serviceType, _createServiceAccessor);
        // 如果服务范围验证器被创建
        // 验证当前服务是否是 Scoped 生命周期服务，并且通过根容器解析的
        _callSiteValidator?.ValidateResolution(serviceType, serviceProviderEngineScope, Root);
        // 使用 Func<ServiceProviderEngineScope, object?> 委托和 serviceProviderEngineScope 解析服务
        var result = realizedService.Invoke(serviceProviderEngineScope);
        return result;
    }

    private Func<ServiceProviderEngineScope, object?> CreateServiceAccessor(Type serviceType)
    {
        // 根据服务类型得到对应的 ServiceCallSite
        // 使用 CallSiteChain 来检查是否存在循环依赖问题，存在则抛出 InvalidOperationException 异常
        ServiceCallSite? callSite = CallSiteFactory.GetCallSite(serviceType, new CallSiteChain());
        if (callSite != null)
        {
            // 验证是否存在通过根容器解析 Scoped 生命周期的服务
            _callSiteValidator?.ValidateCallSite(callSite);

            // 如果服务缓存位置是根容器
            if (callSite.Cache.Location == CallSiteResultCacheLocation.Root)
            {
                // 使用 CallSiteRuntimeResolver 直接解析服务
                object? value = CallSiteRuntimeResolver.Instance.Resolve(callSite, Root);
                // 下次解析对应服务实例时直接返回，属于针对 Singleton 生命周期服务的优化错误，用以提高性能
                return scope => value;
            }

            // 使用解析引擎得到 Func<ServiceProviderEngineScope, object?> 委托
            return _engine.RealizeService(callSite);
        }

        return _ => null;
    }

    private ServiceProviderEngine GetEngine()
    {
        ServiceProviderEngine engine;

#if NETFRAMEWORK || NETSTANDARD2_0
            // 动态决定解析服务方式
            engine = new DynamicServiceProviderEngine(this);
#else
        if (RuntimeFeature.IsDynamicCodeCompiled)
        {
            engine = new DynamicServiceProviderEngine(this);
        }
        else
        {
            // 反射方式解析服务
            engine = RuntimeServiceProviderEngine.Instance;
        }
#endif
        return engine;
    }
}
```

- CompiledServiceProviderEngine  

```C#
// 服务解析引擎抽象表示
// 如果编译时使用的目标框架支持 ILEmit
// 则返回的 Func<ServiceProviderEngineScope, object?> 委托方法将通过运行时编织的方式生成获取服务实例的 IL 指令
// 否则使用 Expression 表达式树的方式生成获取服务实例
internal abstract class CompiledServiceProviderEngine : ServiceProviderEngine
{
#if IL_EMIT
    public ILEmitResolverBuilder ResolverBuilder { get; }
#else
    public ExpressionResolverBuilder ResolverBuilder { get; }
#endif

    [RequiresDynamicCode("Creates DynamicMethods")]
    public CompiledServiceProviderEngine(ServiceProvider provider)
    {
        ResolverBuilder = new(provider);
    }

    // 构建新的 Func<ServiceProviderEngineScope, object?> 委托用于替换
    public override Func<ServiceProviderEngineScope, object?> RealizeService(ServiceCallSite callSite) => ResolverBuilder.Build(callSite);
}
```

- DynamicServiceProviderEngine  

```C#
// 动态服务解析引擎
// 根据服务解析的次数决定是否从反射方式替换为性能更高的 ILEmit 方式得到服务
internal sealed class DynamicServiceProviderEngine : CompiledServiceProviderEngine
{
    private readonly ServiceProvider _serviceProvider;
 
    public DynamicServiceProviderEngine(ServiceProvider serviceProvider): base(serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
 
    public override Func<ServiceProviderEngineScope, object?> RealizeService(ServiceCallSite callSite)
    {
        return scope =>
        {
            var result = CallSiteRuntimeResolver.Instance.Resolve(callSite, scope);
            
            // 如果对某个服务类型的 ServiceCallSite 有多于一次的获取请求，则通过异步方式替换使用 ILEmit 方式解析服务
            if (Interlocked.Increment(ref callCount) == 2)
            {
                _ = ThreadPool.UnsafeQueueUserWorkItem(_ =>
                {
                    try
                    {
                        // 将原来 DynamicServiceProviderEngine.RealizeService 方法返回的 Func<ServiceProviderEngineScope, object?> 委托
                        // 替换为 ILEmitResolverBuilder.Builder 方法返回的 Func<ServiceProviderEngineScope, object?> 委托
                        // 或者为 ExpressionResolverBuilder.Builder 方法返回的 Func<ServiceProviderEngineScope, object?> 委托
                        // 具体使用哪种方法根据编译时的目标框架决定
                        _serviceProvider.ReplaceServiceAccessor(callSite, base.RealizeService(callSite));
                    }
                    catch (Exception ex)
                    {
                        DependencyInjectionEventSource.Log.ServiceRealizationFailed(ex, _serviceProvider.GetHashCode());
 
                        Debug.Fail($"We should never get exceptions from the background compilation.{Environment.NewLine}{ex}");
                    }
                },
                null);
            }
 
            return result;
        };
    }
}
```

- IServiceScope  

```C#
// 服务范围的抽象表示
public interface IServiceScope
{
    IServiceProvider ServiceProvider { get; }
}
```

- IServiceScopeFactory  

```C#
// 服务范围工厂的抽象表示
public interface IServiceScopeFactory
{
    IServiceScope CreateScope();
}
```

- ServiceProviderEngineScope  

```C#
// 集服务容器、服务范围、服务范围工厂三种角色于一体
// 扮演服务范围工厂时，通过 CreateScope 方式创建新的服务范围（服务容器）
// 每个 ServiceProviderEngineScope 直接引用在逻辑上扮演根容器的 ServiceProvider 而不是调用 CreateScope 方法的 ServiceProviderEngineScope
// 即 ServiceProviderEngineScope 之间不存在树形依赖结构
internal sealed class ServiceProviderEngineScope : IServiceScope, IServiceProvider, IAsyncDisposable, IServiceScopeFactory
{
    // 是否已经执行 DisposeAsync 或 Dispose 方法
    private bool _disposed;
    // 由当前容器解析的，并且实现了 IDisposable 或 IAsyncDisposable 接口的服务，则会保存在此集合中
    private List<object>? _disposables;

    public ServiceProviderEngineScope(ServiceProvider provider, bool isRootScope)
    {
        ResolvedServices = new Dictionary<ServiceCacheKey, object?>();
        RootProvider = provider;
        IsRootScope = isRootScope;
    }

    // 所有 Scoped 生命周期的服务实例保存在此范围容器的字典中
    // ServiceProvider 内部引用的 ServiceProviderEngineScope 是根容器
    // 所有 singleton 生命周期的服务实例实际保存在 ServiceCallSite 的 Value 属性中，而不会使用此字典
    internal Dictionary<ServiceCacheKey, object?> ResolvedServices { get; }

    // 同步锁（在并发情况下对 ResolvedServices 的同步访问）
    internal object Sync => ResolvedServices;
    
    // 是否是根容器
    public bool IsRootScope { get; }
    
    // 引用默认的根容器 ServiceProvider
    internal ServiceProvider RootProvider { get; }

    // 通过服务类型得到服务实例
    public object? GetService(Type serviceType)
    {
        if (_disposed)
        {
            ThrowHelper.ThrowObjectDisposedException();
        }

        // 实际的服务解析交由 ServiceProvider 执行
        return RootProvider.GetService(serviceType, this);
    }
    
    // 扮演服务容器
    public IServiceProvider ServiceProvider => this;
    
    // 扮演服务范围工厂
    public IServiceScope CreateScope() => RootProvider.CreateScope();

    // 捕获解析的服务是否需要放入 _disposed 集合
    internal object? CaptureDisposable(object? service)
    {
        ...
    }

    // 支持异步方式执行释放操作
    // 实现 IAsyncDisposable 接口的服务
    // 如果执行 DisposeAsync 方法非同步完成，则通过异步方式执行
    // 目的是如果所有服务实例的释放全部同步完成可以避免在运行时创建状态机
    public ValueTask DisposeAsync()
    {
        try
        {
            for (int i = toDispose.Count - 1; i >= 0; i--)
            {
                object disposable = toDispose[i];
                if (disposable is IAsyncDisposable asyncDisposable)
                {
                    ValueTask vt = asyncDisposable.DisposeAsync();
                    // 非同步完成
                    if (!vt.IsCompletedSuccessfully)
                    {
                        // 剩余的服务使用异步方式执行释放
                        return Await(i, vt, toDispose);
                    }

                    // 同步完成，继续循环
                    vt.GetAwaiter().GetResult();
                }
                else
                {
                    ((IDisposable)disposable).Dispose();
                }
            }
        }
        catch (Exception ex)
        {
            return new ValueTask(Task.FromException(ex));
        }

        return default;

        // 剩余的服务通过异步方式执行释放
        static async ValueTask Await(int i, ValueTask vt, List<object> toDispose)
        {
            // 等待第一个非同步完成的释放操作
            await vt.ConfigureAwait(false);
            i--;

            for (; i >= 0; i--)
            {
                object disposable = toDispose[i];
                if (disposable is IAsyncDisposable asyncDisposable)
                {
                    await asyncDisposable.DisposeAsync().ConfigureAwait(false);
                }
                else
                {
                    ((IDisposable)disposable).Dispose();
                }
            }
        }
    }
}
```

- CallSiteFactory  

```C#
// 用来创建对应服务的 ServiceCallSite 工厂
internal sealed class CallSiteFactory : IServiceProviderIsService
{
    // 默认槽位
    private const int DefaultSlot = 0;
    // 所有注册服务的描述集合
    private readonly ServiceDescriptor[] _descriptors;
    // ServiceCallSite 缓存表
    // 通过 ServiceCacheKey 保证 ServiceCallSite 的唯一性
    private readonly ConcurrentDictionary<ServiceCacheKey, ServiceCallSite> _callSiteCache 
        = new ConcurrentDictionary<ServiceCacheKey, ServiceCallSite>();
    // 服务注册类型查找表
    // 将相同注册服务的所有 ServiceDescriptor 封装为 ServiceDescriptorCacheItem
    private readonly Dictionary<Type, ServiceDescriptorCacheItem> _descriptorLookup = new Dictionary<Type, ServiceDescriptorCacheItem>();
    // 用于相同服务类型并发创建 ServiceCallSite 时的同步锁
    private readonly ConcurrentDictionary<Type, object> _callSiteLocks = new ConcurrentDictionary<Type, object>();

    public CallSiteFactory(ICollection<ServiceDescriptor> descriptors)
    {
        // 拷贝服务描述
        _descriptors = new ServiceDescriptor[descriptors.Count];
        descriptors.CopyTo(_descriptors, 0);

        // 遍历 ServiceDescriptor 集合，构建服务注册类型查找表
        Populate();
    }

    // 构建服务注册类型查找表
    private void Populate()
    {
        foreach (ServiceDescriptor descriptor in _descriptors)
        {
            Type serviceType = descriptor.ServiceType;
            // 如果服务注册类型是开放泛型类型（未被构建的）
            if (serviceType.IsGenericTypeDefinition)
            {
                Type? implementationType = descriptor.ImplementationType;

                // 服务注册类型是开放泛型类型时实现注册类型也必须是开放泛型类型，否则抛出 ArgumentException 异常
                if (implementationType == null || !implementationType.IsGenericTypeDefinition)
                {
                    throw new ArgumentException(
                        SR.Format(SR.OpenGenericServiceRequiresOpenGenericImplementation, serviceType),
                        "descriptors");
                }

                // 所以实现注册类型不能是抽象类型或接口等开放类型（无法实例化），否则抛出 ArgumentException 异常
                if (implementationType.IsAbstract || implementationType.IsInterface)
                {
                    throw new ArgumentException(
                        SR.Format(SR.TypeCannotBeActivated, implementationType, serviceType));
                }

                Type[] serviceTypeGenericArguments = serviceType.GetGenericArguments();
                Type[] implementationTypeGenericArguments = implementationType.GetGenericArguments();
                // 泛型开放类型的泛型参数数量必须一致，否则抛出 ArgumentException 异常
                if (serviceTypeGenericArguments.Length != implementationTypeGenericArguments.Length)
                {
                    throw new ArgumentException(
                        SR.Format(SR.ArityOfOpenGenericServiceNotEqualArityOfOpenGenericImplementation, serviceType, implementationType), "descriptors");
                }
            }
            else if (descriptor.ImplementationInstance == null && descriptor.ImplementationFactory == null)
            {
                // 服务注册类型是封闭类型并且实现实例和实现工厂为 null 时必须具有实现注册类型
                Debug.Assert(descriptor.ImplementationType != null);
                Type implementationType = descriptor.ImplementationType;

                // 实现注册类型不能是开放泛型类型、抽象类型、接口这些开放类型，否则抛出 ArgumentException 异常
                if (implementationType.IsGenericTypeDefinition ||
                    implementationType.IsAbstract ||
                    implementationType.IsInterface)
                {
                    throw new ArgumentException(
                        SR.Format(SR.TypeCannotBeActivated, implementationType, serviceType));
                }
            }

            // 相同服务注册类型的多个 ServiceDescriptor 会被封装为 ServiceDescriptorCacheItem
            // 并且具有如下引用逻辑
            // 1. ServiceDescriptorCacheItem.Last 指向最后添加的服务注册类型
            // 2. ServiceDescriptorCacheItem._item 指向最早添加的服务注册类型
            // 3. ServiceDescriptorCacheItem._items 保存除 ServiceDescriptorCacheItem._item 以外的注册链
            Type cacheKey = serviceType;
            _descriptorLookup.TryGetValue(cacheKey, out ServiceDescriptorCacheItem cacheItem);
            _descriptorLookup[cacheKey] = cacheItem.Add(descriptor);
        }
    }

    // 根据服务类型和默认槽 0（基于最后注册的 ServiceDescriptor）得到 ServiceCallSite
    internal ServiceCallSite? GetCallSite(Type serviceType, CallSiteChain callSiteChain) =>
        _callSiteCache.TryGetValue(new ServiceCacheKey(serviceType, DefaultSlot), out ServiceCallSite? site) ? site :
        CreateCallSite(serviceType, callSiteChain);
    
    // 根据 ServiceDescriptor 中的的服务注册类型得到 ServiceCallSite
    // 所以不支持 ServiceDescriptor 的服务注册类型是开放泛型类型
    // 调用此方法前需要判断 ServiceDescriptor 的服务注册类型是否为开放泛型类型
    // 此方法目前只在 ServiceProvider 构造函数中启用 ServiceProviderOptions.ValidateOnBuild 选项时才会被调用
    internal ServiceCallSite? GetCallSite(ServiceDescriptor serviceDescriptor, CallSiteChain callSiteChain)
    {
        if (_descriptorLookup.TryGetValue(serviceDescriptor.ServiceType, out ServiceDescriptorCacheItem descriptor))
        {
            // 由于使用的是 ServiceDescriptor 中的服务注册类型尝试解析得到 ServiceCallSite
            // 所以只支持针对封闭类型的 TryCreateExact 方法
            // 因为服务类型是开放类型时无法得到 ServiceCallSite
            return TryCreateExact(serviceDescriptor, serviceDescriptor.ServiceType, callSiteChain, descriptor.GetSlot(serviceDescriptor));
        }
 
        Debug.Fail("_descriptorLookup didn't contain requested serviceDescriptor");
        return null;
    }

    private ServiceCallSite? CreateCallSite(Type serviceType, CallSiteChain callSiteChain)
    {
        if (!_stackGuard.TryEnterOnCurrentStack())
        {
            return _stackGuard.RunOnEmptyStack(CreateCallSite, serviceType, callSiteChain);
        }

        // 针对每个服务类型得到同步锁
        var callsiteLock = _callSiteLocks.GetOrAdd(serviceType, static _ => new object());

        // 针对每个服务类型创建 ServiceCallSite 的过程需要同步完成
        // 比如如下的服务依赖关系 C 和 E 同时依赖 D、A：
        // C -> D -> A
        // E -> D -> A
        // 在并发创建服务 C、E 的 ServiceCallSite 时，需要保证他们依赖的服务 D、A 的 ServiceCallSite 是同一个实例
        lock (callsiteLock)
        {
            // 检查循环依赖
            callSiteChain.CheckCircularDependency(serviceType);

            // 通过服务类型得到 ServiceCallSite 通过三种方式
            // 1. 针对封闭类型的 TryCreateExact
            // 2. 针对开放泛型类型的 TryCreateOpenGeneric
            // 3. 针对 IEnumerable<> 类型的 TryCreateEnumerable
            ServiceCallSite? callSite = TryCreateExact(serviceType, callSiteChain) ??
                                    TryCreateOpenGeneric(serviceType, callSiteChain) ??
                                    TryCreateEnumerable(serviceType, callSiteChain);

            return callSite;
        }
    }

    // 针对封闭类型创建 ServiceCallSite
    private ServiceCallSite? TryCreateExact(Type serviceType, CallSiteChain callSiteChain)
    {
        // 根据服务注册类型查找表得到 ServiceDescriptor
        if (_descriptorLookup.TryGetValue(serviceType, out ServiceDescriptorCacheItem descriptor))
        {
            // 尝试使用最后注册的 ServiceDescriptor 和默认默认槽 0 创建 ServiceCallSite
            return TryCreateExact(descriptor.Last, serviceType, callSiteChain, DefaultSlot);
        }
 
        return null;
    }

    private ServiceCallSite? TryCreateExact(ServiceDescriptor descriptor, Type serviceType, CallSiteChain callSiteChain, int slot)
    {
        // 封闭类型的服务注册类型和服务类型必须相同
        if (serviceType == descriptor.ServiceType)
        {
            // 利用服务类型和指定槽位创建 ServiceCacheKey
            ServiceCacheKey callSiteKey = new ServiceCacheKey(serviceType, slot);
            // 已经存在直接返回
            if (_callSiteCache.TryGetValue(callSiteKey, out ServiceCallSite? serviceCallSite))
            {
                return serviceCallSite;
            }

            ServiceCallSite callSite;
            // 创建结果缓存
            // 用来指明利用 ServiceCallSite 解析服务实例后的保存位置
            var lifetime = new ResultCache(descriptor.Lifetime, serviceType, slot);
            if (descriptor.ImplementationInstance != null)
            {
                // 根据实现实例得到 ConstantCallSite
                // 创建 ConstantCallSite 不需要使用 ResultCache 指明实例保存位置
                // 因为已经将 ServiceDescriptor.ImplementationInstance 的值保存到 ServiceCallSite.Value 中
                // 本质上内部会创建一个 ResultCache.None 的 ResultCache，其 ResultCache.Location 属性的值为 CallSiteResultCacheLocation.None
                callSite = new ConstantCallSite(descriptor.ServiceType, descriptor.ImplementationInstance);
            }
            else if (descriptor.ImplementationFactory != null)
            {
                // 根据实现工厂得到 FactoryCallSite
                callSite = new FactoryCallSite(lifetime, descriptor.ServiceType, descriptor.ImplementationFactory);
            }
            else if (descriptor.ImplementationType != null)
            {
                // 根据实现类型创建 ConstructorCallSite
                // 使用 ConstructorCallSite 解析服务时可能存在针对构造函数参数类型的服务解析
                // 需要检查是否存在循环依赖问题
                callSite = CreateConstructorCallSite(lifetime, descriptor.ServiceType, descriptor.ImplementationType, callSiteChain);
            }
            else
            {
                throw new InvalidOperationException(SR.InvalidServiceDescriptor);
            }

            // 根据 ServiceCacheKey 缓存 ServiceCallSite
            return _callSiteCache[callSiteKey] = callSite;
        }

        return null;
    }

    // 创建 ConstructorCallSite
    private ServiceCallSite CreateConstructorCallSite(
            ResultCache lifetime,
            Type serviceType,
            Type implementationType,
            CallSiteChain callSiteChain)
    {
        try
        {
            // 先将服务类型和实现类型添加到 callSiteChain 中
            callSiteChain.Add(serviceType, implementationType);
            // 得到实现类型的公开实例构造函数（BindingFlags.Public | BindingFlags.Instance）
            ConstructorInfo[] constructors = implementationType.GetConstructors();

            ServiceCallSite[]? parameterCallSites = null;

            // 没有候选构造函数，则抛出 InvalidOperationException 异常
            if (constructors.Length == 0)
            {
                throw new InvalidOperationException(SR.Format(SR.NoConstructorMatch, implementationType));
            }
            else if (constructors.Length == 1)
            {
                // 唯一的候选构造函数，即最优构造函数
                ConstructorInfo constructor = constructors[0];
                // 得到构造函数参数的定义元数据
                ParameterInfo[] parameters = constructor.GetParameters();
                if (parameters.Length == 0)
                {
                    // 没有参数
                    // 即存在默认构造函数
                    return new ConstructorCallSite(lifetime, serviceType, constructor);
                }

                // 构造函数存在参数
                // 根据所有参数类型得到对应的 ServiceCallSite
                // 如果存在无法解析的参数类型，则抛出异常
                parameterCallSites = CreateArgumentCallSites(
                    implementationType,
                    callSiteChain,
                    parameters,
                    throwIfCallSiteNotFound: true)!;

                return new ConstructorCallSite(lifetime, serviceType, constructor, parameterCallSites);
            }

            // 如果候选构造函数多于一个，需要选择最优的构造函数
            // 最优匹配原则：
            // 1. 优先选择参数列表最长的
            // 2. 所有参数类型可以通过服务注册类型查找表找到，并且可以得到 ServiceCallSite
            // 3. 最优构造函数的参数列表是所有候选构造函数参数列表的超集

            // 根据构造函数参数长度进行降序排序
            Array.Sort(constructors,
                (a, b) => b.GetParameters().Length.CompareTo(a.GetParameters().Length));
            
            ConstructorInfo? bestConstructor = null;
            HashSet<Type>? bestConstructorParameterTypes = null;
            for (int i = 0; i < constructors.Length; i++)
            {
                ParameterInfo[] parameters = constructors[i].GetParameters();

                // 根据所有参数类型得到对应的 ServiceCallSite
                // 当前还无法确定候选构造函数是否是最优构造函数，先不抛出异常
                // 果存在无法解析的参数类型，则返回 null
                ServiceCallSite[]? currentParameterCallSites = CreateArgumentCallSites(
                    implementationType,
                    callSiteChain,
                    parameters,
                    throwIfCallSiteNotFound: false);

                // currentParameterCallSites != null 表明所有参数类型可以解析
                if (currentParameterCallSites != null)
                {
                    // 因为数组元素已经降序排列（最长参数列表）
                    // 所以首次参数解析成功的构造函数即为候选最优构造函数
                    if (bestConstructor == null)
                    {
                        bestConstructor = constructors[i];
                        parameterCallSites = currentParameterCallSites;
                    }
                    else
                    {
                        // 将候选最优构造函数的参数类型提取出来
                        // 用来和本次候选构造函数参数对比
                        if (bestConstructorParameterTypes == null)
                        {
                            bestConstructorParameterTypes = new HashSet<Type>();
                            foreach (ParameterInfo p in bestConstructor.GetParameters())
                            {
                                bestConstructorParameterTypes.Add(p.ParameterType);
                            }
                        }

                        foreach (ParameterInfo p in parameters)
                        {
                            // 后续的候选构造函数的参数如果存在参数类型不在候选最优构造函数的参数列表中（不满足子集原则），则抛出 InvalidOperationException 异常
                            if (!bestConstructorParameterTypes.Contains(p.ParameterType))
                            {
                                throw new InvalidOperationException(string.Join(
                                    Environment.NewLine,
                                    SR.Format(SR.AmbiguousConstructorException, implementationType),
                                    bestConstructor,
                                    constructors[i]));
                            }
                        }
                    }
                }
            }

            // 没有找到最优构造函数，则抛出 InvalidOperationException 异常
            if (bestConstructor == null)
            {
                throw new InvalidOperationException(
                    SR.Format(SR.UnableToActivateTypeException, implementationType));
            }
            else
            {
                // 多于一个公开实例构造函数的类型至少存在一个非默认构造函数
                // 所以一定会执行参数解析，要么属于候选最优构造函数，要门不满足子集原则
                // 所以此处可以用断言判断是否解析参数列表成功
                Debug.Assert(parameterCallSites != null);
                return new ConstructorCallSite(lifetime, serviceType, bestConstructor, parameterCallSites);
            }
        }
        finally
        {
            // 完成后从 callSiteChain 移除服务类型
            callSiteChain.Remove(serviceType);
        }
    }

    // 根据参数类型创建 ServiceCallSite
    private ServiceCallSite[]? CreateArgumentCallSites(
            Type implementationType,
            CallSiteChain callSiteChain,
            ParameterInfo[] parameters,
            bool throwIfCallSiteNotFound)
    {
        var parameterCallSites = new ServiceCallSite[parameters.Length];
        for (int index = 0; index < parameters.Length; index++)
        {
            // 得到参数类型
            Type parameterType = parameters[index].ParameterType;
            // 使用参数类型作为服务类型调用 GetCallSite 得到 ServiceCallSite
            ServiceCallSite? callSite = GetCallSite(parameterType, callSiteChain);

            // 没有得到 ServiceCallSite 时尝试得到服务类型的默认值
            // 注意：只生成值类型（不包括可空值类型）的默认值
            if (callSite == null && ParameterDefaultValue.TryGetDefaultValue(parameters[index], out object? defaultValue))
            {
                // 使用默认值创建 ConstantCallSite
                callSite = new ConstantCallSite(parameterType, defaultValue);
            }

            if (callSite == null)
            {
                // 没有得到 ServiceCallSite 时是否需要抛出异常
                if (throwIfCallSiteNotFound)
                {
                    throw new InvalidOperationException(SR.Format(SR.CannotResolveService,
                        parameterType,
                        implementationType));
                }

                // 如果不抛出异常，则中断循环直接返回 null
                return null;
            }

            parameterCallSites[index] = callSite;
        }

        return parameterCallSites;
    }

    // 针对开放泛型类型创建 ServiceCallSite
    private ServiceCallSite? TryCreateOpenGeneric(Type serviceType, CallSiteChain callSiteChain)
    {
        // 服务类型必须是被构造的泛型类型（封闭类型）
        // 并且在服务注册类型查找表中存在该开放泛型类型的服务注册
        if (serviceType.IsConstructedGenericType
            && _descriptorLookup.TryGetValue(serviceType.GetGenericTypeDefinition(), out ServiceDescriptorCacheItem descriptor))
        {
            // 尝试使用最后注册的 ServiceDescriptor 和默认默认槽 0 创建 ServiceCallSite
            return TryCreateOpenGeneric(descriptor.Last, serviceType, callSiteChain, DefaultSlot, true);
        }
 
        return null;
    }

    private ServiceCallSite? TryCreateOpenGeneric(ServiceDescriptor descriptor, Type serviceType, CallSiteChain callSiteChain, int slot, bool throwOnConstraintViolation)
    {
        // 服务类型必须是被构造的泛型类型（封闭类型）
        // 并且服务类型的泛型类型定义（开放泛型类型）与服务注册类型相同
        if (serviceType.IsConstructedGenericType &&
            serviceType.GetGenericTypeDefinition() == descriptor.ServiceType)
        {
            // 利用服务类型和槽位创建 ServiceCacheKey
            ServiceCacheKey callSiteKey = new ServiceCacheKey(serviceType, slot);
            // 已经存在直接返回
            if (_callSiteCache.TryGetValue(callSiteKey, out ServiceCallSite? serviceCallSite))
            {
                return serviceCallSite;
            }

            Debug.Assert(descriptor.ImplementationType != null, "descriptor.ImplementationType != null");
            // 创建结果缓存
            var lifetime = new ResultCache(descriptor.Lifetime, serviceType, slot);
            Type closedType;
            try
            {
                // 根据服务类型的泛型实参构建实现注册类型（开放泛型类型）的封闭类型
                closedType = descriptor.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments);
            }
            catch (ArgumentException)
            {
                if (throwOnConstraintViolation)
                {
                    throw;
                }

                return null;
            }

            // 开放泛型类型作为服务注册类型时，创建的 ServiceCallSite 只能是基于构造函数的 ConstructorCallSite
            // 因为需要利用服务类型的泛型实参构建实现注册类型的封闭类型，所以在服务注册时只能通过 ImplementationType 指定实现注册类型
            return _callSiteCache[callSiteKey] = CreateConstructorCallSite(lifetime, serviceType, closedType, callSiteChain);
        }

        return null;
    }

    // 针对 IEnumerable<> 类型创建 ServiceCallSite
    private ServiceCallSite? TryCreateEnumerable(Type serviceType, CallSiteChain callSiteChain)
    {
        // 利用服务类型和槽位创建 ServiceCacheKey
        ServiceCacheKey callSiteKey = new ServiceCacheKey(serviceType, DefaultSlot);
        // 已经存在直接返回
        if (_callSiteCache.TryGetValue(callSiteKey, out ServiceCallSite? serviceCallSite))
        {
            return serviceCallSite;
        }

        try
        {
            // 添加服务类型到 callSiteChain 中
            callSiteChain.Add(serviceType);

            // 确定 IEnumerable<> 的泛型实参是封闭类型
            if (serviceType.IsConstructedGenericType &&
                serviceType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
            {
                // 得到泛型实参的类型
                Type itemType = serviceType.GenericTypeArguments[0];
                // 先假设默认缓存位置是根容器
                CallSiteResultCacheLocation cacheLocation = CallSiteResultCacheLocation.Root;

                var callSites = new List<ServiceCallSite>();

                // 基于前面的判断此处 IEnumerable<> 的泛型实参是封闭类型（封闭泛型类型或非泛型类型）
                // 如果是非泛型类型，利用 itemType 查找服务注册类型查找表得到 ServiceDescriptorCacheItem
                if (!itemType.IsConstructedGenericType &&
                    _descriptorLookup.TryGetValue(itemType, out ServiceDescriptorCacheItem descriptors))
                {
                    // 从最早注册的 ServiceDescriptor 开始遍历
                    // 所以对于非泛型类型，越早注册的 ServiceDescriptor，最终解析得到的实例会出现在返回数组的前面
                    for (int i = 0; i < descriptors.Count; i++)
                    {
                        ServiceDescriptor descriptor = descriptors[i];

                        // ServiceDescriptorCacheItem._item 槽位最大，依次递减
                        // 最后添加的 ServiceDescriptorCacheItem.Last 槽位最小为 0
                        int slot = descriptors.Count - i - 1;
                        // 此处一定为非泛型类型，直接调用 TryCreateExact 尝试创建 ServiceCallSite
                        ServiceCallSite? callSite = TryCreateExact(descriptor, itemType, callSiteChain, slot);
                        Debug.Assert(callSite != null);

                        // 使用基础类型值最大的作为最终缓存位置
                        // 基础类型值从小到大依次为 Root -> Scope -> Dispose -> None
                        cacheLocation = GetCommonCacheLocation(cacheLocation, callSite.Cache.Location);
                        callSites.Add(callSite);
                    }
                }
                else
                {
                    // 此处 itemType 一定是被构造的泛型类型（泛型封闭类型）
                    // 不能直接通过服务注册类型查找表得到 ServiceDescriptorCacheItem
                    // 因为可能存在通过开放泛型类型注册的服务
                    int slot = 0;
                    // 从后往前遍历所有 ServiceDescriptor
                    for (int i = _descriptors.Length - 1; i >= 0; i--)
                    {
                        ServiceDescriptor descriptor = _descriptors[i];
                        // 被构造的泛型类型（泛型封闭类型）先尝试通过 TryCreateExact 得到 ServiceCallSite
                        // 如果 TryCreateExact 方法中的判断 descriptor.ServiceType == itemType 为 false，则说明当前 ServiceDescriptor 的服务注册类型是开放泛型类型
                        // 继续通过 TryCreateOpenGeneric 得到 ServiceCallSite
                        ServiceCallSite? callSite = TryCreateExact(descriptor, itemType, callSiteChain, slot) ??
                                    TryCreateOpenGeneric(descriptor, itemType, callSiteChain, slot, false);

                        if (callSite != null)
                        {
                            // 因为是从后往前遍历，所以槽位递增
                            slot++;

                            // 使用基础类型值最大的作为最终缓存位置
                            // 基础类型值从小到大依次为 Root -> Scope -> Dispose -> None
                            cacheLocation = GetCommonCacheLocation(cacheLocation, callSite.Cache.Location);
                            callSites.Add(callSite);
                        }
                    }

                    // 反转列表
                    // 保证越早注册的 ServiceDescriptor，最终解析得到的实例会出现在返回数组的前面
                    callSites.Reverse();
                }


                ResultCache resultCache = ResultCache.None;
                // 如果缓存位置是 Scope 或 Root
                if (cacheLocation == CallSiteResultCacheLocation.Scope || cacheLocation == CallSiteResultCacheLocation.Root)
                {
                    // 创建结果缓存
                    // 具体结果缓存位置由解析过程中得到的每个 ServiceCallSite.Cache.Location 决定
                    resultCache = new ResultCache(cacheLocation, callSiteKey);
                }

                // 创建 IEnumerableCallSite
                return _callSiteCache[callSiteKey] = new IEnumerableCallSite(resultCache, itemType, callSites.ToArray());
            }

            return null;
        }
        finally
        {
            // 完成后从 callSiteChain 移除服务类型
            callSiteChain.Remove(serviceType);
        }
    }

    // 直接添加 ServiceCallSite
    // 针对特殊服务注册
    public void Add(Type type, ServiceCallSite serviceCallSite)
    {
        _callSiteCache[new ServiceCacheKey(type, DefaultSlot)] = serviceCallSite;
    }

    // 表示相同服务注册类型的多个 ServiceDescriptor 组成的链表
    private struct ServiceDescriptorCacheItem
    {
        // 最早添加的 ServiceDescriptor
        private ServiceDescriptor? _item;

        // 除最早添加的 ServiceDescriptor 集合
        private List<ServiceDescriptor>? _items;

        // 从 _item 中得到最后添加的 ServiceDescriptor
        public ServiceDescriptor Last
        {
            get
            {
                if (_items != null && _items.Count > 0)
                {
                    // 返回集合中最后的元素
                    return _items[_items.Count - 1];
                }

                Debug.Assert(_item != null);
                // 如果集合没有元素就返回唯一的最早添加的
                return _item;
            }
        }

        // 添加的 ServiceDescriptor 总数
        public int Count
        {
            get
            {
                if (_item == null)
                {
                    Debug.Assert(_items == null);
                    return 0;
                }

                return 1 + (_items?.Count ?? 0);
            }
        }

        // 根据索引得到 ServiceDescriptor
        public ServiceDescriptor this[int index]
        {
            get
            {
                if (index >= Count)
                {
                    throw new ArgumentOutOfRangeException(nameof(index));
                }

                if (index == 0)
                {
                    return _item!;
                }

                return _items![index - 1];
            }
        }

        // 槽位根据添加顺序的倒序表示
        // 最后添加的槽位为 0
        // 最早添加的槽位为 Count - 1
        public int GetSlot(ServiceDescriptor descriptor)
        {
            if (descriptor == _item)
            {
                return Count - 1;
            }

            if (_items != null)
            {
                int index = _items.IndexOf(descriptor);
                if (index != -1)
                {
                    return _items.Count - (index + 1);
                }
            }

            throw new InvalidOperationException(SR.ServiceDescriptorNotExist);
        }

        // 添加 ServiceDescriptor
        public ServiceDescriptorCacheItem Add(ServiceDescriptor descriptor)
        {
            // 每次添加都初始化新的 ServiceDescriptorCacheItem，保证其不可变性
            var newCacheItem = default(ServiceDescriptorCacheItem);
            if (_item == null)
            {
                Debug.Assert(_items == null);
                newCacheItem._item = descriptor;
            }
            else
            {
                newCacheItem._item = _item;
                newCacheItem._items = _items ?? new List<ServiceDescriptor>();
                newCacheItem._items.Add(descriptor);
            }
            return newCacheItem;
        }
    }
}
```

- ServiceCacheKey  

```C#
// 服务缓存 Key
// 由服务类型和槽位决定
internal readonly struct ServiceCacheKey : IEquatable<ServiceCacheKey>
{
    public static ServiceCacheKey Empty { get; } = new ServiceCacheKey(null, 0);

    // 服务类型
    public Type? Type { get; }

    // 槽位
    public int Slot { get; }

    public ServiceCacheKey(Type? type, int slot)
    {
        Type = type;
        Slot = slot;
    }

    public bool Equals(ServiceCacheKey other) =>
        Type == other.Type && Slot == other.Slot;

    // 重写 Equals
    public override bool Equals([NotNullWhen(true)] object? obj) =>
        obj is ServiceCacheKey other && Equals(other);

    // 重写 GetHashCode
    public override int GetHashCode()
    {
        unchecked
        {
            return ((Type?.GetHashCode() ?? 23) * 397) ^ Slot;
        }
    }
}
```

- CallSiteResultCacheLocation  

```C#
// 结果缓存位置枚举
// 服务根据时的不同生命周期，最终由依赖注入容器创建的服务实例会缓存在不同的服务范围中
internal enum CallSiteResultCacheLocation
{
    // 用 ServiceLifetime.Singleton 生命周期注册的服务，其服务实例会（在逻辑上）缓存在表示根容器的服务范围中
    Root,
    // 用 ServiceLifetime.Scoped 生命周期注册的服务，其服务实例会（在物理上）缓存在表示当前容器的服务范围中
    Scope,
    // 用 ServiceLifetime.Transient 生命周期注册的服务（并且实现了 IDisposable 接口），其服务实例会（在物理上）缓存在表示当前容器的待释放列表中
    Dispose,
    // 用于 ConstantCallSite 的结果缓存位置
    None
}
```

- ResultCache  

```C#
// 服务实例结果缓存
// 在 ServiceCallSite 中根据服务注册的生命周期决定创建的服务实例保存位置
internal struct ResultCache
{   
    // 无缓存
    public static ResultCache None { get; } = new ResultCache(CallSiteResultCacheLocation.None, ServiceCacheKey.Empty);

    internal ResultCache(CallSiteResultCacheLocation lifetime, ServiceCacheKey cacheKey)
    {
        Location = lifetime;
        Key = cacheKey;
    }

    // 不同生命周期对应的结果缓存位置
    public ResultCache(ServiceLifetime lifetime, Type? type, int slot)
    {
        Debug.Assert(lifetime == ServiceLifetime.Transient || type != null);

        switch (lifetime)
        {
            case ServiceLifetime.Singleton:
                Location = CallSiteResultCacheLocation.Root;
                break;
            case ServiceLifetime.Scoped:
                Location = CallSiteResultCacheLocation.Scope;
                break;
            case ServiceLifetime.Transient:
                Location = CallSiteResultCacheLocation.Dispose;
                break;
            default:
                Location = CallSiteResultCacheLocation.None;
                break;
        }
        Key = new ServiceCacheKey(type, slot);
    }

    public CallSiteResultCacheLocation Location { get; set; }

    public ServiceCacheKey Key { get; set; }
}
```

- ServiceCallSite  

```C#
// 实现类型：
// 1. ConstantCallSite 
//    针对常量值或者通过 ServiceDescriptor.ImplementationInstance 注册的服务
//    创建 ConstantCallSite 时，构造函数中会检查 ServiceDescriptor.ImplementationInstance 的实际类型是否继承或实现了服务类型
// 2. ConstructorCallSite
//    通过 ServiceDescriptor.ImplementationType 注册的服务
//    构创建 ConstructorCallSite 时，造函数中会检查 ServiceDescriptor.ImplementationType 是否继承或实现了服务类型
// 3. FactoryCallSite
//    通过 ServiceDescriptor.ImplementationFactory 注册的服务
//    创建 FactoryCallSite 时，不会检查 ServiceDescriptor.ImplementationFactory 返回的实例类型是否继承或实现了服务类型
// 4. IEnumerableCallSite
//    针对 IEnumerable<> 服务消费所创建的 ServiceCallSite
// 5. ServiceProviderCallSite
//    针对 IServiceProvider 服务消费所创建的 ServiceCallSite
internal abstract class ServiceCallSite
{
    protected ServiceCallSite(ResultCache cache)
    {
        Cache = cache;
    }
    
    // 服务类型
    public abstract Type ServiceType { get; }
    // 实现类型
    public abstract Type? ImplementationType { get; }
    // CallSite 类别，分别对应 ServiceCallSite 同名的实现类型
    public abstract CallSiteKind Kind { get; }
    // 结果缓存
    public ResultCache Cache { get; }
    // 保存如下服务实例：
    // 1. 通过 ConstantCallSite 保存服务默认值
    // 2. 通过 ConstantCallSite 保存 ServiceDescriptor.ImplementationInstance
    // 3. 生命周期为 Singleton 的服务
    public object? Value { get; set; }

    // 捕获实现类型实现了 IDisposable 或 IAsyncDisposable 接口的服务
    public bool CaptureDisposable =>
        ImplementationType == null ||
        typeof(IDisposable).IsAssignableFrom(ImplementationType) ||
        typeof(IAsyncDisposable).IsAssignableFrom(ImplementationType);
}
```

- CallSiteVisitor\<,\>  

```C#
// 使用访问者模式读取 ServiceCallSite 解析服务
// 实现类型：
// 1. CallSiteValidator 开启 ServiceProviderOptions 选项中的 ValidateScopes 配置时验证服务范围的有效性
// 2. CallSiteRuntimeResolver 使用反射方式解析服务
// 3. ILEmitResolverBuilder 使用 ILEmit 方式解析服务
// 4. ExpressionResolverBuilder 使用表达式树方式解析服务
internal abstract class CallSiteVisitor<TArgument, TResult>
{
    private readonly StackGuard _stackGuard;

    protected CallSiteVisitor()
    {
        _stackGuard = new StackGuard();
    }

    // 根据不同的结果缓存位置读取 ServiceCallSite
    protected virtual TResult VisitCallSite(ServiceCallSite callSite, TArgument argument)
    {
        if (!_stackGuard.TryEnterOnCurrentStack())
        {
            return _stackGuard.RunOnEmptyStack(VisitCallSite, callSite, argument);
        }

        // 根据不同的结果缓存位置调用对应的方法
        switch (callSite.Cache.Location)
        {
            case CallSiteResultCacheLocation.Root:
                return VisitRootCache(callSite, argument);
            case CallSiteResultCacheLocation.Scope:
                return VisitScopeCache(callSite, argument);
            case CallSiteResultCacheLocation.Dispose:
                return VisitDisposeCache(callSite, argument);
            case CallSiteResultCacheLocation.None:
                return VisitNoCache(callSite, argument);
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    // 根据不同的 CallSite 类别调用对应的方法
    protected virtual TResult VisitCallSiteMain(ServiceCallSite callSite, TArgument argument)
    {
        switch (callSite.Kind)
        {
            case CallSiteKind.Factory:
                return VisitFactory((FactoryCallSite)callSite, argument);
            case CallSiteKind.IEnumerable:
                return VisitIEnumerable((IEnumerableCallSite)callSite, argument);
            case CallSiteKind.Constructor:
                return VisitConstructor((ConstructorCallSite)callSite, argument);
            case CallSiteKind.Constant:
                return VisitConstant((ConstantCallSite)callSite, argument);
            case CallSiteKind.ServiceProvider:
                return VisitServiceProvider((ServiceProviderCallSite)callSite, argument);
            default:
                throw new NotSupportedException(SR.Format(SR.CallSiteTypeNotSupported, callSite.GetType()));
        }
    }

    protected virtual TResult VisitNoCache(ServiceCallSite callSite, TArgument argument)
    {
        return VisitCallSiteMain(callSite, argument);
    }

    protected virtual TResult VisitDisposeCache(ServiceCallSite callSite, TArgument argument)
    {
        return VisitCallSiteMain(callSite, argument);
    }

    protected virtual TResult VisitRootCache(ServiceCallSite callSite, TArgument argument)
    {
        return VisitCallSiteMain(callSite, argument);
    }

    protected virtual TResult VisitScopeCache(ServiceCallSite callSite, TArgument argument)
    {
        return VisitCallSiteMain(callSite, argument);
    }

    protected abstract TResult VisitConstructor(ConstructorCallSite constructorCallSite, TArgument argument);

    protected abstract TResult VisitConstant(ConstantCallSite constantCallSite, TArgument argument);

    protected abstract TResult VisitServiceProvider(ServiceProviderCallSite serviceProviderCallSite, TArgument argument);

    protected abstract TResult VisitIEnumerable(IEnumerableCallSite enumerableCallSite, TArgument argument);

    protected abstract TResult VisitFactory(FactoryCallSite factoryCallSite, TArgument argument);
}
```

- CallSiteRuntimeResolver  

```C#
// 反射方式解析服务
internal sealed class CallSiteRuntimeResolver : CallSiteVisitor<RuntimeResolverContext, object?>
{
    // 单例模式
    public static CallSiteRuntimeResolver Instance { get; } = new();

    private CallSiteRuntimeResolver()
    {
    }

    // 解析服务
    public object? Resolve(ServiceCallSite callSite, ServiceProviderEngineScope scope)
    {
        // 解析的服务范围是根容器，则会尝试直接从 ServiceCallSite.Value 中得到服务，提升性能
        if (scope.IsRootScope && callSite.Value is object cached)
        {
            return cached;
        }

        // 读取 ServiceCallSite
        return VisitCallSite(callSite, new RuntimeResolverContext
        {
            Scope = scope
        });
    }

    // 访问 Root 服务范围解析服务
    protected override object? VisitRootCache(ServiceCallSite callSite, RuntimeResolverContext context)
    {
        // 尝试从 ServiceCallSite.Value 中得到服务，提升性能
        if (callSite.Value is object value)
        {
            return value;
        }

        var lockType = RuntimeResolverLock.Root;
        // 强制将服务范围切换为根容器
        ServiceProviderEngineScope serviceProviderEngine = context.Scope.RootProvider.Root;

        // 在并发访问的情况下，保证同步访问 ServiceCallSite 解析得到单一实例
        lock (callSite)
        {
            // 再次尝试从 ServiceCallSite.Value 中得到服务，因为当前线程可能刚刚从阻塞状态恢复
            if (callSite.Value is object callSiteValue)
            {
                return callSiteValue;
            }

            // 根据不同的 CallSiteKind 解析得到服务实例
            object? resolved = VisitCallSiteMain(callSite, new RuntimeResolverContext
            {
                Scope = serviceProviderEngine,
                // 按位或操作，当前解析上下文添加锁定范围
                AcquiredLocks = context.AcquiredLocks | lockType
            });
            // 捕获服务是否需要放入服务范围的 ServiceProviderEngineScope._disposables 集合中
            serviceProviderEngine.CaptureDisposable(resolved);
            // 服务范围是根容器解析的服务实例实际上并不保存在 ServiceProviderEngineScope.ResolvedServices 字典中
            // 而是保存在 ServiceCallSite 的 Value 属性中
            callSite.Value = resolved;
            return resolved;
        }
    }

    // 访问 Scope 服务范围解析服务
    // 如果 context 中的 Scope 是根容器，则使用 Root 服务范围解析服务
    // 注意：如果没有通过 ServiceProviderOptions.ValidateScopes 选项配置验证服务范围，那么此时的 context.Scope 可能会是根容器，就会发生由根容器解析 Scope 生命周期的服务
    protected override object? VisitScopeCache(ServiceCallSite callSite, RuntimeResolverContext context)
    {
        // 如果当前解析服务的服务范围是根容器，则调用 VisitRootCache
        return context.Scope.IsRootScope ?
            VisitRootCache(callSite, context) :
            VisitCache(callSite, context, context.Scope, RuntimeResolverLock.Scope);
    }

    private object? VisitCache(
        ServiceCallSite callSite, 
        RuntimeResolverContext context, 
        ServiceProviderEngineScope serviceProviderEngine, 
        RuntimeResolverLock lockType)
    {
        bool lockTaken = false;
        object sync = serviceProviderEngine.Sync;
        Dictionary<ServiceCacheKey, object?> resolvedServices = serviceProviderEngine.ResolvedServices;

        // 当前线程首次通过 Visit 访问 ServiceProviderEngineScope.ResolvedServices 时，则需要对 ServiceProviderEngineScope.ResolvedServices 加锁
        // 在同一线程只需对 ServiceProviderEngineScope.ResolvedServices 锁定一次，因为后续的 Visit 操作一定是同步完成的
        // 不同线程对 ServiceProviderEngineScope.ResolvedServices 的访问需要通过锁定 ServiceProviderEngineScope.ResolvedServices 同步访问
        if ((context.AcquiredLocks & lockType) == 0)
        {
            Monitor.Enter(sync, ref lockTaken);
        }

        try
        {
            // 从服务范围的 ServiceProviderEngineScope.ResolvedServices 中尝试得到服务
            if (resolvedServices.TryGetValue(callSite.Cache.Key, out object? resolved))
            {
                return resolved;
            }

            // 根据不同的 CallSiteKind 解析得到服务实例
            resolved = VisitCallSiteMain(callSite, new RuntimeResolverContext
            {
                Scope = serviceProviderEngine,
                // 按位或操作，当前解析上下文添加上锁定范围
                AcquiredLocks = context.AcquiredLocks | lockType
            });

            // 捕获服务是否需要放入服务范围的 ServiceProviderEngineScope._disposables 集合中
            serviceProviderEngine.CaptureDisposable(resolved);
            // 解析得到的服务存入 ServiceProviderEngineScope.ResolvedServices 字典中
            resolvedServices.Add(callSite.Cache.Key, resolved);
            return resolved;
        }
        finally
        {
            // 如果加锁，则释放
            if (lockTaken)
            {
                Monitor.Exit(sync);
            }
        }
    }

    protected override object? VisitDisposeCache(ServiceCallSite transientCallSite, RuntimeResolverContext context)
    {
        // 根据不同的 CallSiteKind 解析得到服务实例
        // 捕获服务是否需要放入服务范围的 ServiceProviderEngineScope._disposables 集合中
        return context.Scope.CaptureDisposable(VisitCallSiteMain(transientCallSite, context));
    }

    // 使用 FactoryCallSite 解析服务实例
    protected override object? VisitFactory(FactoryCallSite factoryCallSite, RuntimeResolverContext context)
    {
        // 使用当前服务范围调用 FactoryCallSite.Factory 委托解析服务实例
        return factoryCallSite.Factory(context.Scope);
    }

    // 使用 ConstantCallSite 解析服务实例
    protected override object? VisitConstant(ConstantCallSite constantCallSite, RuntimeResolverContext context)
    {
        // DefaultValue 就是在创建 ConstantCallSite 时将 ServiceDescriptor.ImplementationInstance 赋值给 ServiceCallSite.Value 属性的值
        return constantCallSite.DefaultValue;
    }

    // 使用 ServiceProviderCallSite 得到服务实例
    protected override object VisitServiceProvider(ServiceProviderCallSite serviceProviderCallSite, RuntimeResolverContext context)
    {
        // 直接返回当前服务范围
        return context.Scope;
    }

    // 使用 ConstructorCallSite 解析服务实例（反射方式）
    // 在替换为 ILEmit 方式（ILEmitResolverBuilder）后则是通过运行时编织 IL 指令方式调用构造函数创建服务实例
    protected override object VisitConstructor(ConstructorCallSite constructorCallSite, RuntimeResolverContext context)
    {
        object?[] parameterValues;
        // 没有参数
        if (constructorCallSite.ParameterCallSites.Length == 0)
        {
            parameterValues = Array.Empty<object>();
        }
        else
        {
            parameterValues = new object?[constructorCallSite.ParameterCallSites.Length];
            for (int index = 0; index < parameterValues.Length; index++)
            {
                // 根据每个参数对应的 ServiceCallSite 调用 VisitCallSite 得到服务实例
                parameterValues[index] = VisitCallSite(constructorCallSite.ParameterCallSites[index], context);
            }
        }

    #if NETFRAMEWORK || NETSTANDARD2_0
                try
                {
                    // 通过反射方式调用构造函数创建服务实例
                    return constructorCallSite.ConstructorInfo.Invoke(parameterValues);
                }
                catch (Exception ex) when (ex.InnerException != null)
                {
                    ExceptionDispatchInfo.Capture(ex.InnerException).Throw();
                    throw;
                }
    #else
        return constructorCallSite.ConstructorInfo.Invoke(BindingFlags.DoNotWrapExceptions, binder: null, parameters: parameterValues, culture: null);
    #endif
    }

    // 使用 IEnumerableCallSite 解析服务实例
    protected override object VisitIEnumerable(IEnumerableCallSite enumerableCallSite, RuntimeResolverContext context)
    {
        // 根据 IEnumerable<> 获取服务的泛型实参类型创建一个对应类型的空数组
        var array = Array.CreateInstance(
            enumerableCallSite.ItemType,
            enumerableCallSite.ServiceCallSites.Length);
 
        for (int index = 0; index < enumerableCallSite.ServiceCallSites.Length; index++)
        {
            // 遍历每个 ServiceCallSite 调用 VisitCallSite 得到服务实例
            object? value = VisitCallSite(enumerableCallSite.ServiceCallSites[index], context);
            // 反射添加数组元素
            array.SetValue(value, index);
        }
        // 即使没有注册服务也会返回一个空数组
        return array;
    }
}

// 运行时解析服务上下文
internal struct RuntimeResolverContext
{
    // 服务范围
    public ServiceProviderEngineScope Scope { get; set; }
    
    // 保证每一个 Scope 服务范围内服务的单例性
    public RuntimeResolverLock AcquiredLocks { get; set; }
}

[Flags]
internal enum RuntimeResolverLock
{
    Scope = 1,
    Root = 2
}
```

- ServiceProviderServiceExtensions  

```C#

// IServiceProvider 的扩展方法
public static class ServiceProviderServiceExtensions
{
    
    // 根据泛型强类型得到服务
    public static T? GetService<T>(this IServiceProvider provider)
    {
        ThrowHelper.ThrowIfNull(provider);

        return (T?)provider.GetService(typeof(T));
    }

    // 得到必要服务，如果为 null，则抛出 InvalidOperationException 异常
    public static object GetRequiredService(this IServiceProvider provider, Type serviceType)
    {
        ThrowHelper.ThrowIfNull(provider);
        ThrowHelper.ThrowIfNull(serviceType);

        if (provider is ISupportRequiredService requiredServiceSupportingProvider)
        {
            return requiredServiceSupportingProvider.GetRequiredService(serviceType);
        }

        object? service = provider.GetService(serviceType);
        if (service == null)
        {
            throw new InvalidOperationException(SR.Format(SR.NoServiceRegistered, serviceType));
        }

        return service;
    }

    // 根据泛型强类型得到必要服务，如果为 null，则抛出 InvalidOperationException 异常
    public static T GetRequiredService<T>(this IServiceProvider provider) where T : notnull
    {
        ThrowHelper.ThrowIfNull(provider);

        return (T)provider.GetRequiredService(typeof(T));
    }

    // 得到 IEnumerable<> 承载的多个 T 类型的服务实例
    public static IEnumerable<T> GetServices<T>(this IServiceProvider provider)
    {
        ThrowHelper.ThrowIfNull(provider);

        // 由于获取 IEnumerable<> 类型服务的特殊性
        // 即使没有注册服务也会返回一个空数组
        // 所以此处不会抛出异常
        return provider.GetRequiredService<IEnumerable<T>>();
    }

    // 同上
    // T 类型由 serviceType 参数表示
    public static IEnumerable<object?> GetServices(this IServiceProvider provider, Type serviceType)
    {
        ThrowHelper.ThrowIfNull(provider);
        ThrowHelper.ThrowIfNull(serviceType);

        // 构造 IEnumerable<> 封闭类型
        Type? genericEnumerable = typeof(IEnumerable<>).MakeGenericType(serviceType);
        // 此处使用了泛型接口的协变
        return (IEnumerable<object>)provider.GetRequiredService(genericEnumerable);
    }

    // 创建服务范围
    public static IServiceScope CreateScope(this IServiceProvider provider)
    {
        // 通过调用 GetRequiredService 获取 IServiceScopeFactory 服务实例
        return provider.GetRequiredService<IServiceScopeFactory>().CreateScope();
    }

    ...
}
```

- IServiceProviderFactory\<\>  

```C#
// 服务容器工厂的抽象表示
// 用来适配第三方依赖注入框架
public interface IServiceProviderFactory<TContainerBuilder> where TContainerBuilder : notnull
{
    // 根据 IServiceCollection 创建 TContainerBuilder 容器建造者
    TContainerBuilder CreateBuilder(IServiceCollection services);
    
    // 使用 CreateBuilder 方法创建的 TContainerBuilder 容器建造者创建 IServiceProvider 服务容器
    IServiceProvider CreateServiceProvider(TContainerBuilder containerBuilder);
}
```

- DefaultServiceProviderFactory  

```C#
// ASP.NET Core 框架内建的默认服务容器工厂
public class DefaultServiceProviderFactory : IServiceProviderFactory<IServiceCollection>
{
    private readonly ServiceProviderOptions _options;

    public DefaultServiceProviderFactory() : this(ServiceProviderOptions.Default)
    {
        // 使用默认的 ServiceProviderOptions
    }

    public DefaultServiceProviderFactory(ServiceProviderOptions options)
    {
        // 必须指定 ServiceProviderOptions
        _options = options ?? throw new ArgumentNullException(nameof(options));
    }

    // 使用 IServiceCollection 作为容器建造者
    public IServiceCollection CreateBuilder(IServiceCollection services)
    {
        return services;
    }

    // 使用 IServiceCollection 创建 ServiceProvider 作为根容器
    public IServiceProvider CreateServiceProvider(IServiceCollection containerBuilder)
    {
        return containerBuilder.BuildServiceProvider(_options);
    }
}
```
