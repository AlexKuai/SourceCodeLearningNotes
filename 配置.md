# 配置

## 源码涉及的核心类型

- IConfigurationBuilder  
- IConfigurationSource  
- IConfigurationProvider  
- ConfigurationBuilder  
- ConfigurationProvider  
- IChangeToken  
- ConfigurationReloadToken  
- MemoryConfigurationSource  
- MemoryConfigurationBuilderExtensions  
- MemoryConfigurationProvider  
- FileConfigurationSource  
- XmlConfigurationSource  
- JsonConfigurationSource  
- IniConfigurationSource  
- FileConfigurationExtensions  
- IFileProvider  
- JsonConfigurationExtensions  
- XmlConfigurationExtensions  
- IniConfigurationExtensions  
- ConfigurationExtensions  
- FileConfigurationProvider  
- ChangeToken  
- ChangeTokenRegistration\<\>  
- CommandLineConfigurationSource  
- CommandLineConfigurationExtensions  
- EnvironmentVariablesConfigurationSource  
- EnvironmentVariablesExtensions  
- ChainedConfigurationSource  
- ChainedConfigurationProvider  
- ChainedBuilderExtensions  
- IConfiguration  
- IConfigurationRoot  
- IConfigurationSection  
- ConfigurationRoot  
- ConfigurationSection  
- InternalConfigurationRootExtensions  
- ConfigurationBinder  
- BinderOptions  
- BindingPoint  

## 配置模型

- IConfigurationBuilder  

```C#
// 配置建造者的抽象表示
public interface IConfigurationBuilder
{
    IDictionary<string, object> Properties { get; }
 
    IList<IConfigurationSource> Sources { get; }
    
    IConfigurationBuilder Add(IConfigurationSource source);
    
    IConfigurationRoot Build();
}
```

- IConfigurationSource  

```C#
// 不同配置源的抽象表示
public interface IConfigurationSource
{
    // 每个配置源最终会构建出对应的 IConfigurationProvider 配置字典提供者
    IConfigurationProvider Build(IConfigurationBuilder builder);
}
```

- IConfigurationProvider  

```C#
// 配置字典提供者的抽象表示
public interface IConfigurationProvider
{
    // 尝试从配置字典得到值
    bool TryGet(string key, out string? value);
 
    // 设置配置字典的值
    void Set(string key, string? value);
 
    // 得到改变令牌
    IChangeToken GetReloadToken();
    
    // 加载解析对应的配置源并转换为配置字典
    void Load();
    
    // 从配置字典中提取出所有的子 key（不包含 parentPath）
    IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string? parentPath);
}
```

- ConfigurationBuilder  

```C#
// IConfigurationBuilder 的默认实现
public class ConfigurationBuilder : IConfigurationBuilder
{
    // 收集的不同配置源集合
    public IList<IConfigurationSource> Sources { get; } = new List<IConfigurationSource>();

    // 在使用 IConfigurationSource 配置源构建 IConfigurationProvider 配置提供者时
    // 可以利用这组共享数据
    public IDictionary<string, object> Properties { get; } = new Dictionary<string, object>();

    // 添加配置源
    public IConfigurationBuilder Add(IConfigurationSource source)
    {
        ThrowHelper.ThrowIfNull(source);

        Sources.Add(source);
        return this;
    }

    // 根据不同的 IConfigurationSource 配置源创建对应的 IConfigurationProvider 配置提供者
    // 最终使用配置提供者集合创建 IConfigurationRoot 配置根
    public IConfigurationRoot Build()
    {
        var providers = new List<IConfigurationProvider>();
        foreach (IConfigurationSource source in Sources)
        {
            IConfigurationProvider provider = source.Build(this);
            providers.Add(provider);
        }
        return new ConfigurationRoot(providers);
    }
}
```

- ConfigurationProvider  

```C#
// 配置提供者的抽象表示
public abstract class ConfigurationProvider : IConfigurationProvider
{
    // 配置改变令牌
    private ConfigurationReloadToken _reloadToken = new ConfigurationReloadToken();

    protected ConfigurationProvider()
    {
        // 初始化配置字典（配置键忽略大小写）
        Data = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase);
    }

    // 配置字典
    // 配置键是以 “:” 分隔的从根节点出发到叶配置节点的路径化字符串
    protected IDictionary<string, string?> Data { get; set; }

    // 尝试通过配置键获取配置值
    public virtual bool TryGet(string key, out string? value)
        => Data.TryGetValue(key, out value);

    // 设置配置键对应的值
    public virtual void Set(string key, string? value)
        => Data[key] = value;

    // 加载配置源并转换为配置字典
    // 由具体实现类型重写
    public virtual void Load() { }
    
    // 得到父路径下的所有子配置键
    // earlierKeys 参数保存是通过累加器从前面 IConfigurationProvider 中收集到的配置键
    public virtual IEnumerable<string> GetChildKeys(
        IEnumerable<string> earlierKeys,
        string? parentPath)
    {
        var results = new List<string>();

        if (parentPath is null)
        {
            // 从根节点开始找
            foreach (KeyValuePair<string, string?> kv in Data)
            {
                // 查找起始位置为 0 到第一个 “:” 的索引位置
                results.Add(Segment(kv.Key, 0));
            }
        }
        else
        {
            Debug.Assert(ConfigurationPath.KeyDelimiter == ":");

            foreach (KeyValuePair<string, string?> kv in Data)
            {
                // 配置键长度必须大于父路径长度
                // 配置键以父路径开头（忽略大小写）
                // 配置键字符串在以父路径为长度的索引位置的字符必须是 “:”
                if (kv.Key.Length > parentPath.Length &&
                    kv.Key.StartsWith(parentPath, StringComparison.OrdinalIgnoreCase) &&
                    kv.Key[parentPath.Length] == ':')
                {
                    // 查找起始位置为父路径长度 + 1
                    results.Add(Segment(kv.Key, parentPath.Length + 1));
                }
            }
        }

        // 将先收集的子配置键添加到末尾
        results.AddRange(earlierKeys);

        // 使用分段比较策略排序
        // 配置键按 “:” 分隔符拆分成多个段，逐段进行比较
        // 1. 数字段 < 字符串段: 纯数字段始终排在字符串段之前
        // 2. 数字段内部: 按数值大小排序 (0 < 1 < 2 < 10 < 100)
        // 3. 字符串段内部: 大小写不敏感的字典序排序
        // 4. 层级优先: 先比较第一级，相同则比较第二级，以此类推
        results.Sort(ConfigurationKeyComparer.Comparison);

        return results;
    }

    // 得到子配置键
    private static string Segment(string key, int prefixLength)
    {
        // 得到前缀长度以后的第一个 “:” 索引位置（忽略大小写）
        int indexOf = key.IndexOf(ConfigurationPath.KeyDelimiter, prefixLength, StringComparison.OrdinalIgnoreCase);
        // 如果是末端，则截取到末尾
        // 否则截取从前缀长度到之后的第一个 “:” 索引位置
        return indexOf < 0 ? key.Substring(prefixLength) : key.Substring(prefixLength, indexOf - prefixLength);
    }

    // 获取配置改变令牌
    // 供外部调用注册回调，监听改变
    public IChangeToken GetReloadToken()
    {
        return _reloadToken;
    }

    // 回调方法，用于监听配置源的修改变动
    // 如果是文件配置源，则会将 OnReload 方法注册到 IFileProvider.Watch 方法返回的 IChangeToken 上
    protected void OnReload()
    {
        // 创建并交换新的 ConfigurationReloadToken
        ConfigurationReloadToken previousToken = Interlocked.Exchange(ref _reloadToken, new ConfigurationReloadToken());
        // 使用旧的 ConfigurationReloadToken 调用 OnReload 方法触发回调
        previousToken.OnReload();
    }

    // 返回实际的 IConfigurationProvider 配置提供者类型的简短名称
    // 从 Object 继承的 ToString 方法实际返回的是类型的完整名称（本质是通过实例的类型对象指针所指向的 MethodTable 得到的）
    public override string ToString() => $"{GetType().Name}";
}
```

- IChangeToken  

```C#
// 改变令牌的抽象表示
public interface IChangeToken
{
    bool HasChanged { get; }
 
    bool ActiveChangeCallbacks { get; }
 
    IDisposable RegisterChangeCallback(Action<object?> callback, object? state);
}
```

- ConfigurationReloadToken  

```C#
// 配置改变令牌
public class ConfigurationReloadToken : IChangeToken
{
    // 取消令牌源
    private CancellationTokenSource _cts = new CancellationTokenSource();

    // 允许触发回调
    public bool ActiveChangeCallbacks => true;

    // 取消已被触发
    public bool HasChanged => _cts.IsCancellationRequested;

    // 注册配置改变后的回调
    // 使用 CancellationToken.Register 方法注册
    public IDisposable RegisterChangeCallback(Action<object?> callback, object? state) => _cts.Token.Register(callback, state);

    // 触发注册的回调 
    public void OnReload() => _cts.Cancel();
}
```

- MemoryConfigurationSource  

```C#
// 内存配置源
public class MemoryConfigurationSource : IConfigurationSource
{
    // 原始配置源
    // 最终这个原始配置源会在 MemoryConfigurationProvider 的构造函数中完成配置数据到配置字典的转移
    // 所以 MemoryConfigurationProvider 不需要重写 Load 方法
    public IEnumerable<KeyValuePair<string, string?>>? InitialData { get; set; }
    
    // 构建对应的 IConfigurationProvider 配置提供者
    public IConfigurationProvider Build(IConfigurationBuilder builder)
    {
        return new MemoryConfigurationProvider(this);
    }
}
```

- MemoryConfigurationBuilderExtensions  

```C#
// 添加内存配置源的扩展方法
public static class MemoryConfigurationBuilderExtensions
{
    // 添加一个空配置源
    public static IConfigurationBuilder AddInMemoryCollection(this IConfigurationBuilder configurationBuilder)
    {
        ThrowHelper.ThrowIfNull(configurationBuilder);

        // 收集配置源
        configurationBuilder.Add(new MemoryConfigurationSource());
        return configurationBuilder;
    }

    // 添加 initialData 承载的配置源
    public static IConfigurationBuilder AddInMemoryCollection(
        this IConfigurationBuilder configurationBuilder,
        IEnumerable<KeyValuePair<string, string?>>? initialData)
    {
        ThrowHelper.ThrowIfNull(configurationBuilder);

        // 收集配置源
        configurationBuilder.Add(new MemoryConfigurationSource { InitialData = initialData });
        return configurationBuilder;
    }
}
```

- MemoryConfigurationProvider  

```C#
// 使用 MemoryConfigurationSource 构建的内存配置提供者
public class MemoryConfigurationProvider : ConfigurationProvider, IEnumerable<KeyValuePair<string, string?>>
{
    private readonly MemoryConfigurationSource _source;

    public MemoryConfigurationProvider(MemoryConfigurationSource source)
    {
        ThrowHelper.ThrowIfNull(source);

        _source = source;

        if (_source.InitialData != null)
        {
            // 将原始 InitialData 配置数据转移到配置字典
            foreach (KeyValuePair<string, string?> pair in _source.InitialData)
            {
                Data.Add(pair.Key, pair.Value);
            }
        }
    }

    // 添加配置
    public void Add(string key, string? value)
    {
        Data.Add(key, value);
    }

    // 实现 IEnumerable<KeyValuePair<string, string?>>
    public IEnumerator<KeyValuePair<string, string?>> GetEnumerator()
    {
        return Data.GetEnumerator();
    }

    // 实现 IEnumerable
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
```

- FileConfigurationSource  

```C#
// 抽象文件配置源
// 常用实现类型：
// 1. XmlConfigurationSource
// 2. JsonConfigurationSource
// 3. IniConfigurationSource
// 实现类型重写 Build 方法，并在内部调用 EnsureDefaults 方法来确保创建 IFileProvider
// 最后创建对应的 IConfigurationProvider
public abstract class FileConfigurationSource : IConfigurationSource
{
    // IFileProvider 文件提供者
    public IFileProvider? FileProvider { get; set; }

    // 包含相对路径的文件名（包含后缀名）
    public string? Path { get; set; }

    // 文件是否必须存在
    public bool Optional { get; set; }

    // 是否需要监控文件修改变动
    public bool ReloadOnChange { get; set; }

    // 文件修改变动后的延迟触发（等待文件的 Flush 过程，写入磁盘可能有一定延迟）
    // 默认 250 毫秒
    public int ReloadDelay { get; set; } = 250;

    // 在构建对应的 IConfigurationProvider 过程中
    // 调用 FileConfigurationProvider.Load 方法读取文件内容并加载配置字典的过程可能发生错误
    // 可以用来注册回调，执行异常处理
    public Action<FileLoadExceptionContext>? OnLoadException { get; set; }

    // 抽象方法
    // 由子类重写，构建对应的 IConfigurationProvider
    public abstract IConfigurationProvider Build(IConfigurationBuilder builder);

    // 确保 IFileProvider 被创建，一般在子类重写的 Build 方法中调用
    // 在创建 FileConfigurationSource 具体实现类的时候，会调用 ResolveFileProvider 方法创建对应的 IFileProvider
    // 如果没有成功创建，则会调用 FileConfigurationExtensions.GetFileProvider 扩展方法，创建默认的 IFileProvider
    public void EnsureDefaults(IConfigurationBuilder builder)
    {
        FileProvider ??= builder.GetFileProvider();
        OnLoadException ??= builder.GetFileLoadExceptionHandler();
    }

    // 根据绝对路径创建 IFileProvider
    // 如果是相对路径，则会通过调用 EnsureDefaults 方法创建默认的 IFileProvider
    public void ResolveFileProvider()
    {
        // 如果 IFileProvider 未创建，并且是绝对路径
        if (FileProvider == null &&
            !string.IsNullOrEmpty(Path) &&
            System.IO.Path.IsPathRooted(Path))
        {
            // 得到目录路径，返回路径中最后一个 “\” 之前的内容作为目录路径
            string? directory = System.IO.Path.GetDirectoryName(Path);
            // 不管文件或目录，返回路径中最后的 “\” 后面的内容作为文件名（包含后缀名）
            string? pathToFile = System.IO.Path.GetFileName(Path);
            // 如果目录路径不存在
            while (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
            {
                // 通过 GetFileName 方法得到的文件名作为目录名 + 原来的文件名（包含后缀名）的相对路径
                pathToFile = System.IO.Path.Combine(System.IO.Path.GetFileName(directory), pathToFile);
                // 得到上一层目录路径
                directory = System.IO.Path.GetDirectoryName(directory);
            }
            if (Directory.Exists(directory))
            {
                // 使用目录路径创建 PhysicalFileProvider
                FileProvider = new PhysicalFileProvider(directory);
                // 最终用于调用 IFileProvider.GetFileInfo 方法的 subPath
                Path = pathToFile;
            }
        }
    }
}
```

- FileConfigurationExtensions  

```C#
// 设置 IConfigurationBuilder 中 Properties 共享数据的扩展方法
public static class FileConfigurationExtensions
{
    private static string FileProviderKey = "FileProvider";
    private static string FileLoadExceptionHandlerKey = "FileLoadExceptionHandler";

    // 设置外部 IFileProvider 
    // 并作为 IConfigurationBuilder.Properties 的共享数据
    // 避免创建过多的 IFileProvider 实例
    public static IConfigurationBuilder SetFileProvider(this IConfigurationBuilder builder, IFileProvider fileProvider)
    {
        ThrowHelper.ThrowIfNull(builder);
        ThrowHelper.ThrowIfNull(fileProvider);

        builder.Properties[FileProviderKey] = fileProvider;
        return builder;
    }

    // 得到 IFileProvider
    // 优先从 IConfigurationBuilder.Properties 的共享数据中获取 IFileProvider
    // 如果共享数据中没有，则使用应用程序根目录创建 IFileProvider
    // 注意每次都会创建新的 PhysicalFileProvider，并且不会存入共享数据
    public static IFileProvider GetFileProvider(this IConfigurationBuilder builder)
    {
        ThrowHelper.ThrowIfNull(builder);

        if (builder.Properties.TryGetValue(FileProviderKey, out object? provider))
        {
            return (IFileProvider)provider;
        }

        return new PhysicalFileProvider(AppContext.BaseDirectory ?? string.Empty);
    }

    // 使用 basePath 创建 IFileProvider
    // 并且会将 IFileProvider 保存到 IConfigurationBuilder.Properties 的共享数据中
    // 避免创建过多的 IFileProvider 实例
    public static IConfigurationBuilder SetBasePath(this IConfigurationBuilder builder, string basePath)
    {
        ThrowHelper.ThrowIfNull(builder);
        ThrowHelper.ThrowIfNull(basePath);

        return builder.SetFileProvider(new PhysicalFileProvider(basePath));
    }

    // 设置异常处理程序
    // 并保存到 IConfigurationBuilder.Properties 的共享数据中
    public static IConfigurationBuilder SetFileLoadExceptionHandler(this IConfigurationBuilder builder, Action<FileLoadExceptionContext> handler)
    {
        ThrowHelper.ThrowIfNull(builder);

        builder.Properties[FileLoadExceptionHandlerKey] = handler;
        return builder;
    }

    // 尝试从 IConfigurationBuilder.Properties 的共享数据中返回异常处理程序
    public static Action<FileLoadExceptionContext>? GetFileLoadExceptionHandler(this IConfigurationBuilder builder)
    {
        ThrowHelper.ThrowIfNull(builder);

        if (builder.Properties.TryGetValue(FileLoadExceptionHandlerKey, out object? handler))
        {
            return handler as Action<FileLoadExceptionContext>;
        }
        return null;
    }
}
```

- IFileProvider  

```C#
// 文件提供者的抽象表示
public interface IFileProvider
{
    // 得到子路径下对应的文件
    IFileInfo GetFileInfo(string subpath);
 
    // 得到子路径下的目录内容
    IDirectoryContents GetDirectoryContents(string subpath);

    // 利用过滤规则监控文件改变
    IChangeToken Watch(string filter);
}
```

- JsonConfigurationExtensions  

```C#
// 添加 Json 文件配置源的扩展方法
public static class JsonConfigurationExtensions
{
    public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, IFileProvider? provider, string path, bool optional, bool reloadOnChange)
    {
        ThrowHelper.ThrowIfNull(builder);
 
        if (string.IsNullOrEmpty(path))
        {
            throw new ArgumentException(SR.Error_InvalidFilePath, nameof(path));
        }
 
        return builder.AddJsonFile(s =>
        {
            s.FileProvider = provider;
            s.Path = path;
            s.Optional = optional;
            s.ReloadOnChange = reloadOnChange;
            s.ResolveFileProvider();
        });
    }

    // 不启用文件变动监控并且文件路径必须存在对应的文件（非可选）
    public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, string path)
    {
        return AddJsonFile(builder, provider: null, path: path, optional: false, reloadOnChange: false);
    }

    // 不启用文件监控
    public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, string path, bool optional)
    {
        return AddJsonFile(builder, provider: null, path: path, optional: optional, reloadOnChange: false);
    }

    public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, string path, bool optional, bool reloadOnChange)
    {
        return AddJsonFile(builder, provider: null, path: path, optional: optional, reloadOnChange: reloadOnChange);
    }

    public static IConfigurationBuilder AddJsonFile(this IConfigurationBuilder builder, Action<JsonConfigurationSource>? configureSource)
        => builder.Add(configureSource);

    public static IConfigurationBuilder AddJsonStream(this IConfigurationBuilder builder, Stream stream)
    {
        ThrowHelper.ThrowIfNull(builder);

        return builder.Add<JsonStreamConfigurationSource>(s => s.Stream = stream);
    }
}
```

- XmlConfigurationExtensions  

```C#
// 添加 Xml 文件配置源的扩展方法
public static class XmlConfigurationExtensions
{
    // 实现同 JsonConfigurationExtensions 类似
}
```

- IniConfigurationExtensions  

```C#
// 添加 Ini 文件配置源的扩展方法
public static class IniConfigurationExtensions
{
    // 实现同 JsonConfigurationExtensions 类似
}
```

- ConfigurationExtensions  

```C#
// 配置相关的扩展方法
public static class ConfigurationExtensions
{
    // 根据配置委托配置不同的 IConfigurationSource
    public static IConfigurationBuilder Add<TSource>(this IConfigurationBuilder builder, Action<TSource>? configureSource) 
        where TSource : IConfigurationSource, new()
    {
        var source = new TSource();
        configureSource?.Invoke(source);
        return builder.Add(source);
    }

    // 得到 ConnectionStrings 配置节下 key 为 name 的子配置节的值
    public static string? GetConnectionString(this IConfiguration configuration, string name)
    {
        return configuration?.GetSection("ConnectionStrings")[name];
    }

    // 判断配置节是否真实存在
    public static bool Exists(this IConfigurationSection? section)
    {
        if (section == null)
        {
            return false;
        }
        // 是叶配置节或存在子配置节的情况返回 true
        return section.Value != null || section.GetChildren().Any();
    }

    // 得到必须的配置节
    public static IConfigurationSection GetRequiredSection(this IConfiguration configuration, string key)
    {
        ThrowHelper.ThrowIfNull(configuration);
 
        IConfigurationSection section = configuration.GetSection(key);
        // 使用 Exists 方法判断配置节是否存在
        if (section.Exists())
        {
            return section;
        }

        // 不存在，则抛出异常
        throw new InvalidOperationException(SR.Format(SR.InvalidSectionName, key));
    }

    // 枚举所有配置节
    // 根据 makePathsRelative 参数：
    // 1. 如果是 true，则从当前配置节之后枚举所有路径对应的配置节（使用相对路径）
    // 2. 如果是 false，则从当前配置节（包含当前配置节）枚举所有路径对应的配置节（使用绝对路径）
    public static IEnumerable<KeyValuePair<string, string?>> AsEnumerable(this IConfiguration configuration, bool makePathsRelative);
}
```

- FileConfigurationProvider  

```C#
// 文件配置提供者的抽象表示
// 实现类型：
// 1. XmlConfigurationProvider
// 2. JsonConfigurationProvider
// 3. IniConfigurationProvider
public abstract class FileConfigurationProvider : ConfigurationProvider, IDisposable
{
    // 可以通过调用 IDisposable.Dispose 方法取消注册配置改变回调
    private readonly IDisposable? _changeTokenRegistration;

    public FileConfigurationProvider(FileConfigurationSource source)
    {
        ThrowHelper.ThrowIfNull(source);
 
        Source = source;

        // 启用监听配置源改变并且存在 IFileProvider
        if (Source.ReloadOnChange && Source.FileProvider != null)
        {
            // 使用 ChangeToken.OnChange 方法注册回调，监听改变
            _changeTokenRegistration = ChangeToken.OnChange(
                () => Source.FileProvider.Watch(Source.Path!),
                () =>
                {
                    // 回调触发后阻塞线程一段时间
                    // 等待文件 Flush 过程中可能有一定延迟
                    Thread.Sleep(Source.ReloadDelay);
                    // 重新加载配置源
                    Load(reload: true);
                });
        }
    }

    // 对应的文件配置源
    public FileConfigurationSource Source { get; }

    private void Load(bool reload)
    {
        // 得到代表文件信息的 IFileInfo
        IFileInfo? file = Source.FileProvider?.GetFileInfo(Source.Path ?? string.Empty);
        // 文件不存在
        if (file == null || !file.Exists)
        {
            if (Source.Optional || reload)
            {
                // 如果配置源可选或重新加载，则初始化一个空的配置字典
                Data = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase);
            }
            else
            {
                // 抛出异常
                var error = new StringBuilder(SR.Format(SR.Error_FileNotFound, Source.Path));
                if (!string.IsNullOrEmpty(file?.PhysicalPath))
                {
                    error.Append(SR.Format(SR.Error_ExpectedPhysicalPath, file.PhysicalPath));
                }
                // 使用 FileConfigurationSource.OnLoadException 注册的异常处理程序处理异常
                HandleException(ExceptionDispatchInfo.Capture(new FileNotFoundException(error.ToString())));
            }
        }
        else
        {
            static Stream OpenRead(IFileInfo fileInfo)
            {
                // 物理文件路径存在
                if (fileInfo.PhysicalPath != null)
                {
                    // 根据物理文件的绝对路径创建文件读取流
                    return new FileStream(
                        fileInfo.PhysicalPath,
                        FileMode.Open,
                        FileAccess.Read,
                        FileShare.ReadWrite,
                        bufferSize: 1,
                        FileOptions.SequentialScan);
                }

                // 通过 IFileInfo.CreateReadStream 创建文件读取流
                // 这个方法实际返回的是启用了异步 IO 的 FileStream
                // 但是这个 Load 方法是一个同步方法
                // 上面优先创建 FileStream 是为了避免不必要的异步状态机开销和额外堆分配
                return fileInfo.CreateReadStream();
            }

            using Stream stream = OpenRead(file);
            try
            {
                // 从流中读取加载配置源文件内容
                Load(stream);
            }
            catch (Exception ex)
            {
                if (reload)
                {
                    // 如果是重新加载，则初始化配置字典
                    Data = new Dictionary<string, string?>(StringComparer.OrdinalIgnoreCase);
                }
                var exception = new InvalidDataException(SR.Format(SR.Error_FailedToLoad, file.PhysicalPath), ex);
                // 使用 FileConfigurationSource.OnLoadException 注册的异常处理程序处理异常
                HandleException(ExceptionDispatchInfo.Capture(exception));
            }
        }
        
        // 调用父类的 OnReload 方法激活回调
        OnReload();
    }

    // ConfigurationRoot 就是通过调用这个方法初始化每个文件配置提供者的配置字典
    public override void Load()
    {
        Load(reload: false);
    }
    
    // 根据文件流将将文件内容转换为配置字典
    // 实现类型主要就是重写这个方法，完成实际的文件配置到配置字典的转换
    public abstract void Load(Stream stream);

    // 实现 IDisposable
    public void Dispose() => Dispose(true);

    // 取消注册配置改变回调
    protected virtual void Dispose(bool disposing)
    {
        _changeTokenRegistration?.Dispose();
    }
}
```

- ChangeToken  

```C#
// 用于注册 IChangeToken.RegisterChangeCallback 回调的工具类
public static class ChangeToken
{
    // 根据 changeTokenProducer 得到 IChangeToken
    // 使用 changeTokenConsumer 注册 IChangeToken.RegisterChangeCallback 回调
    public static IDisposable OnChange(Func<IChangeToken?> changeTokenProducer, Action changeTokenConsumer)
    {
        if (changeTokenProducer is null)
        {
            ThrowHelper.ThrowArgumentNullException(ExceptionArgument.changeTokenProducer);
        }
        if (changeTokenConsumer is null)
        {
            ThrowHelper.ThrowArgumentNullException(ExceptionArgument.changeTokenConsumer);
        }

        // Action<TState> 参数类型是 Action<Action>
        // TState 泛型参数类型是 Action
        return new ChangeTokenRegistration<Action>(changeTokenProducer, callback => callback(), changeTokenConsumer);
    }

    // 根据 changeTokenProducer 得到 IChangeToken
    // 使用 changeTokenConsumer 注册 IChangeToken.RegisterChangeCallback 回调
    public static IDisposable OnChange<TState>(Func<IChangeToken?> changeTokenProducer, Action<TState> changeTokenConsumer, TState state)
    {
        if (changeTokenProducer is null)
        {
            ThrowHelper.ThrowArgumentNullException(ExceptionArgument.changeTokenProducer);
        }
        if (changeTokenConsumer is null)
        {
            ThrowHelper.ThrowArgumentNullException(ExceptionArgument.changeTokenConsumer);
        }

        return new ChangeTokenRegistration<TState>(changeTokenProducer, changeTokenConsumer, state);
    }

    // 内部类
    // 属于代理注册类，用于实际注册 IChangeToken.RegisterChangeCallback 回调
    // 可以通过调用 IDisposable.Dispose 方法取消注册
    private sealed class ChangeTokenRegistration<TState> : IDisposable
    {
        private readonly Func<IChangeToken?> _changeTokenProducer;
        private readonly Action<TState> _changeTokenConsumer;
        private readonly TState _state;
        private IDisposable? _disposable;

        public ChangeTokenRegistration(Func<IChangeToken?> changeTokenProducer, Action<TState> changeTokenConsumer, TState state)
        {
            _changeTokenProducer = changeTokenProducer;
            _changeTokenConsumer = changeTokenConsumer;
            _state = state;

            // 使用生产者委托得到 IChangeToken
            IChangeToken? token = changeTokenProducer();

            // 使用 IChangeToken.RegisterChangeCallback 注册代理回调
            RegisterChangeTokenCallback(token);
        }

        // 代理回调方法
        private void OnChangeTokenFired()
        {
            // 使用生产者委托得到新的 IChangeToken
            IChangeToken? token = _changeTokenProducer();

            try
            {
                // 使用消费者委托触发实际的回调方法
                _changeTokenConsumer(_state);
            }
            finally
            {
                // 使用新的 IChangeToken.RegisterChangeCallback 注册回调
                RegisterChangeTokenCallback(token);
            }
        }

        // 使用 OnChangeTokenFired 方法注册 IChangeToken.RegisterChangeCallback 回调
        private void RegisterChangeTokenCallback(IChangeToken? token)
        {
            if (token is null)
            {
                return;
            }

            IDisposable registraton = token.RegisterChangeCallback(s => ((ChangeTokenRegistration<TState>?)s)!.OnChangeTokenFired(), this);
            if (token.HasChanged && token.ActiveChangeCallbacks)
            {
                registraton?.Dispose();
                return;
            }
            SetDisposable(registraton);
        }
    }
}
```

- CommandLineConfigurationSource  

```C#
// 命令行配置源
// 单参数形式（一段）：
// 1. {name}={value}
// 2. {prefix}{name}={value}
// 双参数形式（两段）：
// 1. {prefix}{name} {value}
// 前缀支持：
// 1. --
// 2. -
// 3. /
public class CommandLineConfigurationSource : IConfigurationSource
{
    // 命令行缩写与全名的映射配置（缩写忽略大小写）
    // 缩写只能使用 “-” 或 “--” 作为前缀
    // 如果使用 “-” 前缀，映射配置中必须存在相应配置，否则抛出 FormatException
    public IDictionary<string, string>? SwitchMappings { get; set; }

    // 命令行参数
    public IEnumerable<string> Args { get; set; } = Array.Empty<string>();
 
    // 构建对应的 IConfigurationProvider
    public IConfigurationProvider Build(IConfigurationBuilder builder)
    {
        return new CommandLineConfigurationProvider(Args, SwitchMappings);
    }
}
```

- CommandLineConfigurationExtensions  

```C#
// 添加命令行配置源的扩展方法
public static class CommandLineConfigurationExtensions
{
    public static IConfigurationBuilder AddCommandLine(this IConfigurationBuilder configurationBuilder, string[] args)
    {
        return configurationBuilder.AddCommandLine(args, switchMappings: null);
    }

    public static IConfigurationBuilder AddCommandLine(
        this IConfigurationBuilder configurationBuilder,
        string[] args,
        IDictionary<string, string>? switchMappings)
    {
        configurationBuilder.Add(new CommandLineConfigurationSource { Args = args, SwitchMappings = switchMappings });
        return configurationBuilder;
    }

    public static IConfigurationBuilder AddCommandLine(this IConfigurationBuilder builder, Action<CommandLineConfigurationSource>? configureSource)
        => builder.Add(configureSource);
    }
```

- EnvironmentVariablesConfigurationSource  

```C#
// 环境变量配置源
// 来源：
// 1. 当前系统 HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment
// 2. 当前用户 HKEY_CURRENT_USER\Environment
// 3. 当前进程 launchSettings.json
public class EnvironmentVariablesConfigurationSource : IConfigurationSource
{
    // 环境变量前缀
    public string? Prefix { get; set; }
 
    public IConfigurationProvider Build(IConfigurationBuilder builder)
    {
        return new EnvironmentVariablesConfigurationProvider(Prefix);
    }
}
```

- EnvironmentVariablesExtensions  

```C#
// 添加环境变量配置源的扩展方法
public static class EnvironmentVariablesExtensions
{
    public static IConfigurationBuilder AddEnvironmentVariables(this IConfigurationBuilder configurationBuilder)
    {
        configurationBuilder.Add(new EnvironmentVariablesConfigurationSource());
        return configurationBuilder;
    }
 
    public static IConfigurationBuilder AddEnvironmentVariables(
        this IConfigurationBuilder configurationBuilder,
        string? prefix)
    {
        configurationBuilder.Add(new EnvironmentVariablesConfigurationSource { Prefix = prefix });
        return configurationBuilder;
    }
 
    public static IConfigurationBuilder AddEnvironmentVariables(this IConfigurationBuilder builder, Action<EnvironmentVariablesConfigurationSource>? configureSource)
        => builder.Add(configureSource);
}
```

- ChainedConfigurationSource  

```C#
// 外部链接配置源
public class ChainedConfigurationSource : IConfigurationSource
{
    // 使用外部 IConfiguration 作为配置源
    public IConfiguration? Configuration { get; set; }
    
    // 外部的 IConfiguration 的释放是否随 ChainedConfigurationProvider 一起
    public bool ShouldDisposeConfiguration { get; set; }
 
    public IConfigurationProvider Build(IConfigurationBuilder builder)
        => new ChainedConfigurationProvider(this);
}
```

- ChainedConfigurationProvider  

```C#
// 链接配置提供者
public class ChainedConfigurationProvider : IConfigurationProvider, IDisposable
{
    private readonly IConfiguration _config;
    private readonly bool _shouldDisposeConfig;

    public ChainedConfigurationProvider(ChainedConfigurationSource source)
    {
        ThrowHelper.ThrowIfNull(source);

        // 外部 IConfiguration 不存在，则抛出异常
        _config = source.Configuration ?? throw new ArgumentException(SR.Format(SR.InvalidNullArgument, "source.Configuration"), nameof(source));
        _shouldDisposeConfig = source.ShouldDisposeConfiguration;
    }

    // 返回 IConfiguration
    public IConfiguration Configuration => _config;

    // 内部实际返回从 IConfiguration 得到配置值
    public bool TryGet(string key, out string? value)
    {
        value = _config[key];
        return !string.IsNullOrEmpty(value);
    }

    // 内部实际是对 IConfiguration 设置值
    public void Set(string key, string? value) => _config[key] = value;

    // 内部实际是调用 IConfiguration 的 GetReloadToken 方法
    public IChangeToken GetReloadToken() => _config.GetReloadToken();

    // 空实现
    // 无需创建配置字典
    public void Load() { }

    // 得到所有子配置键
    public IEnumerable<string> GetChildKeys(
        IEnumerable<string> earlierKeys,
        string? parentPath)
    {
        // 根据 parentPath 路径得到配置节
        IConfiguration section = parentPath == null ? _config : _config.GetSection(parentPath);
        var keys = new List<string>();
        // 循环所有子配置节
        foreach (IConfigurationSection child in section.GetChildren())
        {
            // 添加将子配置节的配置键
            keys.Add(child.Key);
        }
        // 将 earlierKeys 添加到末尾
        keys.AddRange(earlierKeys);
        // 使用分段比较策略排序
        // 配置键按 “:” 分隔符拆分成多个段，逐段进行比较
        // 1. 数字段 < 字符串段: 纯数字段始终排在字符串段之前
        // 2. 数字段内部: 按数值大小排序 (0 < 1 < 2 < 10 < 100)
        // 3. 字符串段内部: 大小写不敏感的字典序排序
        // 4. 层级优先: 先比较第一级，相同则比较第二级，以此类推
        keys.Sort(ConfigurationKeyComparer.Comparison);
        return keys;
    }

    // 释放
    public void Dispose()
    {
        // IConfiguration 是否随 ChainedConfigurationProvider 一起执行释放
        if (_shouldDisposeConfig)
        {
            (_config as IDisposable)?.Dispose();
        }
    }
}
```

- ChainedBuilderExtensions  

```C#
// 使用外部 IConfiguration 作为配置源注册 IConfigurationSource 的扩展方法
public static class ChainedBuilderExtensions
{
    public static IConfigurationBuilder AddConfiguration(this IConfigurationBuilder configurationBuilder, IConfiguration config)
        => AddConfiguration(configurationBuilder, config, shouldDisposeConfiguration: false);
    
    public static IConfigurationBuilder AddConfiguration(
        this IConfigurationBuilder configurationBuilder, IConfiguration config, bool shouldDisposeConfiguration)
    {
        ThrowHelper.ThrowIfNull(configurationBuilder);
        ThrowHelper.ThrowIfNull(config);

        configurationBuilder.Add(new ChainedConfigurationSource
        {
            Configuration = config,
            ShouldDisposeConfiguration = shouldDisposeConfiguration,
        });
        return configurationBuilder;
    }
}
```

## 配置应用

- IConfiguration  

```C#
// 配置节的抽象表示
// 逻辑上配置体现为一颗由不同配置节组成的配置树
// 每个叶配置节保存了配置值
public interface IConfiguration
{
    // 通过配置节路径得到对应的值
    // 如果不是叶配置节路径，则返回 null
    string? this[string key] { get; set; }
    
    // 通过给定的配置节键得到配置节
    // 无论配置节是否存在最终都会得到 IConfigurationSection
    IConfigurationSection GetSection(string key);

    // 得到当前配置节下所有的子配置节
    IEnumerable<IConfigurationSection> GetChildren();

    // 得到配置改变令牌
    IChangeToken GetReloadToken();
}
```

- IConfigurationRoot  

```C#
// 配置根的抽象表示
public interface IConfigurationRoot : IConfiguration
{
    // 重新加载
    // 内部实际遍历调用 IConfigurationProvider.Load 方法重新加载配置字典
    void Reload();

    // 保存了所有的配置提供者
    IEnumerable<IConfigurationProvider> Providers { get; }
}
```

- IConfigurationSection  

```C#
// 非根配置节的抽象表示
public interface IConfigurationSection : IConfiguration
{
    // 配置节名称
    string Key { get; }

    // 配置节路径
    string Path { get; }
    
    // 如果是叶配置节，则返回配置字典中以 Path 为键所对应的值
    string? Value { get; set; }
}
```

- ConfigurationRoot  

```C#
// IConfigurationRoot 的默认实现
public class ConfigurationRoot : IConfigurationRoot, IDisposable
{
    // 配置提供者集合
    private readonly IList<IConfigurationProvider> _providers;
    // 利用每个配置提供者得到的 IChangeToken 并注册 IChangeToken.RegisterChangeCallback 回调
    // 得到 ChangeTokenRegistration 集合
    private readonly IList<IDisposable> _changeTokenRegistrations;
    // 对外提供 IChangeToken 注册 IChangeToken.RegisterChangeCallback 回调
    private ConfigurationReloadToken _changeToken = new ConfigurationReloadToken();

    public ConfigurationRoot(IList<IConfigurationProvider> providers)
    {
        ThrowHelper.ThrowIfNull(providers);
 
        _providers = providers;
        _changeTokenRegistrations = new List<IDisposable>(providers.Count);
        foreach (IConfigurationProvider p in providers)
        {
            // 将每个配置提供器对应的配置源加载并转换为配置字典
            p.Load();
            // 利用每个配置提供者得到的 IChangeToken 并注册 IChangeToken.RegisterChangeCallback 回调
            // 得到 ChangeTokenRegistration 集合
            _changeTokenRegistrations.Add(ChangeToken.OnChange(p.GetReloadToken, RaiseChanged));
        }
    }

    // 返回配置提供者集合
    public IEnumerable<IConfigurationProvider> Providers => _providers;

    // 实现索引器
    // 通过配置节路径从每个配置提供者的配置字典中尝试得到或设置对应的值
    public string? this[string key]
    {
        get => GetConfiguration(_providers, key);
        set => SetConfiguration(_providers, key, value);
    }

    // 通过配置键从配置提供者的配置字典中得到对应的配置值
    internal static string? GetConfiguration(IList<IConfigurationProvider> providers, string key)
    {
        // 从后往前遍历配置提供者
        // 寻找对应配置键的配置值
        for (int i = providers.Count - 1; i >= 0; i--)
        {
            IConfigurationProvider provider = providers[i];
 
            if (provider.TryGet(key, out string? value))
            {
                // 只要找到就直接返回
                return value;
            }
        }
 
        // 如果没有找到，则返回 null
        return null;
    }
    
    // 通过配置键和配置值更新所有配置提供器的配置字典
    internal static void SetConfiguration(IList<IConfigurationProvider> providers, string key, string? value)
    {
        if (providers.Count == 0)
        {
            throw new InvalidOperationException(SR.Error_NoSources);
        }

        // 遍历所有配置提供者
        foreach (IConfigurationProvider provider in providers)
        {
            // 更新配置提供者的配置字典
            provider.Set(key, value);
        }
    }

    // 得到根节点下的子配置节集合
    public IEnumerable<IConfigurationSection> GetChildren() => this.GetChildrenImplementation(null);

    // 返回 IChangeToken 对外提供注册 IChangeToken.RegisterChangeCallback 回调
    public IChangeToken GetReloadToken() => _changeToken;

    // 得到指定路径的配置节
    // 可能返回路径不存在的配置节
    // 注意：
    // 此处的 key 是从根节点出发的绝对路径
    public IConfigurationSection GetSection(string key)
        => new ConfigurationSection(this, key);

    // 可用用来重新加载配置源并转换为配置字典
    // 用于手动触发重新加载配置源
    public void Reload()
    {
        foreach (IConfigurationProvider provider in _providers)
        {
            provider.Load();
        }
        // 激活回调
        RaiseChanged();
    }

    // 用来注册每个配置提供器的 IChangeToken.RegisterChangeCallback 回调方法
    private void RaiseChanged()
    {
        // 比较并交换返回原来的 ConfigurationReloadToken，并创建新的 ConfigurationReloadToken
        ConfigurationReloadToken previousToken = Interlocked.Exchange(ref _changeToken, new ConfigurationReloadToken());
        // 使用原来的 ConfigurationReloadToken 触发注册的 IChangeToken.RegisterChangeCallback 回调
        previousToken.OnReload();
    }

    // 释放
    public void Dispose()
    {
        // 取消每个回调注册
        foreach (IDisposable registration in _changeTokenRegistrations)
        {
            registration.Dispose();
        }
 
        // 释放每个配置提供者
        foreach (IConfigurationProvider provider in _providers)
        {
            (provider as IDisposable)?.Dispose();
        }
    }
}
```

- ConfigurationSection  

```C#
// IConfigurationSection 的默认实现
public class ConfigurationSection : IConfigurationSection
{
    // 配置根
    private readonly IConfigurationRoot _root;
    // 配置节路径
    private readonly string _path;
    // 配置键（配置节路径最后一段）
    private string? _key;

    public ConfigurationSection(IConfigurationRoot root, string path)
    {
        ThrowHelper.ThrowIfNull(root);
        ThrowHelper.ThrowIfNull(path);
 
        _root = root;
        _path = path;
    }
    
    // 返回配置节路径
    public string Path => _path;
    
    // 返回配置键（配置节路径最后一段）
    public string Key =>
        _key ??= ConfigurationPath.GetSectionKey(_path);
    
    // 返回配置路径对应的配置值
    // 内部实际是调用配置根实现的索引器
    // 注意：
    // 如果配置路径不存在或不是叶配置节点则返回 null
    public string? Value
    {
        get
        {
            return _root[Path];
        }
        set
        {
            _root[Path] = value;
        }
    }
    
    // 实现索引器
    // 内部实际是调用配置根实现的索引器
    // 得到从当前路径出发的配置节路径为 [当前配置节路径]:[参数 key] 对应的配置值
    public string? this[string key]
    {
        get
        {
            return _root[ConfigurationPath.Combine(Path, key)];
        }
        set
        {
            _root[ConfigurationPath.Combine(Path, key)] = value;
        }
    }
    
    // 得到从当前路径出发的配置节路径为 [当前配置节路径]:[参数 key] 对应的配置节
    public IConfigurationSection GetSection(string key) => _root.GetSection(ConfigurationPath.Combine(Path, key));

    // 得到当前路径下的所有子配置节
    public IEnumerable<IConfigurationSection> GetChildren() => _root.GetChildrenImplementation(Path);

    // 返回 IChangeToken
    // 本质是返回根配置节的 IChangeToken
    public IChangeToken GetReloadToken() => _root.GetReloadToken();
}
```

- InternalConfigurationRootExtensions  

```C#
// 提供针对 IConfigurationRoot 的扩展方法
internal static class InternalConfigurationRootExtensions
{
    // 根据父配置节路径，得到所有子配置节
    internal static IEnumerable<IConfigurationSection> GetChildrenImplementation(this IConfigurationRoot root, string? path)
    {
        using ReferenceCountedProviders? reference = (root as ConfigurationManager)?.GetProvidersReference();
                // 得到所有配置提供者
        IEnumerable<IConfigurationProvider> providers = reference?.Providers ?? root.Providers;

        // 通过累加器得到父配置节路径下所有子配置节的配置键并去重
        // 最终得到父配置节下的所有子配置节
        IEnumerable<IConfigurationSection> children = providers
            .Aggregate(Enumerable.Empty<string>(),
                (seed, source) => source.GetChildKeys(seed, path))
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .Select(key => root.GetSection(path == null ? key : ConfigurationPath.Combine(path, key)));

        if (reference is null)
        {
            return children;
        }
        else
        {
            return children.ToList();
        }
    }
}
```

## 配置绑定

- ConfigurationBinder  

```C#
// 配置绑定
// 提供针对 IConfiguration 的扩展方法
public static class ConfigurationBinder
{
    // 根据配置节创建对应类型的对象并绑定配置值
    public static T? Get<T>(this IConfiguration configuration)
        => configuration.Get<T>(_ => { });
    public static T? Get<T>(this IConfiguration configuration, Action<BinderOptions>? configureOptions)
    {
        ThrowHelper.ThrowIfNull(configuration);
 
        object? result = configuration.Get(typeof(T), configureOptions);
        if (result == null)
        {
            return default(T);
        }
        return (T)result;
    }
    public static object Get(this IConfiguration configuration, Type type)
        => configuration.Get(type, _ => { });
    public static object Get(this IConfiguration configuration, Type type, Action<BinderOptions>? configureOptions)
    {
        ThrowHelper.ThrowIfNull(configuration);
 
        var options = new BinderOptions();
        configureOptions?.Invoke(options);
        var bindingPoint = new BindingPoint();
        BindInstance(type, bindingPoint, config: configuration, options: options);
        return bindingPoint.Value;
    }

    // 根据配置节对已存在的对象绑定配置值
    public static void Bind(this IConfiguration configuration, string key, object? instance)
        => configuration.GetSection(key).Bind(instance);
    public static void Bind(this IConfiguration configuration, object? instance)
        => configuration.Bind(instance, _ => { });
    public static void Bind(this IConfiguration configuration, object? instance, Action<BinderOptions>? configureOptions)
    {
        ThrowHelper.ThrowIfNull(configuration);
 
        if (instance != null)
        {
            var options = new BinderOptions();
            configureOptions?.Invoke(options);
            // 设置绑定点只读
            var bindingPoint = new BindingPoint(instance, isReadOnly: true);
            BindInstance(instance.GetType(), bindingPoint, configuration, options);
        }
    }

    // 根据配置节得到强类型的配置值
    // 本质是将字符串配置值根据类型转换对应的强类型值
    public static T? GetValue<T>(this IConfiguration configuration, string key)
    {
        return GetValue(configuration, key, default(T));
    }
    public static T? GetValue<T>(this IConfiguration configuration, string key, T defaultValue)
    {
        return (T?)GetValue(configuration, typeof(T), key, defaultValue);
    }
    public static object? GetValue(this IConfiguration configuration, Type type, string key)
    {
        return GetValue(configuration, type, key, defaultValue: null);
    }
    public static object? GetValue(this IConfiguration configuration, Type type, string key, object? defaultValue)
    {
        IConfigurationSection section = configuration.GetSection(key);
        string? value = section.Value;
        if (value != null)
        {
            // 尝试从字符串转换为 type 表示的目标类型
            return ConvertValue(type, value, section.Path);
        }
        return defaultValue;
    }

    // 将配置绑定到实例属性上
    private static void BindInstance(Type type, BindingPoint bindingPoint, IConfiguration config, BinderOptions options)
    {
        // 如果 type 表示的目标类型实现 IConfigurationSection
        // 则填充 BindingPoint 直接返回
        if (type == typeof(IConfigurationSection))
        {
            // 对绑定点设置新的值
            bindingPoint.TrySetValue(config);
            return;
        }

        var section = config as IConfigurationSection;
        string? configValue = section?.Value;
        // 如果是叶配置节并且可以从字符串转换为目标类型的值
        if (configValue != null && TryConvertValue(type, configValue, section?.Path, out object? convertedValue, out Exception? error))
        {
            if (error != null)
            {
                throw error;
            }

            // 使用绑定点设置新的值
            bindingPoint.TrySetValue(convertedValue);
            return;
        }

        // 如果是非叶配置节并且存在子配置节
        if (config != null && config.GetChildren().Any())
        {
            // 如果目标类型是数组类型或数组实现的接口类型
            // 数组实现的接口类型包括：
            // 1. IEnumerable<>
            // 2. IReadOnlyCollection<>
            // 3. IReadOnlyList<>
            if (type.IsArray || IsArrayCompatibleInterface(type))
            {
                // 绑定点非只读
                if (!bindingPoint.IsReadOnly)
                {
                    // 创建数组并作为数组绑定
                    // 如果绑定点的值是 null，则创建一个空数组
                    bindingPoint.SetValue(BindArray(type, (IEnumerable?)bindingPoint.Value, config, options));
                }
                return;
            }
            
            // 如果目标类型是 ISet<> 或 IReadOnlySet<> 接口类型
            if (TypeIsASetInterface(type))
            {
                // 绑定点非只读
                if (!bindingPoint.IsReadOnly)
                {
                    // 作为 HashSet 集合绑定（表示无序且不可重复的集合）
                    object? newValue = BindSet(type, (IEnumerable?)bindingPoint.Value, config, options);
                    if (newValue != null)
                    {
                        bindingPoint.SetValue(newValue);
                    }
                }
                return;
            }

            // 如果目标类型是 IDictionary<,> 或 IReadOnlyDictionary<,> 接口类型
            if (TypeIsADictionaryInterface(type))
            {
                // 绑定点非只读
                if (!bindingPoint.IsReadOnly)
                {
                    // 作为 Dictionary<,> 字典绑定
                    object? newValue = BindDictionaryInterface(bindingPoint.Value, type, config, options);
                    if (newValue != null)
                    {
                        bindingPoint.SetValue(newValue);
                    }
                }
                return;
            }

            // 目标类型不满足以上条件，并且绑定点的值是 null
            if (bindingPoint.Value is null)
            {
                if (bindingPoint.IsReadOnly)
                {
                    return;
                }

                // 创建实例并设置绑定点的值
                bindingPoint.SetValue(CreateInstance(type, config, options));
            }

            // 此时绑定点的值 BindingPoint.Value 一定不为 null

            // 目标类型是实现 IDictionary<,> 的接口类型
            Type? dictionaryInterface = FindOpenGenericInterface(typeof(IDictionary<,>), type);

            if (dictionaryInterface != null)
            {
                // 使用 IDictionary<,> 读取配置绑定字典
                BindConcreteDictionary(bindingPoint.Value!, dictionaryInterface, config, options);
            }
            else
            {
                // 目标类型是实现 ICollection<,> 的接口类型
                Type? collectionInterface = FindOpenGenericInterface(typeof(ICollection<>), type);
                if (collectionInterface != null)
                {
                    // 使用 ICollection<> 读取配置绑定集合
                    BindCollection(bindingPoint.Value!, collectionInterface, config, options);
                }
                else
                {
                    // 读取配置绑定实例中的属性
                    BindProperties(bindingPoint.Value!, config, options);
                }
            }
        }
    }

    // 绑定数组
    private static Array BindArray(Type type, IEnumerable? source, IConfiguration config, BinderOptions options)
    {
        Type elementType;
        if (type.IsArray)
        {
            // 数组类型并且数组的秩大于 1（非一维数组），则抛出异常
            if (type.GetArrayRank() > 1)
            {
                throw new InvalidOperationException(SR.Format(SR.Error_UnsupportedMultidimensionalArray, type));
            }
            // 得到数组的元素类型
            elementType = type.GetElementType()!;
        }
        else
        {
            // 如果是数组实现的接口类型
            // 得到泛型实参类型
            elementType = type.GetGenericArguments()[0];
        }

        IList list = new List<object?>();

        // 如果是通过调用 Bind 相关方法的话，则绑定点可能已存在集合
        if (source != null)
        {
            // 转移到新的集合中
            foreach (object? item in source)
            {
                list.Add(item);
            }
        }

        // 遍历所有子配置节
        foreach (IConfigurationSection section in config.GetChildren())
        {
            var itemBindingPoint = new BindingPoint();
            try
            {
                // 根据每个子配置节调用 BindInstance 方法
                BindInstance(
                    type: elementType,
                    bindingPoint: itemBindingPoint,
                    config: section,
                    options: options);
                // 将得到的绑定实例添加到集合末尾
                // 如果没有绑定成功则跳过
                if (itemBindingPoint.HasNewValue)
                {
                    list.Add(itemBindingPoint.Value);
                }
            }
            catch
            {
            }
        }

        // 创建新的数组并从列表拷贝元素
        Array result = Array.CreateInstance(elementType, list.Count);
        list.CopyTo(result, 0);
        return result;
    }

    // 绑定 HashSet 集合
    // 仅支持配置值是字符串或枚举值的配置节
    private static object? BindSet(Type type, IEnumerable? source, IConfiguration config, BinderOptions options)
    {
        Type elementType = type.GetGenericArguments()[0];
        
        // 得到泛型类型实参
        Type keyType = type.GenericTypeArguments[0];

        bool keyTypeIsEnum = keyType.IsEnum;

        // 仅支持泛型类型实参为 string 或枚举类型作为 key
        // HashSet 集合内部是调用 GetHashCode 方法得到散列值来确定位置的
        if (keyType != typeof(string) && !keyTypeIsEnum)
        {
            return null;
        }

        // 创建 HashSet<> 泛型类型
        Type genericType = typeof(HashSet<>).MakeGenericType(keyType);
        object instance = Activator.CreateInstance(genericType)!;

        MethodInfo addMethod = genericType.GetMethod("Add", DeclaredOnlyLookup)!;

        // 创建调用反射时的参数数组
        object?[] arguments = new object?[1];

        // 如果是通过调用 Bind 相关方法的话，则绑定点可能已存在集合
        if (source != null)
        {
            // 转移到新的 HashSet 集合中
            foreach (object? item in source)
            {
                arguments[0] = item;
                // 通过反射方式调用 Add 方法
                addMethod.Invoke(instance, arguments);
            }
        }

        // 遍历所有子配置节
        foreach (IConfigurationSection section in config.GetChildren())
        {
            var itemBindingPoint = new BindingPoint();
            try
            {
                // 根据每个子配置节调用 BindInstance 方法
                BindInstance(
                    type: elementType,
                    bindingPoint: itemBindingPoint,
                    config: section,
                    options: options);
                // 将得到的绑定实例放入 HashSet
                // 如果没有绑定成功则跳过
                if (itemBindingPoint.HasNewValue)
                {
                    arguments[0] = itemBindingPoint.Value;

                    addMethod.Invoke(instance, arguments);
                }
            }
            catch
            {
            }
        }
        
        return instance;
    }

    // 绑定 Dictionary<,> 字典
    private static object? BindDictionaryInterface(object? source, Type dictionaryType, IConfiguration config, BinderOptions options)
    {
        // 得到表示 Key 的泛型类型实参
        Type keyType = dictionaryType.GenericTypeArguments[0];
        // 得到表示 Value 的泛型类型实参
        Type valueType = dictionaryType.GenericTypeArguments[1];
        bool keyTypeIsEnum = keyType.IsEnum;

        // 仅支持泛型类型实参为 string 或枚举类型作为 key
        if (keyType != typeof(string) && !keyTypeIsEnum)
        {
            return null;
        }

        Type genericType = typeof(Dictionary<,>).MakeGenericType(keyType, valueType);
        MethodInfo addMethod = genericType.GetMethod("Add", DeclaredOnlyLookup)!;

        Type kvpType = typeof(KeyValuePair<,>).MakeGenericType(keyType, valueType);
        PropertyInfo keyMethod = kvpType.GetProperty("Key", DeclaredOnlyLookup)!;
        PropertyInfo valueMethod = kvpType.GetProperty("Value", DeclaredOnlyLookup)!;

        // 创建 Dictionary<,> 泛型类型
        object dictionary = Activator.CreateInstance(genericType)!;

        // 如果是通过调用 Bind 相关方法的话，则绑定点可能已存在字典
        var orig = source as IEnumerable;

        // 创建调用反射时的参数数组
        object?[] arguments = new object?[2];

        if (orig != null)
        {
            // 转移到新的 Dictionary 字典中
            foreach (object? item in orig)
            {
                object? k = keyMethod.GetMethod!.Invoke(item, null);
                object? v = valueMethod.GetMethod!.Invoke(item, null);
                arguments[0] = k;
                arguments[1] = v;
                addMethod.Invoke(dictionary, arguments);
            }
        }

        // 读取配置绑定字典
        BindConcreteDictionary(dictionary, dictionaryType, config, options);

        return dictionary;
    }

    // 读取配置绑定 Dictionary<,> 字典
    private static void BindConcreteDictionary(object? dictionary, Type dictionaryType, IConfiguration config, BinderOptions options)
    {
        // 得到表示 Key 的泛型类型实参
        Type keyType = dictionaryType.GenericTypeArguments[0];
        // 得到表示 Value 的泛型类型实参
        Type valueType = dictionaryType.GenericTypeArguments[1];
        bool keyTypeIsEnum = keyType.IsEnum;

        // 仅支持泛型类型实参为 string 或枚举类型作为 key
        if (keyType != typeof(string) && !keyTypeIsEnum)
        {
            return;
        }

        Type genericType = typeof(Dictionary<,>).MakeGenericType(keyType, valueType);

        MethodInfo tryGetValue = dictionaryType.GetMethod("TryGetValue")!;
        // 得到索引器属性
        PropertyInfo setter = genericType.GetProperty("Item", DeclaredOnlyLookup)!;
        // 遍历所有子配置节
        foreach (IConfigurationSection child in config.GetChildren())
        {
            try
            {
                // 使用配置节填充字典的键
                object key = keyTypeIsEnum ? Enum.Parse(keyType, child.Key) : child.Key;
                // 创建绑定点的初始值提供者
                // 使用绑定提供器因为如果是通过调用 Bind 相关方法的话
                // 可能字典键的值已经存在，可以作为无法从配置节中解析值时的初始值
                var valueBindingPoint = new BindingPoint(
                    initialValueProvider: () =>
                    {
                        // 调用 TryGetValue 方法，第二个参数是 out 输出参数，使用 null 初始化
                        object?[] tryGetValueArgs = { key, null };
                        // 从输出参数得到字典值
                        return (bool)tryGetValue.Invoke(dictionary, tryGetValueArgs)! ? tryGetValueArgs[1] : null;
                    },
                    isReadOnly: false);
                BindInstance(
                    type: valueType,
                    bindingPoint: valueBindingPoint,
                    config: child,
                    options: options);
                if (valueBindingPoint.HasNewValue)
                {
                    // 通过使用索引器反射设置字典值
                    setter.SetValue(dictionary, valueBindingPoint.Value, new object[] { key });
                }
            }
            catch
            {
            }
        }
    }

    // 绑定实现 ICollection<> 接口的集合
    private static void BindCollection(object collection, Type collectionType, IConfiguration config, BinderOptions options)
    {
        // 得到 ICollection<> 的泛型类型实参
        Type itemType = collectionType.GenericTypeArguments[0];
        MethodInfo? addMethod = collectionType.GetMethod("Add", DeclaredOnlyLookup);

        foreach (IConfigurationSection section in config.GetChildren())
        {
            try
            {
                BindingPoint itemBindingPoint = new();
                BindInstance(
                    type: itemType,
                    bindingPoint: itemBindingPoint,
                    config: section,
                    options: options);
                if (itemBindingPoint.HasNewValue)
                {
                    // 通过反射添加集合元素
                    addMethod?.Invoke(collection, new[] { itemBindingPoint.Value });
                }
            }
            catch
            {
            }
        }
    }

    // 绑定属性
    private static void BindProperties(object instance, IConfiguration configuration, BinderOptions options)
    {
        List<PropertyInfo> modelProperties = GetAllProperties(instance.GetType());

        // 如果 BinderOptions.ErrorOnUnknownConfiguration 属性值为 true
        // 则需要在绑定属性前检查所有配置节的 Key 是否都可以找到对应的同名属性（忽略大小写）
        // 如果存在未知配置，则抛出异常
        if (options.ErrorOnUnknownConfiguration)
        {
            HashSet<string> propertyNames = new(modelProperties.Select(mp => mp.Name),
                StringComparer.OrdinalIgnoreCase);

            IEnumerable<IConfigurationSection> configurationSections = configuration.GetChildren();
            List<string> missingPropertyNames = configurationSections
                .Where(cs => !propertyNames.Contains(cs.Key))
                .Select(mp => $"'{mp.Key}'")
                .ToList();

            // 存在子配置节的 Key 无法找到对应的同名属性（忽略大小写），则抛出异常
            if (missingPropertyNames.Count > 0)
            {
                throw new InvalidOperationException(SR.Format(SR.Error_MissingConfig,
                    nameof(options.ErrorOnUnknownConfiguration), nameof(BinderOptions), instance.GetType(),
                    string.Join(", ", missingPropertyNames)));
            }
        }

        foreach (PropertyInfo property in modelProperties)
        {
            BindProperty(property, instance, configuration, options);
        }
    }

    // 通过反射方式绑定属性值
    private static void BindProperty(PropertyInfo property, object instance, IConfiguration config, BinderOptions options)
    {
        // 不支持以下属性：
        // 1. 只写属性（即使绑定上了也没有意义）
        // 2. 非公共属性（BinderOptions.BindNonPublicProperties 属性值为 false）
        // 3. 索引器（有参属性）
        if (property.GetMethod == null ||
            (!options.BindNonPublicProperties && !property.GetMethod.IsPublic) ||
            property.GetMethod.GetParameters().Length > 0)
        {
            return;
        }

        // 绑定提供器使用当前属性值作为无法从配置节中解析值时的初始值
        var propertyBindingPoint = new BindingPoint(
            initialValueProvider: () => property.GetValue(instance),
            isReadOnly: property.SetMethod is null || (!property.SetMethod.IsPublic && !options.BindNonPublicProperties));

        // 使用属性名创建子配置节并调用 BindInstance 方法
        BindInstance(
            property.PropertyType,
            propertyBindingPoint,
            config.GetSection(GetPropertyName(property)),
            options);

        if (propertyBindingPoint.HasNewValue)
        {
            // 通过反射绑定属性值
            property.SetValue(instance, propertyBindingPoint.Value);
        }
    }
}
```

- BinderOptions  

```C#
// 绑定选项
public class BinderOptions
{
    // 是否绑定非公开属性
    public bool BindNonPublicProperties { get; set; }
    
    // 在绑定属性时，如果配置节的 Key 找不到对应的同名属性时（忽略大小写），是否抛出异常
    public bool ErrorOnUnknownConfiguration { get; set; }
}
```

- BindingPoint  

```C#
// 绑定上下文
// 用来在绑定配置时存储解析出的配置值
internal sealed class BindingPoint
{
    // 初始值提供者
    private readonly Func<object?>? _initialValueProvider;
    // 初始值
    private object? _initialValue;
    // 外部设置值
    private object? _setValue;
    // 已通过从外部设置值
    private bool _valueSet;

    public BindingPoint(object? initialValue = null, bool isReadOnly = false)
    {
        _initialValue = initialValue;
        IsReadOnly = isReadOnly;
    }

    public BindingPoint(Func<object?> initialValueProvider, bool isReadOnly)
    {
        _initialValueProvider = initialValueProvider;
        IsReadOnly = isReadOnly;
    }

    // 是否只读
    public bool IsReadOnly { get; }

    // 是否由外部设置过新值
    public bool HasNewValue
    {
        get
        {
            if (IsReadOnly)
            {
                return false;
            }

            if (_valueSet)
            {
                return true;
            }

            // 可变值类型（自定义的结构）返回 true
            // 原始值类型都属于不可变值类型（初始化结构后不能修改）
            return _initialValue?.GetType() is { } initialValueType
                && initialValueType.IsValueType
                && !initialValueType.IsPrimitive;
        }
    }

    // 按优先顺序从外部设置新值、初始值、初始值提供者得到配置值
    public object? Value => _valueSet ? _setValue : _initialValue ??= _initialValueProvider?.Invoke();

    // 从外部设置值
    public void SetValue(object? newValue)
    {
        Debug.Assert(!IsReadOnly);
        Debug.Assert(!_valueSet);
        _setValue = newValue;
        _valueSet = true;
    }

    // 尝试从外部设置值
    public void TrySetValue(object? newValue)
    {
        if (!IsReadOnly)
        {
            SetValue(newValue);
        }
    }
}
```
