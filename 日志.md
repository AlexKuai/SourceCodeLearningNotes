## 源码涉及的核心类型
- EventId  
- LogLevel  
- ILogger  
- Logger  
- ILogger\<\>  
- Logger\<\>  
- LoggerInformation  
- MessageLogger  
- ScopeLogger  
- LoggerFactoryOptions  
- LoggerFilterOptions  
- LoggerFilterRule  
- ILoggerFactory  
- LoggerFactory  
- ILoggerProvider  
- IExternalScopeProvider  
- LoggerFactoryScopeProvider  
- Scope  
- LoggerMessage  
- LoggingServiceCollectionExtensions  
- LoggingBuilder  
- LoggingBuilderExtensions  
- LoggingBuilderConfigurationExtensions  
- ILoggerProviderConfigurationFactory  
- LoggerProviderConfigurationFactory  
- ILoggerProviderConfiguration\<\>  
- LoggerProviderConfiguration\<\>  
- LoggerProviderOptions  
- LoggerProviderConfigureOptions\<,\>  
- LoggerProviderOptionsChangeTokenSource\<,\>  
- FilterLoggingBuilderExtensions  
- LoggerExtensions  
- ConsoleLoggerProvider  
- ConsoleLogger  
- LogEntry\<\>  
- ConsoleLoggerOptions  
- ConsoleFormatter  

## 日志模型

- EventId  
```C#
// 表示日志事件的 ID 和 Name
public readonly struct EventId : IEquatable<EventId>
{
    // 重载隐式转换操作（支持 int 隐式转换为 EventId 类型）
    public static implicit operator EventId(int i)
    {
        return new EventId(i);
    }

    // 重载 == 运算符
    public static bool operator ==(EventId left, EventId right)
    {
        return left.Equals(right);
    }

    // 重载 != 运算符
    public static bool operator !=(EventId left, EventId right)
    {
        return !left.Equals(right);
    }

    // name 默认为 null
    public EventId(int id, string? name = null)
    {
        Id = id;
        Name = name;
    }

    // 事件 ID
    public int Id { get; }

    // 事件 Name
    public string? Name { get; }

    // 重写 ToString
    public override string ToString()
    {
        return Name ?? Id.ToString();
    }

    // 实现 IEquatable<EventId>
    public bool Equals(EventId other)
    {
        return Id == other.Id;
    }

    // 重写 Equals
    public override bool Equals(object? obj)
    {
        if (obj is null)
        {
            return false;
        }

        return obj is EventId eventId && Equals(eventId);
    }

    // 重写 GetHashCode
    public override int GetHashCode()
    {
        return Id;
    }
}
```

- LogLevel  
```C#
// 日志事件等级
// 严重程度由低到高（除 None 以外）
public enum LogLevel
{
    Trace = 0,
    Debug = 1,
    Information = 2,
    Warning = 3,
    Error = 4,
    Critical = 5,
    None = 6
}
```

- ILogger  
```C#
// 日志记录器接口
public interface ILogger
{
    // 为应用程序提供的日志写入方法
    void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter);

    // 日志事件等级检查方法（基于最低日志事件等级过滤屏蔽）
    bool IsEnabled(LogLevel logLevel);

    // 日志范围开始方法（记录活动跟踪）
    IDisposable? BeginScope<TState>(TState state) where TState : notnull;
}
```

- Logger  
```C#
// ILogger 的默认实现
// 提供应用程序发送日志事件的入口对象
internal sealed class Logger : ILogger
{
    public Logger(LoggerInformation[] loggers) => Loggers = loggers;

    // 数组的元素数量与注册的 ILoggerProvider 数量一致
    public LoggerInformation[] Loggers { get; set; }
    // 数组的元素数量与注册的 ILoggerProvider 数量一致
    public MessageLogger[]? MessageLoggers { get; set; }
    // 数组的元素数量与注册的 ILoggerProvider 数量可能不一致
    // 如果注册的 ILoggerProvider 没有一个实现了 ISupportExternalScope 接口，则数量一致
    // 如果注册的 ILoggerProvider 至少有一个实现了 ISupportExternalScope 接口，则数量就会少于注册的 ILoggerProvider 数量
    // 因为实现了 ISupportExternalScope 接口的所有 ILoggerProvider 本质上共用一个 IExternalScopeProvider 来提供日志范围的活动跟踪
    public ScopeLogger[]? ScopeLoggers { get; set; }

    // 作为提供应用程序发送日志事件的入口函数
    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        MessageLogger[]? loggers = MessageLoggers;
        if (loggers == null)
        {
            return;
        }

        List<Exception>? exceptions = null;
        for (int i = 0; i < loggers.Length; i++)
        {
            ref readonly MessageLogger loggerInfo = ref loggers[i];
            // 根据最低日志等级过滤屏蔽日志事件输出
            if (!loggerInfo.IsEnabled(logLevel))
            {
                continue;
            }

            // 使用由 ILoggerProvider 创建的 ILogger 发送日志事件
            LoggerLog(logLevel, eventId, loggerInfo.Logger, exception, formatter, ref exceptions, state);
        }

        if (exceptions != null && exceptions.Count > 0)
        {
            ThrowLoggingError(exceptions);
        }

        // 调用由 ILoggerProvider 创建的 ILogger 使用对应的日志事件源发送日志事件
        static void LoggerLog(LogLevel logLevel, EventId eventId, ILogger logger, Exception? exception, Func<TState, Exception?, string> formatter, ref List<Exception>? exceptions, in TState state)
        {
            try
            {
                logger.Log(logLevel, eventId, state, exception, formatter);
            }
            catch (Exception ex)
            {
                exceptions ??= new List<Exception>();
                exceptions.Add(ex);
            }
        }
    }

    // 可以利用此方法检查是否存在至少一个满足最低日志事件等级或过滤规则的 ILogger
    // 即可以将日志事件交给至少一个由 ILoggerProvider 创建的 ILogger 处理
    public bool IsEnabled(LogLevel logLevel)
    {
        MessageLogger[]? loggers = MessageLoggers;
        if (loggers == null)
        {
            return false;
        }

        List<Exception>? exceptions = null;
        int i = 0;
        for (; i < loggers.Length; i++)
        {
            ref readonly MessageLogger loggerInfo = ref loggers[i];
            if (!loggerInfo.IsEnabled(logLevel))
            {
                continue;
            }

            // 继续使用由 ILoggerProvider 创建的 ILogger 检查是否满足最低日志事件等级或其他过滤规则
            if (LoggerIsEnabled(logLevel, loggerInfo.Logger, ref exceptions))
            {
                break;
            }
        }

        if (exceptions != null && exceptions.Count > 0)
        {
            ThrowLoggingError(exceptions);
        }

        // i < loggers.Length 表明至少有一个由 ILoggerProvider 创建的 ILogger 满足最低日志事件等级或过滤规则，可以发送日志事件
        return i < loggers.Length ? true : false;

        static bool LoggerIsEnabled(LogLevel logLevel, ILogger logger, ref List<Exception>? exceptions)
        {
            try
            {
                if (logger.IsEnabled(logLevel))
                {
                    return true;
                }
            }
            catch (Exception ex)
            {
                exceptions ??= new List<Exception>();
                exceptions.Add(ex);
            }

            return false;
        }
    }

    // 开始一个日志范围
    // 本质上就是由 ILoggerProvider 创建的 ILogger 来创建一个表示日志范围的结构
    // 当前日志范围的结构指向父日志范围的结构形成一个单向链表（父范围 <- 当前范围），并利用 AsyncLocal<T> 保存来实现在不同线程间传递
    public IDisposable? BeginScope<TState>(TState state) where TState : notnull
    {
        ScopeLogger[]? loggers = ScopeLoggers;

        if (loggers == null)
        {
            return NullScope.Instance;
        }

        if (loggers.Length == 1)
        {
            return loggers[0].CreateScope(state);
        }

        var scope = new Scope(loggers.Length);
        List<Exception>? exceptions = null;
        for (int i = 0; i < loggers.Length; i++)
        {
            ref readonly ScopeLogger scopeLogger = ref loggers[i];

            try
            {
                // 代表日志范围的结构实现了 IDisposable 接口
                // 可以在范围结束时通过调用 IDisposable.Dispose 方法完成当前范围的出栈操作
                scope.SetDisposable(i, scopeLogger.CreateScope(state));
            }
            catch (Exception ex)
            {
                exceptions ??= new List<Exception>();
                exceptions.Add(ex);
            }
        }

        if (exceptions != null && exceptions.Count > 0)
        {
            ThrowLoggingError(exceptions);
        }

        return scope;
    }

    private static void ThrowLoggingError(List<Exception> exceptions)
    {
        throw new AggregateException(
            message: "An error occurred while writing to logger(s).", innerExceptions: exceptions);
    }
}
```

- ILogger\<\>  
```C#
// 便于利用依赖注入方式使用日志
// 泛型参数可以将组件、服务等类型作为日志类别
public interface ILogger<out TCategoryName> : ILogger
{

}
```

- Logger\<\>  
```C#
// ILogger<> 默认实现
// 本质是 ILogger 的包装类型
// 利用泛型强类型名称表示日志类别
// 便于将组件、服务等类型作为日志类别
// 内部实际是对 ILogger 方法的调用
public class Logger<T> : ILogger<T>
{
    private readonly ILogger _logger;

    public Logger(ILoggerFactory factory)
    {
        ThrowHelper.ThrowIfNull(factory);

        // 类型名称作为日志类别时使用显示名称，如果是泛型类型则不包含泛型参数类型，内嵌类型使用 . 号分割
        _logger = factory.CreateLogger(TypeNameHelper.GetTypeDisplayName(typeof(T), includeGenericParameters: false, nestedTypeDelimiter: '.'));
    }

    void ILogger.Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        _logger.Log(logLevel, eventId, state, exception, formatter);
    }

    bool ILogger.IsEnabled(LogLevel logLevel)
    {
        return _logger.IsEnabled(logLevel);
    }

    IDisposable? ILogger.BeginScope<TState>(TState state)
    {
        return _logger.BeginScope(state);
    }
}
```

- LoggerInformation  
```C#
// 日志信息
// 每个日志类别和不同 ILoggerProvider 的组合对应一个 ILogger
internal readonly struct LoggerInformation
{
    public LoggerInformation(ILoggerProvider provider, string category) : this()
    {
        ProviderType = provider.GetType();
        Logger = provider.CreateLogger(category);
        Category = category;
        ExternalScope = provider is ISupportExternalScope;
    }
    
    // 由 ILoggerProvider 创建的 ILogger
    // ILogger 内部通过对应的日志事件源发送日志事件
    // 订阅者（观察者）收到日志事件后将其输出到相应的渠道
    public ILogger Logger { get; }

    // 日志类别
    public string Category { get; }

    // ILoggerProvider 具体类型
    public Type ProviderType { get; }

    // ILoggerProvider 是否实现了 ISupportExternalScope 接口
    // 实现了 ISupportExternalScope 接口就表明需要借助 IExternalScopeProvider 来提供日志范围的活动跟踪
    // 没有实现的 ILoggerProvider 代表自身可以提供日志范围的活动跟踪
    public bool ExternalScope { get; }
}
```

- MessageLogger  
```C#
// 消息日志
// 利用 ILoggerProvider 全名、日志类别、日志等级过滤日志
internal readonly struct MessageLogger
{
    // 用来过滤日志
    // 根据传入的 category、providerTypeFullName 
    // 与 LoggingFilterRule 中的 ProviderName、CategoryName 匹配得到对应的 LogLevel 和 Filter
    // 作为 minLevel、filter
    public MessageLogger(ILogger logger, string? category, string? providerTypeFullName, LogLevel? minLevel, Func<string?, string?, LogLevel, bool>? filter)
    {
        Logger = logger;
        Category = category;
        ProviderTypeFullName = providerTypeFullName;
        MinLevel = minLevel;
        Filter = filter;
    }

    // 由 ILoggerProvider 创建的 ILogger
    public ILogger Logger { get; }

    // 日志类别
    public string? Category { get; }

    // ILoggerProvider 全名
    // 可以使用 ProviderAliasAttribute 特性配置对应的别名
    private string? ProviderTypeFullName { get; }

    // 通过 Category 和 ProviderTypeFullName 根据最优筛选逻辑得到的最优 LoggerFilterRule 中的 LogLevel 属性值
    public LogLevel? MinLevel { get; }

    // 通过 Category 和 ProviderTypeFullName 根据最优筛选逻辑得到的最优 LoggerFilterRule 中的 Filter 属性值
    public Func<string?, string?, LogLevel, bool>? Filter { get; }

    // 根据最低日志等级和过滤规则方法方法过滤发送的日志事件
    public bool IsEnabled(LogLevel level)
    {
        // 不满足最低日志级别直接返回 false
        if (MinLevel != null && level < MinLevel)
        {
            return false;
        }

        // 如果存在过滤方法则继续检查
        if (Filter != null)
        {
            return Filter(ProviderTypeFullName, Category, level);
        }

        return true;
    }
}
```

- ScopeLogger  
```C#
// 范围日志
// 如果 ILoggerProvider 实现了 ISupportExternalScope 接口就表明其自身不具有日志范围的活动跟踪
// 这时候就需要通过 IExternalScopeProvider 来提供日志范围的活动跟踪
internal readonly struct ScopeLogger
{
    public ScopeLogger(ILogger? logger, IExternalScopeProvider? externalScopeProvider)
    {
        Debug.Assert(logger != null || externalScopeProvider != null, "Logger can't be null when there isn't an ExternalScopeProvider");

        Logger = logger;
        ExternalScopeProvider = externalScopeProvider;
    }

    // 由 ILoggerProvider 创建的 ILogger
    public ILogger? Logger { get; }

    // 实现 IExternalScopeProvider 的范围提供者
    public IExternalScopeProvider? ExternalScopeProvider { get; }

    // 创建日志范围
    // 实现的核心就是创建当前日志范围的结构并指向父日志范围的结构形成一个单向链表（父范围 <- 当前范围），并利用 AsyncLocal<T> 保存来实现在不同线程间传递
    public IDisposable? CreateScope<TState>(TState state) where TState : notnull
    {
        if (ExternalScopeProvider != null)
        {
            return ExternalScopeProvider.Push(state);
        }

        Debug.Assert(Logger != null);
        return Logger.BeginScope<TState>(state);
    }
}
```

- LoggerFactoryOptions  
```C#
// 日志工厂选项
// 主要用来配置活动跟踪时的信息组织
public class LoggerFactoryOptions
{
    public LoggerFactoryOptions() { }

    // 活动跟踪选项
    // ActivityTrackingOptions 是一个带有位标志的枚举类型
    public ActivityTrackingOptions ActivityTrackingOptions { get; set; }
}
```

- LoggerFilterOptions  
```C#
// 日志过滤选项
public class LoggerFilterOptions
{
    public LoggerFilterOptions() { }

    // 是否启用日志范围的活动跟踪
    public bool CaptureScopes { get; set; } = true;

    // 全局最小日志等级
    public LogLevel MinLevel { get; set; }

    // 日志过滤规则集合
    public IList<LoggerFilterRule> Rules => RulesInternal;

    internal List<LoggerFilterRule> RulesInternal { get; } = new List<LoggerFilterRule>();
}
```

- LoggerFilterRule  
```C#
public class LoggerFilterRule
{
    // 通过调用 ILoggingBuilder.AddConfiguration 方法从配置文件中得到的 providerName、categoryName、logLevel
    // 通过调用 ILoggingBuilder.AddFilter 方法配置得到的 providerName、categoryName、filter
    public LoggerFilterRule(string? providerName, string? categoryName, LogLevel? logLevel, Func<string?, string?, LogLevel, bool>? filter)
    {
        ProviderName = providerName;
        CategoryName = categoryName;
        LogLevel = logLevel;
        Filter = filter;
    }

    public string? ProviderName { get; }

    public string? CategoryName { get; }

    public LogLevel? LogLevel { get; }

    public Func<string?, string?, LogLevel, bool>? Filter { get; }

    public override string ToString()
    {
        return $"{nameof(ProviderName)}: '{ProviderName}', {nameof(CategoryName)}: '{CategoryName}', {nameof(LogLevel)}: '{LogLevel}', {nameof(Filter)}: '{Filter}'";
    }
}
```

- ILoggerFactory  
```C#
// Logger 工厂的抽象表示
public interface ILoggerFactory : IDisposable
{
    // 根据 categoryName 创建对应日志类别的 ILogger
    // 创建的 ILogger 只是提供应用程序发送日志事件的入口作用
    ILogger CreateLogger(string categoryName);

    // 添加 ILoggerProvider
    void AddProvider(ILoggerProvider provider);
}
```

- LoggerFactory  
```C#
// ILoggerFactory 的默认实现
public class LoggerFactory : ILoggerFactory
{
    // 缓存根据不同日志类别创建的 ILogger
    private readonly Dictionary<string, Logger> _loggers = new Dictionary<string, Logger>(StringComparer.Ordinal);
    // ILoggerPrivider 注册列表
    private readonly List<ProviderRegistration> _providerRegistrations = new List<ProviderRegistration>();
    // 同步锁
    private readonly object _sync = new object();
    // 是否执行过释放操作标志
    private volatile bool _disposed;
    // 用来取消通过 IOptionsMonitor<LoggerFilterOptions>.OnChange 方法注册的回调
    private IDisposable? _changeTokenRegistration;
    // 日志过滤选项
    private LoggerFilterOptions _filterOptions;
    // 全局的外部范围提供者
    private IExternalScopeProvider? _scopeProvider;
    // 日志工厂选项
    // 主要作用是配置活动跟踪选项
    private LoggerFactoryOptions _factoryOptions;

    public LoggerFactory() : this(Array.Empty<ILoggerProvider>())
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers) : this(providers, new StaticFilterOptionsMonitor(new LoggerFilterOptions()))
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers, LoggerFilterOptions filterOptions) : this(providers, new StaticFilterOptionsMonitor(filterOptions))
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption) : this(providers, filterOption, null)
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions>? options) : this(providers, filterOption, options, null)
    {
    }

    // 依赖注入框架会选取此为最优构造函数
    // 参数：
    // 1. 所有注册的 ILoggerProvider
    // 2. LoggerFilterOptions 选项的配置可能来源于文件，所以需要监控文件改变的 IOptionsMonitor<LoggerFilterOptions>
    // 3. 启用日志范围后需要记录哪些活动跟踪信息的 LoggerFactoryOptions 选项，由 IOptions<LoggerFactoryOptions> 提供
    // 4. 外部日志范围提供者 IExternalScopeProvider
    public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions>? options = null, IExternalScopeProvider? scopeProvider = null)
    {
        // 初始化全局默认的 IExternalScopeProvider
        _scopeProvider = scopeProvider;

        // 可能未注册 LoggerFactoryOptions 的选项配置
        _factoryOptions = options == null || options.Value == null ? new LoggerFactoryOptions() : options.Value;

        // 对除 None 以外的所有枚举按位或后取非
        const ActivityTrackingOptions ActivityTrackingOptionsMask = ~(ActivityTrackingOptions.SpanId | 
                                                                      ActivityTrackingOptions.TraceId | 
                                                                      ActivityTrackingOptions.ParentId |
                                                                      ActivityTrackingOptions.TraceFlags | 
                                                                      ActivityTrackingOptions.TraceState | 
                                                                      ActivityTrackingOptions.Tags | 
                                                                      ActivityTrackingOptions.Baggage);

        // 如果和上面 ActivityTrackingOptionsMask 按位与操作后不为零，表明配置了未定义的枚举值，则抛出 ArgumentException
        if ((_factoryOptions.ActivityTrackingOptions & ActivityTrackingOptionsMask) != 0)
        {
            throw new ArgumentException(SR.Format(SR.InvalidActivityTrackingOptions, _factoryOptions.ActivityTrackingOptions), nameof(options));
        }
        // 遍历所有注册的 ILoggerPrivider，添加进注册中心
        foreach (ILoggerProvider provider in providers)
        {
            // 如果是实现了 ISupportExternalScope 接口的 ILoggerProvider
            // 则需要对其设置 IExternalScopeProvider 提供日志范围的活动跟踪
            AddProviderRegistration(provider, dispose: false);
        }
        
        // 监控日志过滤规则配置文件的改变
        // 在改变后重新获取 LoggerFilterOptions 并刷新应用过滤规则
        _changeTokenRegistration = filterOption.OnChange(RefreshFilters);
        // 初始化使用 IOptionsMonitor<LoggerFilterOptions> 的 CurrentValue（空字符串命名）获取选项
        // 刷新应用过滤规则
        RefreshFilters(filterOption.CurrentValue);
    }

    // 刷新应用规则
    private void RefreshFilters(LoggerFilterOptions filterOptions)
    {
        lock (_sync)
        {
            // 更新 LoggerFilterOptions
            _filterOptions = filterOptions;
            foreach (KeyValuePair<string, Logger> registeredLogger in _loggers)
            {
                Logger logger = registeredLogger.Value;
                // 应用新的过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);
            }
        }
    }

    // 根据 categoryName 日志类别创建获取 ILogger
    public ILogger CreateLogger(string categoryName)
    {
        if (CheckDisposed())
        {
            throw new ObjectDisposedException(nameof(LoggerFactory));
        }

        // 在并发情况下创建对应日志类别的 ILogger 和应用新的过滤规则需要同步完成
        lock (_sync)
        {
            if (!_loggers.TryGetValue(categoryName, out Logger? logger))
            {
                // 基于日志类别创建 ILogger
                // 利用 CreateLoggers 方法创建 LoggerInformation 数组
                logger = new Logger(CreateLoggers(categoryName));

                // 应用过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);

                // 添加新的日志类别和对应的 ILogger
                _loggers[categoryName] = logger;
            }

            return logger;
        }
    }

    // 添加新的 ILoggerProvider
    public void AddProvider(ILoggerProvider provider)
    {
        if (CheckDisposed())
        {
            throw new ObjectDisposedException(nameof(LoggerFactory));
        }

        ThrowHelper.ThrowIfNull(provider);

        // 在并发情况下 ILogger 的创建需要同步完成
        lock (_sync)
        {
            // 添加进注册中心
            AddProviderRegistration(provider, dispose: true);
            // 遍历所有已经创建的 Logger
            // 利用新添加的 ILoggerProvider 创建新的 LoggerInformation，并应用过滤规则
            foreach (KeyValuePair<string, Logger> existingLogger in _loggers)
            {
                Logger logger = existingLogger.Value;
                LoggerInformation[] loggerInformation = logger.Loggers;

                int newLoggerIndex = loggerInformation.Length;
                // 扩容数组
                Array.Resize(ref loggerInformation, loggerInformation.Length + 1);
                // 根据 ILoggerProvider 和日志类别的组合创建新的 LoggerInformation，并添加到添加到末尾
                loggerInformation[newLoggerIndex] = new LoggerInformation(provider, existingLogger.Key);

                logger.Loggers = loggerInformation;
                // 应用过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);
            }
        }
    }

    // 将 ILoggerProvider 添加进列表
    // 便于维护和释放
    private void AddProviderRegistration(ILoggerProvider provider, bool dispose)
    {
        _providerRegistrations.Add(new ProviderRegistration
        {
            Provider = provider,
            ShouldDispose = dispose
        });

        // 如果 ILoggerProvider 实现了 ISupportExternalScope 
        // 就为 ILoggerProvider 添加 LoggerFactoryScopeProvider（LoggerFactoryScopeProvider 实现了 IExternalScopeProvider）
        // 利用 IExternalScopeProvider 为 ILoggerProvider 提供基于范围的活动跟踪
        if (provider is ISupportExternalScope supportsExternalScope)
        {
            // 利用 ActivityTrackingOptions 创建 LoggerFactoryScopeProvider
            // 作为全局默认 IExternalScopeProvider
            _scopeProvider ??= new LoggerFactoryScopeProvider(_factoryOptions.ActivityTrackingOptions);

            supportsExternalScope.SetScopeProvider(_scopeProvider);
        }
    }

    // 利用 categoryName 和所有已注册的 ILoggerProvider 创建 LoggerInformation 数组
    private LoggerInformation[] CreateLoggers(string categoryName)
    {
        var loggers = new LoggerInformation[_providerRegistrations.Count];
        for (int i = 0; i < _providerRegistrations.Count; i++)
        {
            loggers[i] = new LoggerInformation(_providerRegistrations[i].Provider, categoryName);
        }
        return loggers;
    }

    // 应用过滤规则
    private (MessageLogger[] MessageLoggers, ScopeLogger[]? ScopeLoggers) ApplyFilters(LoggerInformation[] loggers)
    {
        var messageLoggers = new List<MessageLogger>();
        // 根据 LoggerFilterOptions.CaptureScopes 属性决定是否启用日志范围的活动跟踪，这个属性默认值为 true
        // 启用情况下才需要创建 ScopeLogger 集合，否则将不存在任何 ScopeLogger 用来创建代表日志范围的结构
        List<ScopeLogger>? scopeLoggers = _filterOptions.CaptureScopes ? new List<ScopeLogger>() : null;

        foreach (LoggerInformation loggerInformation in loggers)
        {
            // 选择最优的 LoggerFilterRule
            // 匹配规则：
            // 1. 具体的针对 ILoggerProvider 的规则优先级高于默认规则
            // 2. 日志类别基于前缀匹配规则（对于 Foo.Bar.Baz 的日志类别，配置中 Foo.Bar 的规则比 Foo 的规则优先级更高）
            // 3. 有多个优先级相同的规则选择最后一个
            // 4. 以上规则没有匹配到则使用全局最低日志等级 LoggerFilterOptions.MinLevel
            LoggerRuleSelector.Select(_filterOptions,
                loggerInformation.ProviderType,
                loggerInformation.Category,
                out LogLevel? minLevel,
                out Func<string?, string?, LogLevel, bool>? filter);

            // 无效的最低日志等级
            if (minLevel is not null and > LogLevel.Critical)
            {
                continue;
            }

            messageLoggers.Add(new MessageLogger(loggerInformation.Logger, loggerInformation.Category, loggerInformation.ProviderType.FullName, minLevel, filter));

            // 不需要由 IExternalScopeProvider 提供日志范围的活动跟踪
            // 直接使用 ILoggerProvider 创建的 ILogger 构建 ScopeLogger
            if (!loggerInformation.ExternalScope)
            {
                scopeLoggers?.Add(new ScopeLogger(logger: loggerInformation.Logger, externalScopeProvider: null));
            }
        }

        // 是否有提供默认的 IExternalScopeProvider
        // 如果有表明存在实现了 ISupportExternalScope 接口的 IServiceProvider 被注册，需要由 IExternalScopeProvider 来提供日志范围的活动跟踪
        // 一个日志类别相关的 ILogger 只需要创建一个 ScopeLogger 保存 IExternalScopeProvider 即可
        // 其实全局也只有一个 IExternalScopeProvider 实例
        if (_scopeProvider != null)
        {
            scopeLoggers?.Add(new ScopeLogger(logger: null, externalScopeProvider: _scopeProvider));
        }

        return (messageLoggers.ToArray(), scopeLoggers?.ToArray());
    }

    // 创建一个独立的 ILoggerFactory（DisposingLoggerFactory）的静态工具方法
    // 包装了 ServiceProvider 和 ILoggerFactory
    // 并在内部实现 IDisposable 接口用来释放 ServiceProvider 和 ILoggerFactory
    public static ILoggerFactory Create(Action<ILoggingBuilder> configure)
    {
        var serviceCollection = new ServiceCollection();
        serviceCollection.AddLogging(configure);
        ServiceProvider serviceProvider = serviceCollection.BuildServiceProvider();
        ILoggerFactory loggerFactory = serviceProvider.GetRequiredService<ILoggerFactory>();
        return new DisposingLoggerFactory(loggerFactory, serviceProvider);
    }

    // 检查是否已经执行过释放
    protected virtual bool CheckDisposed() => _disposed;

    // 释放
    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;

            _changeTokenRegistration?.Dispose();

            foreach (ProviderRegistration registration in _providerRegistrations)
            {
                try
                {
                    if (registration.ShouldDispose)
                    {
                        registration.Provider.Dispose();
                    }
                }
                catch
                {

                }
            }
        }
    }

    private struct ProviderRegistration
    {
        public ILoggerProvider Provider;
        public bool ShouldDispose;
    }
}
```

- ILoggerProvider  
```C#
// LoggerProvider 的抽象表示
public interface ILoggerProvider : IDisposable
{
    // 根据 categoryName 创建对应日志类别的 ILogger
    // 和 ILoggerFactory 中的 CreateLogger 方法不同
    // 此处创建是针对具体日志输出渠道的 ILogger
    ILogger CreateLogger(string categoryName);
}
```

- IExternalScopeProvider  
```C#
public interface IExternalScopeProvider
{
    // 遍历从根范围到当前范围，使用范围日志的内容载荷 Scope.State 发出 callback 回调
    void ForEachScope<TState>(Action<object?, TState> callback, TState state);

    // 新建一个范围结构（可以理解为压栈操作）
    // 核心是创建一个新的范围结构，并将当前范围结构保存到新范围结构的 Parent 属性中，作为父范围
    // 将新创建的范围结构作为当前范围存储到 AsyncLocal<> 中
    IDisposable Push(object? state);
}
```

- LoggerFactoryScopeProvider  
```C#
// IExternalScopeProvider 的默认实现
// 用来管理范围的入栈和出栈
internal sealed class LoggerFactoryScopeProvider : IExternalScopeProvider
{
    // 此处可以使用 static readonly
    // 类似 Activity 类中的 s_current 一样
    // private static readonly AsyncLocal<Activity?> s_current = new AsyncLocal<Activity?>();
    private readonly AsyncLocal<Scope?> _currentScope = new AsyncLocal<Scope?>();
    private readonly ActivityTrackingOptions _activityTrackingOption;

    public void ForEachScope<TState>(Action<object?, TState> callback, TState state)
    {
        void Report(Scope? current)
        {
            if (current == null)
            {
                return;
            }
            Report(current.Parent);
            callback(current.State, state);
        }

        if (_activityTrackingOption != ActivityTrackingOptions.None)
        {
            Activity? activity = Activity.Current;
            // 如果 activity != null，则表明是通过调用 Activity.Start 方法开始日志范围
            if (activity != null)
            {
                const string propertyKey = "__ActivityLogScope__";

                ActivityLogScope? activityLogScope = activity.GetCustomProperty(propertyKey) as ActivityLogScope;
                if (activityLogScope == null)
                {
                    activityLogScope = new ActivityLogScope(activity, _activityTrackingOption);
                    activity.SetCustomProperty(propertyKey, activityLogScope);
                }

                callback(activityLogScope, state);

                if ((_activityTrackingOption & ActivityTrackingOptions.Tags) != 0
                    && activity.TagObjects.GetEnumerator().MoveNext())
                {
                    callback(activity.TagObjects, state);
                }

                if ((_activityTrackingOption & ActivityTrackingOptions.Baggage) != 0)
                {
                    IEnumerable<KeyValuePair<string, string?>> baggage = activity.Baggage;
                    if (baggage.GetEnumerator().MoveNext())
                    {
                        ActivityBaggageLogScopeWrapper scope = GetOrCreateActivityBaggageLogScopeWrapper(activity, baggage);
                        callback(scope, state);
                    }
                }
            }
        }

        // 如果使用 Activity.Start 方法开始日志范围，则 _currentScope.Value 就等于 null（因为开始日志范围不是通过调用 ILogger.BeginScope 方法）
        // Report 方法将直接返回
        Report(_currentScope.Value);
    }

    // 新建一个范围，并压栈
    public IDisposable Push(object? state)
    {
        // 当前范围作为父范围
        Scope? parent = _currentScope.Value;
        // 新建一个范围
        var newScope = new Scope(this, state, parent);
        // 将新建的范围保存到 AsyncLocal<> 中，作为当前范围
        _currentScope.Value = newScope;

        return newScope;
    }
}
```

- Scope  
```C#
// 表示日志范围的数据结构
// 实现 IDisposable.Dispose 方法（用来完成日志范围的出栈）
private sealed class Scope : IDisposable
{
    // IExternalScopeProvider
    private readonly LoggerFactoryScopeProvider _provider;
    private bool _isDisposed;

    internal Scope(LoggerFactoryScopeProvider provider, object? state, Scope? parent)
    {
        _provider = provider;
        State = state;
        Parent = parent;
    }

    // 父范围
    public Scope? Parent { get; }

    public object? State { get; }

    public override string? ToString()
    {
        return State?.ToString();
    }

    // 将父范围保存到 AsyncLocal<> 中，实现当前范围的出栈
    public void Dispose()
    {
        if (!_isDisposed)
        {
            _provider._currentScope.Value = Parent;
            _isDisposed = true;
        }
    }
}
```

- LoggerMessage  
```C#
// 提供基于占位符的日志消息模板方法
// 可以避免消息模板的重复解析
public static class LoggerMessage
{
    // 利用模板字符串得到发送日志事件消息的委托（最全参数签名）
    // formateString 支持 {数字} 和 {文本} 占位符
    public static Action<ILogger, T1, T2, T3, T4, T5, T6, Exception?> Define<T1, T2, T3, T4, T5, T6>(LogLevel logLevel, EventId eventId, string formatString, LogDefineOptions? options)
    {
        // 根据消息模板字符串解析得到格式化器
        // 不管是使用 {数字} 或 {文本} 占位符，内部最终会转换为 string.Format 方法所支持的以参数索引形式的格式化字符串
        LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, expectedNamedParameterCount: 6);

        // 编译器会根据闭包变量 formatter、logLevel、eventId 和泛型参数创建内部匿名泛型类型
        // 避免重复解析的关键就是通过编译时生成的内部匿名泛型类型
        // 用于在运行时保存已解析消息模板的 LogValuesFormatter
        void Log(ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, Exception? exception)
        {
            logger.Log(logLevel, eventId, new LogValues<T1, T2, T3, T4, T5, T6>(formatter, arg1, arg2, arg3, arg4, arg5, arg6), exception, LogValues<T1, T2, T3, T4, T5, T6>.Callback);
        }

        // 是否跳过 IsEnable 检查
        if (options != null && options.SkipEnabledCheck)
        {
            return Log;
        }

        // 需要执行 IsEnable 检查
        // 确定是否至少有一个由 ILoggerProvider 创建的 ILogger 可以发送日志事件消息
        return (logger, arg1, arg2, arg3, arg4, arg5, arg6, exception) =>
        {
            if (logger.IsEnabled(logLevel))
            {
                Log(logger, arg1, arg2, arg3, arg4, arg5, arg6, exception);
            }
        };
    }

    // 利用模板字符串得到开始日志范围消息的委托（最全参数签名）
    // formateString 支持 {数字} 和 {文本} 占位符
    public static Func<ILogger, T1, T2, T3, T4, T5, T6, IDisposable?> DefineScope<T1, T2, T3, T4, T5, T6>(string formatString)
    {
        LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, expectedNamedParameterCount: 6);

        return (logger, arg1, arg2, arg3, arg4, arg5, arg6) => logger.BeginScope(new LogValues<T1, T2, T3, T4, T5, T6>(formatter, arg1, arg2, arg3, arg4, arg5, arg6));
    }

    // 记录日志事件的荷载
    // 利用格式化器对日志事件消息进行格式化输出
    private readonly struct LogValues<T0, T1, T2, T3, T4, T5> : IReadOnlyList<KeyValuePair<string, object?>>
    {
        // 消息格式化委托
        // 对消息进行格式化输出
        public static readonly Func<LogValues<T0, T1, T2, T3, T4, T5>, Exception?, string> Callback = (state, exception) => state.ToString();

        private readonly LogValuesFormatter _formatter;
        private readonly T0 _value0;
        private readonly T1 _value1;
        private readonly T2 _value2;
        private readonly T3 _value3;
        private readonly T4 _value4;
        private readonly T5 _value5;

        public int Count => 7;

        public KeyValuePair<string, object?> this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[0], _value0);
                    case 1:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[1], _value1);
                    case 2:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[2], _value2);
                    case 3:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[3], _value3);
                    case 4:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[4], _value4);
                    case 5:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[5], _value5);
                    case 6:
                        return new KeyValuePair<string, object?>("{OriginalFormat}", _formatter.OriginalFormat);
                    default:
                        throw new IndexOutOfRangeException(nameof(index));
                }
            }
        }

        public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)
        {
            _formatter = formatter;
            _value0 = value0;
            _value1 = value1;
            _value2 = value2;
            _value3 = value3;
            _value4 = value4;
            _value5 = value5;
        }

        // 输出日志事件消息的参数
        private object?[] ToArray() => new object?[] { _value0, _value1, _value2, _value3, _value4, _value5 };

        // 格式化器根据解析得到的格式化字符串利用传入的参数输出格式化消息
        public override string ToString() => _formatter.FormatWithOverwrite(ToArray());

        public IEnumerator<KeyValuePair<string, object?>> GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
```

## 依赖注入

- LoggingServiceCollectionExtensions  
```C#
// 提供日志核心服务注册的扩展方法
public static class LoggingServiceCollectionExtensions
{
    public static IServiceCollection AddLogging(this IServiceCollection services)
    {
        return AddLogging(services, builder => { });
    }

    public static IServiceCollection AddLogging(this IServiceCollection services, Action<ILoggingBuilder> configure)
    {
        ThrowHelper.ThrowIfNull(services);

        // 注册选项核心服务
        services.AddOptions();

        // 注册日志工厂
        services.TryAdd(ServiceDescriptor.Singleton<ILoggerFactory, LoggerFactory>());
        // 注册泛型 ILogger<>
        services.TryAdd(ServiceDescriptor.Singleton(typeof(ILogger<>), typeof(Logger<>)));

        // 注册默认最低日志等级的选项配置
        services.TryAddEnumerable(ServiceDescriptor.Singleton<IConfigureOptions<LoggerFilterOptions>>(
            new DefaultLoggerLevelConfigureOptions(LogLevel.Information)));

        // 创建 LoggingBuilder
        configure(new LoggingBuilder(services));
        return services;
    }
}
```

- LoggingBuilder  
```C#
// 日志构建者
// 本质是对 IServiceCollection 的封装
// 便于利用其它 ILoggingBuilder 扩展方法提供日志相关服务的注册
internal sealed class LoggingBuilder : ILoggingBuilder
{
    public LoggingBuilder(IServiceCollection services)
    {
        Services = services;
    }

    public IServiceCollection Services { get; }
}
```

- LoggingBuilderExtensions  
```C#
// 基于 ILoggingBuilder 的扩展方法
// 提供日志相关服务的注册
// Microsoft.Extensions.Logging.LoggingBuilderExtensions
public static class LoggingBuilderExtensions
{
    // 注册 LoggerFilterOptions 选项配置
    // 用来设置最小日志事件等级
    public static ILoggingBuilder SetMinimumLevel(this ILoggingBuilder builder, LogLevel level)
    {
        builder.Services.Add(ServiceDescriptor.Singleton<IConfigureOptions<LoggerFilterOptions>>(
            new DefaultLoggerLevelConfigureOptions(level)));
        return builder;
    }

    // 注册 ILoggerProvider 实例
    public static ILoggingBuilder AddProvider(this ILoggingBuilder builder, ILoggerProvider provider)
    {
        builder.Services.AddSingleton(provider);
        return builder;
    }

    // 清空所有已注册的 ILoggerProvider 服务
    public static ILoggingBuilder ClearProviders(this ILoggingBuilder builder)
    {
        builder.Services.RemoveAll<ILoggerProvider>();
        return builder;
    }

    // 注册 LoggerFactoryOptions 选项配置
    // 用来设置 ActivityTrackingOptions 活动跟踪枚举
    public static ILoggingBuilder Configure(this ILoggingBuilder builder, Action<LoggerFactoryOptions> action)
    {
        builder.Services.Configure(action);
        return builder;
    }

    // 使用 IConfiguration 注册 LoggerFilterOptions 选项配置
    public static ILoggingBuilder AddConfiguration(this ILoggingBuilder builder, IConfiguration configuration)
    {
        // 注册 ILoggerProviderConfigurationFactory 和 ILoggerProviderConfiguration<> 服务
        builder.AddConfiguration();

        // 注册 LoggerFilterOptions 选项配置
        // 使用基于文件配置的选项配置来设置 LoggerFilterRule 集合
        builder.Services.AddSingleton<IConfigureOptions<LoggerFilterOptions>>(new LoggerFilterConfigureOptions(configuration));
        // 注册 IOptionsChangeTokenSource<LoggerFilterOptions> 服务
        // 通过注入 IOptionsMonitor<LoggerFilterOptions> 来得到选项，所以需要监控配置文件的变动随时更新过滤选项
        builder.Services.AddSingleton<IOptionsChangeTokenSource<LoggerFilterOptions>>(
            new ConfigurationChangeTokenSource<LoggerFilterOptions>(configuration));

        // 注册 LoggingConfiguration
        // 作为 IConfigurationRoot 的封装
        builder.Services.AddSingleton(new LoggingConfiguration(configuration));

        return builder;
    }
}
```

- LoggingBuilderConfigurationExtensions  
```C#
// 注册 ILoggerProviderConfigurationFactory 和 ILoggerProviderConfiguration<> 服务的扩展方法
public static class LoggingBuilderConfigurationExtensions
{
    public static void AddConfiguration(this ILoggingBuilder builder)
    {
        // 注册 ILoggerProviderConfigurationFactory
        builder.Services.TryAddSingleton<ILoggerProviderConfigurationFactory, LoggerProviderConfigurationFactory>();
        // 注册 ILoggerProviderConfiguration<>
        // 在服务消费时，泛型实参对应不同的 ILoggerProvider 类型
        builder.Services.TryAddSingleton(typeof(ILoggerProviderConfiguration<>), typeof(LoggerProviderConfiguration<>));
    }
}
```

- ILoggerProviderConfigurationFactory  
```C#
// ILoggerProvider 配置工厂
public interface ILoggerProviderConfigurationFactory
{
    // 根据不同的 ILoggerProvider 类型从 IConfigurationRoot 中得到对应配置节的 IConfigurationSection
    // 然后通过 IConfigurationBuilder.AddConfiguration 方法将 IConfigurationSection 构建为 ChainedConfigurationSource
    // 最终得到一个新的针对具体 ILoggerProvider 类型的 IConfigurationRoot
    IConfiguration GetConfiguration(Type providerType);
}
```

- LoggerProviderConfigurationFactory  
```C#
// ILoggerProviderConfigurationFactory 默认实现
internal sealed class LoggerProviderConfigurationFactory : ILoggerProviderConfigurationFactory
{
    private readonly IEnumerable<LoggingConfiguration> _configurations;

    public LoggerProviderConfigurationFactory(IEnumerable<LoggingConfiguration> configurations)
    {
        _configurations = configurations;
    }

    // 得到针对具体 ILoggerProvider 类型的 IConfigurationRoot
    public IConfiguration GetConfiguration(Type providerType)
    {
        ThrowHelper.ThrowIfNull(providerType);

        string fullName = providerType.FullName!;
        string? alias = ProviderAliasUtilities.GetAlias(providerType);
        // 通过创建 ConfigurationBuilder 来构建 IConfigurationRoot
        var configurationBuilder = new ConfigurationBuilder();
        foreach (LoggingConfiguration configuration in _configurations)
        {
            IConfigurationSection sectionFromFullName = configuration.Configuration.GetSection(fullName);
            configurationBuilder.AddConfiguration(sectionFromFullName);

            // 别名的配置优先级高于全名
            if (!string.IsNullOrWhiteSpace(alias))
            {
                IConfigurationSection sectionFromAlias = configuration.Configuration.GetSection(alias);
                configurationBuilder.AddConfiguration(sectionFromAlias);
            }
        }
        return configurationBuilder.Build();
    }
}
```

- ILoggerProviderConfiguration\<\>  
```C#
// ILoggerProvider 配置的抽象表示
public interface ILoggerProviderConfiguration<T>
{
    // 根据 ILoggerProvider 类型得到的 IConfigurationRoot
    IConfiguration Configuration { get; }
}
```

- LoggerProviderConfiguration\<\>  
```C#
// ILoggerProviderConfiguration<> 默认实现
internal sealed class LoggerProviderConfiguration<T> : ILoggerProviderConfiguration<T>
{
    public LoggerProviderConfiguration(ILoggerProviderConfigurationFactory providerConfigurationFactory)
    {
        // 根据 ILoggerProvider 类型得到对应的 IConfigurationRoot
        Configuration = providerConfigurationFactory.GetConfiguration(typeof(T));
    }

    public IConfiguration Configuration { get; }
}
```

- LoggerProviderOptions  
```C#
// ILoggerProvider 选项
// 由于可以通过依赖注入方式得到 ILoggerProviderConfiguration<> 并通过 Configuration 属性所引用的 IConfigurationRoot 访问配置
// 所以可以通过注册选项配置来将对应的配置绑定到选项上
// 此处没有定义为扩展方法令人费解？
public static class LoggerProviderOptions
{
    public static void RegisterProviderOptions<TOptions, TProvider>(IServiceCollection services) where TOptions : class
    {
        // 根据选项类型和 ILoggerProvider 类型注册选项配置
        services.TryAddEnumerable(ServiceDescriptor.Singleton<IConfigureOptions<TOptions>, LoggerProviderConfigureOptions<TOptions, TProvider>>());
        // 由于配置信息来源于文件，可以使用 IOptionsMonitor<> 作为依赖注入时的服务类型，并通过注册 IOptionsChangeTokenSource<> 来监控文件的变动
        // 并在变动后发出回调更新选项
        services.TryAddEnumerable(ServiceDescriptor.Singleton<IOptionsChangeTokenSource<TOptions>, LoggerProviderOptionsChangeTokenSource<TOptions, TProvider>>());
    }
}
```

- LoggerProviderConfigureOptions\<,\>  
```C#
// LoggerProviderConfigureOptions 选项
// 通过继承 ConfigureFromConfigurationOptions<> 绑定配置
internal sealed class LoggerProviderConfigureOptions<TOptions, TProvider> : ConfigureFromConfigurationOptions<TOptions> where TOptions : class
{
    public LoggerProviderConfigureOptions(ILoggerProviderConfiguration<TProvider> providerConfiguration)
        : base(providerConfiguration.Configuration)
    {
    }
}
```

- LoggerProviderOptionsChangeTokenSource\<,\>  
```C#
// 针对 ILoggerProvider 配置变化的监控
// 通过继承 ConfigurationChangeTokenSource<> 监控变化
public class LoggerProviderOptionsChangeTokenSource<TOptions, TProvider> : ConfigurationChangeTokenSource<TOptions>
{
    public LoggerProviderOptionsChangeTokenSource(ILoggerProviderConfiguration<TProvider> providerConfiguration) : base(providerConfiguration.Configuration)
    {
    }
}
```

- FilterLoggingBuilderExtensions  
```C#
// 注册 LoggerFilterOptions 选项配置的扩展方法
public static class FilterLoggingBuilderExtensions
{
    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string?, string?, LogLevel, bool> filter) =>
        builder.ConfigureFilter(options => options.AddFilter(filter));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string?, LogLevel, bool> categoryLevelFilter) =>
        builder.ConfigureFilter(options => options.AddFilter(categoryLevelFilter));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, Func<string?, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(categoryLevelFilter));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<LogLevel, bool> levelFilter) =>
        builder.ConfigureFilter(options => options.AddFilter(levelFilter));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(levelFilter));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string? category, LogLevel level) =>
        builder.ConfigureFilter(options => options.AddFilter(category, level));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string? category, LogLevel level) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(category, level));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string? category, Func<LogLevel, bool> levelFilter) =>
        builder.ConfigureFilter(options => options.AddFilter(category, levelFilter));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string? category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(category, levelFilter));

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string?, string?, LogLevel, bool> filter) =>
        AddRule(builder, filter: filter);

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string?, LogLevel, bool> categoryLevelFilter) =>
        AddRule(builder, filter: (type, name, level) => categoryLevelFilter(name, level));

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, Func<string?, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, filter: (type, name, level) => categoryLevelFilter(name, level));

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<LogLevel, bool> levelFilter) =>
        AddRule(builder, filter: (type, name, level) => levelFilter(level));

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, filter: (type, name, level) => levelFilter(level));

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string? category, LogLevel level) =>
        AddRule(builder, category: category, level: level);

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string? category, LogLevel level) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, category: category, level: level);

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string? category, Func<LogLevel, bool> levelFilter) =>
        AddRule(builder, category: category, filter: (type, name, level) => levelFilter(level));

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string? category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, category: category, filter: (type, name, level) => levelFilter(level));

    private static ILoggingBuilder ConfigureFilter(this ILoggingBuilder builder, Action<LoggerFilterOptions> configureOptions)
    {
        builder.Services.Configure(configureOptions);
        return builder;
    }

    private static LoggerFilterOptions AddRule(LoggerFilterOptions options,
        string? type = null,
        string? category = null,
        LogLevel? level = null,
        Func<string?, string?, LogLevel, bool>? filter = null)
    {
        options.Rules.Add(new LoggerFilterRule(type, category, level, filter));
        return options;
    }
}
```

- LoggerExtensions  
```C#
// 提供各种基于日志等级名称的日志记录方法
// 在运行时调用 ILogger.Log<> 方法时会将表示日志内容载荷的 TState 泛型实参指定为 FormattedLogValues
// 并统一利用 MessageFormatter 作为格式化日志消息的委托
public static class LoggerExtensions
{
    // 避免每次调用方法都要创建 Func<FormattedLogValues, Exception?, string> 实例
    private static readonly Func<FormattedLogValues, Exception?, string> _messageFormatter = MessageFormatter;

    public static void LogDebug(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, eventId, exception, message, args);
    }

    public static void LogDebug(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, eventId, message, args);
    }

    public static void LogDebug(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, exception, message, args);
    }

    public static void LogDebug(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, message, args);
    }

    public static void LogTrace(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, eventId, exception, message, args);
    }

    public static void LogTrace(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, eventId, message, args);
    }

    public static void LogTrace(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, exception, message, args);
    }

    public static void LogTrace(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, message, args);
    }

    public static void LogInformation(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, eventId, exception, message, args);
    }

    public static void LogInformation(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, eventId, message, args);
    }

    public static void LogInformation(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, exception, message, args);
    }

    public static void LogInformation(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, message, args);
    }

    public static void LogWarning(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, eventId, exception, message, args);
    }

    public static void LogWarning(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, eventId, message, args);
    }

    public static void LogWarning(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, exception, message, args);
    }

    public static void LogWarning(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, message, args);
    }

    public static void LogError(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, eventId, exception, message, args);
    }

    public static void LogError(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, eventId, message, args);
    }

    public static void LogError(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, exception, message, args);
    }

    public static void LogError(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, message, args);
    }

    public static void LogCritical(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, eventId, exception, message, args);
    }

    public static void LogCritical(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, eventId, message, args);
    }

    public static void LogCritical(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, exception, message, args);
    }

    public static void LogCritical(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, string? message, params object?[] args)
    {
        logger.Log(logLevel, 0, null, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(logLevel, eventId, null, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(logLevel, 0, exception, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        ThrowHelper.ThrowIfNull(logger);

        // 不直接使用 MessageFormatter 方法作为参数的原因是
        // 避免每次调用方法都要创建 Func<FormattedLogValues, Exception?, string> 实例
        logger.Log(logLevel, eventId, new FormattedLogValues(message, args), exception, _messageFormatter);
    }

    public static IDisposable? BeginScope(
        this ILogger logger,
        string messageFormat,
        params object?[] args)
    {
        ThrowHelper.ThrowIfNull(logger);

        return logger.BeginScope(new FormattedLogValues(messageFormat, args));
    }

    private static string MessageFormatter(FormattedLogValues state, Exception? error)
    {
        return state.ToString();
    }
}
```

## 控制台

- ConsoleLoggerProvider  
```C#
// 针对控制台的 ILoggerProvider 实现
// 别名 "Console"
[UnsupportedOSPlatform("browser")]
[ProviderAlias("Console")]
public class ConsoleLoggerProvider : ILoggerProvider, ISupportExternalScope
{
    // ConsoleLoggerOptions 选项
    private readonly IOptionsMonitor<ConsoleLoggerOptions> _options;
    // 缓存根据不同日志类别创建的 ILogger
    private readonly ConcurrentDictionary<string, ConsoleLogger> _loggers;
    // 缓存名称对应的格式化器
    // 内建的三个格式化器：
    // 1. simple
    // 2. json
    // 3. systemd
    private ConcurrentDictionary<string, ConsoleFormatter> _formatters;
    // 日志处理器，本质是利用内部的一个消息队列顺序输出日志消息
    private readonly ConsoleLoggerProcessor _messageQueue;

    // 利用 IOptionsMonitor<>.OnChange 注册回调
    // 可以通过调用 IDisposable.Dispose 取消注册
    private IDisposable? _optionsReloadToken;
    // 通过 SetScopeProvider 方法传入的 IExternalScopeProvider 
    // 默认为 NullExternalScopeProvider 表示不支持日志范围
    private IExternalScopeProvider _scopeProvider = NullExternalScopeProvider.Instance;

    public ConsoleLoggerProvider(IOptionsMonitor<ConsoleLoggerOptions> options)
            : this(options, Array.Empty<ConsoleFormatter>()) { }
 
    // 会被依赖注入框架选为最优构造函数
    public ConsoleLoggerProvider(IOptionsMonitor<ConsoleLoggerOptions> options, IEnumerable<ConsoleFormatter>? formatters)
    {
        _options = options;
        _loggers = new ConcurrentDictionary<string, ConsoleLogger>();
        // 设置格式化器
        SetFormatters(formatters);
        // 标准输出
        // 可以通过 Console.SetOut 设置标准输出使用的 TextWriter 写入器
        IConsole? console;
        // 错误输出
        // 可以通过 Console.SetError 设置错误输出使用的 TextWriter 写入器
        IConsole? errorConsole;
        // 判断是否支持 ansi 编码
        if (DoesConsoleSupportAnsi())
        {
            console = new AnsiLogConsole();
            errorConsole = new AnsiLogConsole(stdErr: true);
        }
        else
        {
            console = new AnsiParsingLogConsole();
            errorConsole = new AnsiParsingLogConsole(stdErr: true);
        }
        // 创建日志处理器
        _messageQueue = new ConsoleLoggerProcessor(
            console,
            errorConsole,
            options.CurrentValue.QueueFullMode,
            options.CurrentValue.MaxQueueLength);

        // 根据 ConsoleLoggerOptions 选项选择格式化器
        ReloadLoggerOptions(options.CurrentValue);
        _optionsReloadToken = _options.OnChange(ReloadLoggerOptions);
    }

    // 设置格式化器
    private void SetFormatters(IEnumerable<ConsoleFormatter>? formatters = null)
    {
        // 名称忽略大小写
        var cd = new ConcurrentDictionary<string, ConsoleFormatter>(StringComparer.OrdinalIgnoreCase);

        bool added = false;
        if (formatters != null)
        {
            // 将注册的格式化器添加到缓存中
            foreach (ConsoleFormatter formatter in formatters)
            {
                cd.TryAdd(formatter.Name, formatter);
                added = true;
            }
        }

        // 如果没有注册的式化器则添加三个内建的格式化器
        if (!added)
        {
            // ConsoleFormatterNames.Simple 常量对应 simple 字符串
            cd.TryAdd(ConsoleFormatterNames.Simple, new SimpleConsoleFormatter(new FormatterOptionsMonitor<SimpleConsoleFormatterOptions>(new SimpleConsoleFormatterOptions())));
            // ConsoleFormatterNames.Systemd 常量对应 systemd 字符串
            cd.TryAdd(ConsoleFormatterNames.Systemd, new SystemdConsoleFormatter(new FormatterOptionsMonitor<ConsoleFormatterOptions>(new ConsoleFormatterOptions())));
            // ConsoleFormatterNames.Json 常量对应 json 字符串
            cd.TryAdd(ConsoleFormatterNames.Json, new JsonConsoleFormatter(new FormatterOptionsMonitor<JsonConsoleFormatterOptions>(new JsonConsoleFormatterOptions())));
        }

        _formatters = cd;
    }

    // 重新加载新的 ConsoleLoggerOptions 选项
    // 并根据选项选择应用新的格式化器
    private void ReloadLoggerOptions(ConsoleLoggerOptions options)
    {
        // ConsoleLoggerOptions.FormatterName 为 null 或缓存中没有对应名称的格式化器
        // 则根据 ConsoleLoggerOptions.Format 枚举值选择 systemd 或 simple 的内建格式化器
        if (options.FormatterName == null || !_formatters.TryGetValue(options.FormatterName, out ConsoleFormatter? logFormatter))
        {
#pragma warning disable CS0618
            logFormatter = options.Format switch
            {
                ConsoleLoggerFormat.Systemd => _formatters[ConsoleFormatterNames.Systemd],
                // 缓存中没有 systemd 名称的格式化器，则使用名称为 simple 的格式化器
                _ => _formatters[ConsoleFormatterNames.Simple],
            };
            if (options.FormatterName == null)
            {
                // 用 ConsoleLoggerOptions 选项属性值更新名称为 systemd 或 simple 的内建格式化器的 ConsoleFormatterOptions 选项属性值
                UpdateFormatterOptions(logFormatter, options);
            }
#pragma warning restore CS0618
        }

        _messageQueue.FullMode = options.QueueFullMode;
        _messageQueue.MaxQueueLength = options.MaxQueueLength;

        // 用重新选择的格式化器和更新后的 ConsoleLoggerOptions 选项修改每个创建的 ConsoleLogger 
        foreach (KeyValuePair<string, ConsoleLogger> logger in _loggers)
        {
            logger.Value.Options = options;
            logger.Value.Formatter = logFormatter;
        }
    }

    #pragma warning disable CS0618
    // 更新格式化器的 ConsoleFormatterOptions 选项
    private static void UpdateFormatterOptions(ConsoleFormatter formatter, ConsoleLoggerOptions deprecatedFromOptions)
    {
        if (formatter is SimpleConsoleFormatter defaultFormatter)
        {
            defaultFormatter.FormatterOptions = new SimpleConsoleFormatterOptions()
            {
                // SimpleConsoleFormatterOptions 可以用来控制颜色行为和单行显示行为
                ColorBehavior = deprecatedFromOptions.DisableColors ? LoggerColorBehavior.Disabled : LoggerColorBehavior.Default,
                IncludeScopes = deprecatedFromOptions.IncludeScopes,
                TimestampFormat = deprecatedFromOptions.TimestampFormat,
                UseUtcTimestamp = deprecatedFromOptions.UseUtcTimestamp,
            };
        }
        else if (formatter is SystemdConsoleFormatter systemdFormatter)
        {
            systemdFormatter.FormatterOptions = new ConsoleFormatterOptions()
            {
                IncludeScopes = deprecatedFromOptions.IncludeScopes,
                TimestampFormat = deprecatedFromOptions.TimestampFormat,
                UseUtcTimestamp = deprecatedFromOptions.UseUtcTimestamp,
            };
        }
    }
#pragma warning restore CS0618

    // 实现 IDisposable
    public void Dispose()
    {
        // 取消 IOptionsMonitor<>.OnChange 注册的回调
        _optionsReloadToken?.Dispose();
        // 释放消息队列
        _messageQueue.Dispose();
    }

    // 设置 IExternalScopeProvider
    // 实现日志范围的活动跟踪
    public void SetScopeProvider(IExternalScopeProvider scopeProvider)
    {
        _scopeProvider = scopeProvider;

        // 将 IExternalScopeProvider 传给每个创建的 ILogger
        foreach (System.Collections.Generic.KeyValuePair<string, ConsoleLogger> logger in _loggers)
        {
            logger.Value.ScopeProvider = _scopeProvider;
        }
    }
}
```

- ConsoleLogger  
```C#
// 由 ConsoleLoggerProvider 创建的 ILogger
internal sealed class ConsoleLogger : ILogger
{
    // 名称（日志类别）
    private readonly string _name;
    // 用来实现日志消息的有序输出
    private readonly ConsoleLoggerProcessor _queueProcessor;

    internal ConsoleLogger(
        string name,
        ConsoleLoggerProcessor loggerProcessor,
        ConsoleFormatter formatter,
        IExternalScopeProvider? scopeProvider,
        ConsoleLoggerOptions options)
    {
        ThrowHelper.ThrowIfNull(name);

        _name = name;
        _queueProcessor = loggerProcessor;
        Formatter = formatter;
        ScopeProvider = scopeProvider;
        Options = options;
    }

    // 格式化器
    internal ConsoleFormatter Formatter { get; set; }
    // 调用 ConsoleLoggerProvider.SetScopeProvider 方法传入
    // 实现日志范围的活动跟踪
    internal IExternalScopeProvider? ScopeProvider { get; set; }
    // ConsoleLoggerOptions 选项
    internal ConsoleLoggerOptions Options { get; set; }

    [ThreadStatic]
    private static StringWriter? t_stringWriter;

    // 日志输出方法
    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        // 日志事件等级检查
        if (!IsEnabled(logLevel))
        {
            return;
        }

        ThrowHelper.ThrowIfNull(formatter);

        // 使用 StringWriter 作为写入器
        t_stringWriter ??= new StringWriter();
        // 构建 LogEntry<> 结构交由格式化器处理
        LogEntry<TState> logEntry = new LogEntry<TState>(logLevel, _name, eventId, state, exception, formatter);
        // 格式化器对日志荷载进行格式化并写入 StringWriter 缓冲区
        Formatter.Write(in logEntry, ScopeProvider, t_stringWriter);

        // 从 StringWriter 缓冲区获取格式化日志消息
        var sb = t_stringWriter.GetStringBuilder();
        if (sb.Length == 0)
        {
            return;
        }
        string computedAnsiString = sb.ToString();
        sb.Clear();
        if (sb.Capacity > 1024)
        {
            sb.Capacity = 1024;
        }
        // 将格式化日志消息送入队列
        // 大于 ConsoleLoggerOptions.LogToStandardErrorThreshold 设置的日志事件等级的作为错误输出
        _queueProcessor.EnqueueMessage(new LogMessageEntry(computedAnsiString, logAsError: logLevel >= Options.LogToStandardErrorThreshold));
    }

    // 日志事件等级过滤方法
    public bool IsEnabled(LogLevel logLevel)
    {
        // 日志事件等级只要不为 LogLevel.None 即为 true
        return logLevel != LogLevel.None;
    }

    // 如果设置了 IExternalScopeProvider，则调用 IExternalScopeProvider.Push 方法开始日志范围（压栈）
    // 否则返回 NullScope，不能使用日志范围
    public IDisposable BeginScope<TState>(TState state) where TState : notnull => ScopeProvider?.Push(state) ?? NullScope.Instance;
}
```

- LogEntry\<\>  
```C#
// 格式化器处理目标
public readonly struct LogEntry<TState>
{
    public LogEntry(LogLevel logLevel, string category, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        LogLevel = logLevel;
        Category = category;
        EventId = eventId;
        State = state;
        Exception = exception;
        Formatter = formatter;
    }

    public LogLevel LogLevel { get; }

    public string Category { get; }

    public EventId EventId { get; }

    // 日志载荷
    public TState State { get; }

    public Exception? Exception { get; }

    // 日志格式化委托
    public Func<TState, Exception?, string> Formatter { get; }
}
```

- ConsoleLoggerOptions  
```C#
// ConsoleLoggerOptions 选项
public class ConsoleLoggerOptions
{
    // 是否启用颜色行为
    // 已废弃
    // 用 SimpleConsoleFormatterOptions.ColorBehavior 替代
    [System.ObsoleteAttribute("ConsoleLoggerOptions.DisableColors has been deprecated. Use SimpleConsoleFormatterOptions.ColorBehavior instead.")]
    public bool DisableColors { get; set; }

#pragma warning disable CS0618
    private ConsoleLoggerFormat _format = ConsoleLoggerFormat.Default;
    // 格式化器类别
    // 已废弃
    // 用 ConsoleLoggerOptions.FormatterName 替代
    [System.ObsoleteAttribute("ConsoleLoggerOptions.Format has been deprecated. Use ConsoleLoggerOptions.FormatterName instead.")]
    public ConsoleLoggerFormat Format
    {
        get => _format;
        set
        {
            if (value < ConsoleLoggerFormat.Default || value > ConsoleLoggerFormat.Systemd)
            {
                throw new ArgumentOutOfRangeException(nameof(value));
            }
            _format = value;
        }
#pragma warning restore CS0618
    }

    // 格式化器名称
    public string? FormatterName { get; set; }

    // 是否输出包含日志范围的信息
    // 已废弃
    // 用 ConsoleFormatterOptions.IncludeScopes 替代
    [System.ObsoleteAttribute("ConsoleLoggerOptions.IncludeScopes has been deprecated. Use ConsoleFormatterOptions.IncludeScopes instead.")]
    public bool IncludeScopes { get; set; }

    // 高于此日志事件等级的使用错误输出
    // 默认不使用错误输出
    public LogLevel LogToStandardErrorThreshold { get; set; } = LogLevel.None;

    // 时间戳格式化
    // 已废弃
    // 用 ConsoleFormatterOptions.TimestampFormat 替代
    [System.ObsoleteAttribute("ConsoleLoggerOptions.TimestampFormat has been deprecated. Use ConsoleFormatterOptions.TimestampFormat instead.")]
    public string? TimestampFormat { get; set; }

    // 是否使用 Utc 时间戳
    // 已废弃
    // 使用 ConsoleFormatterOptions.UseUtcTimestamp 替代
    [System.ObsoleteAttribute("ConsoleLoggerOptions.UseUtcTimestamp has been deprecated. Use ConsoleFormatterOptions.UseUtcTimestamp instead.")]
    public bool UseUtcTimestamp { get; set; }

    private ConsoleLoggerQueueFullMode _queueFullMode = ConsoleLoggerQueueFullMode.Wait;
    // 队列满时的行为
    // 默认为 ConsoleLoggerQueueFullMode.Wait 等待
    // 可以使用 ConsoleLoggerQueueFullMode.DropWrite 丢弃日志写入
    public ConsoleLoggerQueueFullMode QueueFullMode
    {
        get => _queueFullMode;
        set
        {
            if (value != ConsoleLoggerQueueFullMode.Wait && value != ConsoleLoggerQueueFullMode.DropWrite)
            {
                throw new ArgumentOutOfRangeException(SR.Format(SR.QueueModeNotSupported, nameof(value)));
            }
            _queueFullMode = value;
        }
    }

    internal const int DefaultMaxQueueLengthValue = 2500;
    private int _maxQueuedMessages = DefaultMaxQueueLengthValue;

    // 日志处理器的最大队列容量
    public int MaxQueueLength
    {
        get => _maxQueuedMessages;
        set
        {
            if (value <= 0)
            {
                throw new ArgumentOutOfRangeException(SR.Format(SR.MaxQueueLengthBadValue, nameof(value)));
            }

            _maxQueuedMessages = value;
        }
    }
}
```

- ConsoleFormatter  
```C#
// 格式化器抽象表示
// 内建的三个实现类型：
// 1. SimpleConsoleFormatter
// 2. SystemdConsoleFormatter
// 3. JsonConsoleFormatter
public abstract class ConsoleFormatter
{
    // 实现类必须为格式化器指定一个名称
    protected ConsoleFormatter(string name)
    {
        ThrowHelper.ThrowIfNull(name);

        Name = name;
    }

    // 格式化器名称
    public string Name { get; }

    // 具体实现通过重写此方法，将日志消息格式化后写入 TextWriter 缓冲区
    // 大致的具体步骤如下：
    // 1. 利用 LogEntry<>.State、LogEntry<>.Exception 通过 LogEntry<>.Formatter 委托格式化日志消息
    // 2. 根据 ConsoleFormatterOptions.IncludeScopes 判断是否需要在输出中包含范围信息
    // 3. 利用 Scope.State（或者 Activity 的 W3C 格式的范围消息，根据 ActivityTrackingOptions 枚举值创建 ActivityLogScope）作为消息载荷
    //    通过消息载荷对象调用 ToString 方法得到范围消息
    //    最终利用 IExternalScopeProvider.ForEachScope<> 方法将范围消息写入 TextWriter 缓冲区  
    public abstract void Write<TState>(in LogEntry<TState> logEntry, IExternalScopeProvider? scopeProvider, TextWriter textWriter);
}
```

## 依赖注入

- ConsoleLoggerExtensions  
```C#
public static class ConsoleLoggerExtensions
{
    // 注册控制台日志核心服务
    public static ILoggingBuilder AddConsole(this ILoggingBuilder builder)
    {
        // 需要确保注册 ILoggerProviderConfigurationFactory 和 ILoggerProviderConfiguration<> 服务
        // 因为注册的 ConsoleLoggerOptions 选项配置依赖这两个服务注册
        builder.AddConfiguration();

        // 注册三个内建的格式化器和它们所对应的 ConsoleFormatterOptions 选项配置
        builder.AddConsoleFormatter<JsonConsoleFormatter, JsonConsoleFormatterOptions>();
        builder.AddConsoleFormatter<SystemdConsoleFormatter, ConsoleFormatterOptions>();
        builder.AddConsoleFormatter<SimpleConsoleFormatter, SimpleConsoleFormatterOptions>();

        // 注册 ILoggerProvider
        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<ILoggerProvider, ConsoleLoggerProvider>());
        // 注册 ConsoleLoggerOptions 选项配置
        // 将 ConsoleLoggerProvider 所对应的 IConfigurationSection 配置节的配置绑定到 ConsoleLoggerOptions 选项上
        LoggerProviderOptions.RegisterProviderOptions<ConsoleLoggerOptions, ConsoleLoggerProvider>(builder.Services);

        return builder;
    }

    // 通过 Action<ConsoleLoggerOptions> 注册 ConsoleLoggerOptions 选项配置
    public static ILoggingBuilder AddConsole(this ILoggingBuilder builder, Action<ConsoleLoggerOptions> configure)
    {
        ThrowHelper.ThrowIfNull(configure);

        builder.AddConsole();
        builder.Services.Configure(configure);

        return builder;
    }

    // 注册 ConsoleLoggerOptions 选项配置
    // 配置 ConsoleLoggerOptions.FormatterName 为 ConsoleFormatterNames.Simple
    // AddJsonConsole 和 AddSystemdConsole 具有相似的实现
    public static ILoggingBuilder AddSimpleConsole(this ILoggingBuilder builder) =>
            builder.AddFormatterWithName(ConsoleFormatterNames.Simple);
    
    // 注册 SimpleConsoleFormatterOptions 选项配置
    // AddJsonConsole 和 AddSystemdConsole 具有相的实现
    public static ILoggingBuilder AddSimpleConsole(this ILoggingBuilder builder, Action<SimpleConsoleFormatterOptions> configure)
    {
        return builder.AddConsoleWithFormatter<SimpleConsoleFormatterOptions>(ConsoleFormatterNames.Simple, configure);
    }

    // 注册 ConsoleLoggerOptions 选项配置
    private static ILoggingBuilder AddFormatterWithName(this ILoggingBuilder builder, string name) =>
        builder.AddConsole((ConsoleLoggerOptions options) => options.FormatterName = name);

    // 注册 ConsoleFormatterOptions 选项配置
    internal static ILoggingBuilder AddConsoleWithFormatter<TOptions>(this ILoggingBuilder builder, string name, Action<TOptions> configure)
        where TOptions : ConsoleFormatterOptions
    {
        ThrowHelper.ThrowIfNull(configure);

        builder.AddFormatterWithName(name);
        builder.Services.Configure(configure);

        return builder;
    }

    // 注册格式化器和对应的 ConsoleFormatterOptions 选项配置
    public static ILoggingBuilder AddConsoleFormatter<TFormatter, TOptions>(this ILoggingBuilder builder)
        where TOptions : ConsoleFormatterOptions
        where TFormatter : ConsoleFormatter
    {
        builder.AddConfiguration();

        // 注册格式化器
        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<ConsoleFormatter, TFormatter>());
        // 注册 ConsoleFormatterOptions 选项配置
        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<IConfigureOptions<TOptions>, ConsoleLoggerFormatterConfigureOptions<TFormatter, TOptions>>());
        // 由于配置来源最终可以追溯到 LoggingConfiguration 封装的 IConfiguration
        // 所以可以通过 IOptionsMonitor<> 得到配置，并在配置改变后发出回调更新选项
        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<IOptionsChangeTokenSource<TOptions>, ConsoleLoggerFormatterOptionsChangeTokenSource<TFormatter, TOptions>>());

        return builder;
    }

    // 通过 Action<TOptions> 注册 ConsoleFormatterOptions 选项配置
    public static ILoggingBuilder AddConsoleFormatter<TFormatter, TOptions>(this ILoggingBuilder builder, Action<TOptions> configure)
        where TOptions : ConsoleFormatterOptions
        where TFormatter : ConsoleFormatter
    {
        ThrowHelper.ThrowIfNull(configure);

        builder.AddConsoleFormatter<TFormatter, TOptions>();
        builder.Services.Configure(configure);
        return builder;
    }
}
```

- ConsoleLoggerFormatterConfigureOptions\<,\>  
```C#
// ConsoleLoggerFormatter 选项配置
internal sealed class ConsoleLoggerFormatterConfigureOptions<TFormatter, TOptions> : ConfigureFromConfigurationOptions<TOptions>
    where TOptions : ConsoleFormatterOptions
    where TFormatter : ConsoleFormatter
{
    // 利用 ConsoleLoggerProvider 对应配置节下的子配置节 "FormatterOptions" 绑定选项
    public ConsoleLoggerFormatterConfigureOptions(ILoggerProviderConfiguration<ConsoleLoggerProvider> providerConfiguration) :
        base(providerConfiguration.Configuration.GetSection("FormatterOptions"))
    {
    }
}
```

- ConsoleLoggerFormatterOptionsChangeTokenSource  
```C#
// ConsoleLoggerFormatter 选项配置改变源
// 用于在配置发送改变时发出回调
internal sealed class ConsoleLoggerFormatterOptionsChangeTokenSource<TFormatter, TOptions> : ConfigurationChangeTokenSource<TOptions>
    where TOptions : ConsoleFormatterOptions
    where TFormatter : ConsoleFormatter
{
    // 利用 ConsoleLoggerProvider 对应配置节下的子配置节 "FormatterOptions" 绑定选项
    public ConsoleLoggerFormatterOptionsChangeTokenSource(ILoggerProviderConfiguration<ConsoleLoggerProvider> providerConfiguration)
        : base(providerConfiguration.Configuration.GetSection("FormatterOptions"))
    {
    }
}
```