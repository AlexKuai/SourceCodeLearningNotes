## 源码涉及的核心类型
- EventId  
- LogLevel  

## 日志模型

- EventId  
```C#
// 表示日志事件的 ID 和 Name
public readonly struct EventId : IEquatable<EventId>
{
    // 重载隐式转换操作（支持 int 隐式转换为 EventId 类型）
    public static implicit operator EventId(int i)
    {
        return new EventId(i);
    }

    // 重载 == 运算符
    public static bool operator ==(EventId left, EventId right)
    {
        return left.Equals(right);
    }

    // 重载 != 运算符
    public static bool operator !=(EventId left, EventId right)
    {
        return !left.Equals(right);
    }

    // name 默认为 null
    public EventId(int id, string? name = null)
    {
        Id = id;
        Name = name;
    }

    // 事件 ID
    public int Id { get; }

    // 事件 Name
    public string? Name { get; }

    // 重写 ToString
    public override string ToString()
    {
        return Name ?? Id.ToString();
    }

    // 实现 IEquatable<EventId>
    public bool Equals(EventId other)
    {
        return Id == other.Id;
    }

    // 重写 Equals
    public override bool Equals(object? obj)
    {
        if (obj is null)
        {
            return false;
        }

        return obj is EventId eventId && Equals(eventId);
    }

    // 重写 GetHashCode
    public override int GetHashCode()
    {
        return Id;
    }
}
```

- LogLevel  
```C#
// 日志事件等级
// 严重程度由低到高（除 None 以外）
public enum LogLevel
{
    Trace = 0,
    Debug = 1,
    Information = 2,
    Warning = 3,
    Error = 4,
    Critical = 5,
    None = 6
}
```

- ILogger  
```C#
// 日志记录器接口
public interface ILogger
{
    // 为应用程序提供的日志写入方法
    void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter);

    // 日志事件等级检查方法（基于最低日志事件等级过滤屏蔽）
    bool IsEnabled(LogLevel logLevel);

    // 日志范围开始方法（记录活动跟踪）
    IDisposable? BeginScope<TState>(TState state) where TState : notnull;
}
```

- Logger  
```C#
// ILogger 的默认实现
// 提供应用程序发送日志事件的入口作用
internal sealed class Logger : ILogger
{
    public Logger(LoggerInformation[] loggers) => Loggers = loggers;

    // 数组的元素数量与注册的 ILoggerProvider 数量一致
    public LoggerInformation[] Loggers { get; set; }
    // 数组的元素数量与注册的 ILoggerProvider 数量一致
    public MessageLogger[]? MessageLoggers { get; set; }
    // 数组的元素数量与注册的 ILoggerProvider 数量可能不一致
    // 如果注册的 ILoggerProvider 没有一个实现了 ISupportExternalScope 接口，则数量一致
    // 如果注册的 ILoggerProvider 至少有一个实现了 ISupportExternalScope 接口，则数量就会少于注册的 ILoggerProvider 数量
    // 因为实现了 ISupportExternalScope 接口的所有 ILoggerProvider 本质上共用一个 IExternalScopeProvider 来提供日志范围的活动跟踪
    public ScopeLogger[]? ScopeLoggers { get; set; }

    // 作为提供应用程序发送日志事件的入口函数
    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        MessageLogger[]? loggers = MessageLoggers;
        if (loggers == null)
        {
            return;
        }

        List<Exception>? exceptions = null;
        for (int i = 0; i < loggers.Length; i++)
        {
            ref readonly MessageLogger loggerInfo = ref loggers[i];
            // 根据最低日志等级过滤屏蔽日志事件输出
            if (!loggerInfo.IsEnabled(logLevel))
            {
                continue;
            }

            // 使用由 ILoggerProvider 创建的 ILogger 发送日志事件
            LoggerLog(logLevel, eventId, loggerInfo.Logger, exception, formatter, ref exceptions, state);
        }

        if (exceptions != null && exceptions.Count > 0)
        {
            ThrowLoggingError(exceptions);
        }

        // 调用由 ILoggerProvider 创建的 ILogger 使用对应的日志事件源发送日志事件
        static void LoggerLog(LogLevel logLevel, EventId eventId, ILogger logger, Exception? exception, Func<TState, Exception?, string> formatter, ref List<Exception>? exceptions, in TState state)
        {
            try
            {
                logger.Log(logLevel, eventId, state, exception, formatter);
            }
            catch (Exception ex)
            {
                exceptions ??= new List<Exception>();
                exceptions.Add(ex);
            }
        }
    }

    // 可以利用此方法检查是否存在至少一个满足最低日志事件等级或过滤规则的 ILogger
    // 即可以将日志事件发送到至少一个由 ILoggerProvider 创建的 ILogger
    public bool IsEnabled(LogLevel logLevel)
    {
        MessageLogger[]? loggers = MessageLoggers;
        if (loggers == null)
        {
            return false;
        }

        List<Exception>? exceptions = null;
        int i = 0;
        for (; i < loggers.Length; i++)
        {
            ref readonly MessageLogger loggerInfo = ref loggers[i];
            if (!loggerInfo.IsEnabled(logLevel))
            {
                continue;
            }

            // 继续使用由 ILoggerProvider 创建的 ILogger 检查是否满足最低日志事件等级或其他过滤规则
            if (LoggerIsEnabled(logLevel, loggerInfo.Logger, ref exceptions))
            {
                break;
            }
        }

        if (exceptions != null && exceptions.Count > 0)
        {
            ThrowLoggingError(exceptions);
        }

        // 只要存在一个通过过滤的 ILoggerProvider 就返回 true
        return i < loggers.Length ? true : false;

        static bool LoggerIsEnabled(LogLevel logLevel, ILogger logger, ref List<Exception>? exceptions)
        {
            try
            {
                if (logger.IsEnabled(logLevel))
                {
                    return true;
                }
            }
            catch (Exception ex)
            {
                exceptions ??= new List<Exception>();
                exceptions.Add(ex);
            }

            return false;
        }
    }

    // 开始一个日志范围
    // 本质上就是由 ILoggerProvider 创建的 ILogger 来创建一个表示日志范围的结构
    // 当前日志范围的结构指向父日志范围的结构形成一个单向链表（父范围 <- 当前范围），并利用 AsyncLocal<T> 保存来实现在不同线程间传递
    public IDisposable? BeginScope<TState>(TState state) where TState : notnull
    {
        ScopeLogger[]? loggers = ScopeLoggers;

        if (loggers == null)
        {
            return NullScope.Instance;
        }

        if (loggers.Length == 1)
        {
            return loggers[0].CreateScope(state);
        }

        var scope = new Scope(loggers.Length);
        List<Exception>? exceptions = null;
        for (int i = 0; i < loggers.Length; i++)
        {
            ref readonly ScopeLogger scopeLogger = ref loggers[i];

            try
            {
                // 代表日志范围的结构实现了 IDisposable 接口
                // 可以在范围结束时通过调用 IDisposable.Dispose 方法完成当前范围的出栈操作
                scope.SetDisposable(i, scopeLogger.CreateScope(state));
            }
            catch (Exception ex)
            {
                exceptions ??= new List<Exception>();
                exceptions.Add(ex);
            }
        }

        if (exceptions != null && exceptions.Count > 0)
        {
            ThrowLoggingError(exceptions);
        }

        return scope;
    }

    private static void ThrowLoggingError(List<Exception> exceptions)
    {
        throw new AggregateException(
            message: "An error occurred while writing to logger(s).", innerExceptions: exceptions);
    }
}
```

- ILogger\<\>    
```C#
// 便于利用依赖注入方式使用日志
// 泛型参数可以将组件、服务等类型作为日志类别
public interface ILogger<out TCategoryName> : ILogger
{

}
```

- Logger\<\>  
```C#
// ILogger<> 默认实现
// 本质是 ILogger 的包装类型
// 利用泛型强类型方式使用日志类别
// 便于将组件、服务等类型作为日志类别
// 内部实际都是对 ILogger 方法的调用
public class Logger<T> : ILogger<T>
{
    private readonly ILogger _logger;

    public Logger(ILoggerFactory factory)
    {
        ThrowHelper.ThrowIfNull(factory);

        // 类型名称作为日志类别时使用显示名称，如果是泛型类型则不包含泛型参数类型，内嵌类型使用 . 号分割
        _logger = factory.CreateLogger(TypeNameHelper.GetTypeDisplayName(typeof(T), includeGenericParameters: false, nestedTypeDelimiter: '.'));
    }

    void ILogger.Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        _logger.Log(logLevel, eventId, state, exception, formatter);
    }

    bool ILogger.IsEnabled(LogLevel logLevel)
    {
        return _logger.IsEnabled(logLevel);
    }

    IDisposable? ILogger.BeginScope<TState>(TState state)
    {
        return _logger.BeginScope(state);
    }
}
```

- LoggerInformation  
```C#
// 日志信息
// 每个日志类别和不同 ILoggerProvider 的组合对应一个 ILogger
internal readonly struct LoggerInformation
{
    public LoggerInformation(ILoggerProvider provider, string category) : this()
    {
        ProviderType = provider.GetType();
        Logger = provider.CreateLogger(category);
        Category = category;
        ExternalScope = provider is ISupportExternalScope;
    }
    
    // 由 ILoggerProvider 创建的 ILogger
    // ILogger 内部通过对应的日志事件源发送日志事件
    // 订阅者（观察者）收到日志事件后将其输出到相应的渠道
    public ILogger Logger { get; }

    // 日志类别
    public string Category { get; }

    // ILoggerProvider 具体类型
    public Type ProviderType { get; }

    // ILoggerProvider 是否实现了 ISupportExternalScope 接口
    // 实现了 ISupportExternalScope 接口就表明需要借助 IExternalScopeProvider 来提供日志范围的活动跟踪
    // 没有实现的 ILoggerProvider 代表自身可以提供日志范围的活动跟踪
    public bool ExternalScope { get; }
}
```

- MessageLogger  
```C#
// 消息日志
// 利用 ILoggerProvider 全名、日志类别、日志等级过滤日志
internal readonly struct MessageLogger
{
    // 利用 category、providerTypeFullName 从 ILoggingBuilder.AddConfiguration、ILoggingBuilder.AddFilter、ILoggingBuilder.SetMinimumLevel 得到
    // 匹配的 minLevel 和 filter
    public MessageLogger(ILogger logger, string? category, string? providerTypeFullName, LogLevel? minLevel, Func<string?, string?, LogLevel, bool>? filter)
    {
        Logger = logger;
        Category = category;
        ProviderTypeFullName = providerTypeFullName;
        MinLevel = minLevel;
        Filter = filter;
    }

    // 由 ILoggerProvider 创建的 ILogger
    public ILogger Logger { get; }

    // 日志类别
    public string? Category { get; }

    // ILoggerProvider 全名
    // 可以使用 ProviderAliasAttribute 特性配置对应的别名
    private string? ProviderTypeFullName { get; }

    // 通过 Category 和 ProviderTypeFullName 根据最优筛选逻辑得到的最优 LoggerFilterRule 中的 LogLevel 属性值
    public LogLevel? MinLevel { get; }

    // 通过 Category 和 ProviderTypeFullName 根据最优筛选逻辑得到的最优 LoggerFilterRule 中的 Filter 属性值
    public Func<string?, string?, LogLevel, bool>? Filter { get; }

    // 根据最低日志等级和过滤规则方法方法过滤发送的日志事件
    public bool IsEnabled(LogLevel level)
    {
        // 不满足最低日志级别直接返回 false
        if (MinLevel != null && level < MinLevel)
        {
            return false;
        }

        // 使用过滤规则方法检查
        if (Filter != null)
        {
            return Filter(ProviderTypeFullName, Category, level);
        }

        return true;
    }
}
```

- ScopeLogger  
```C#
// 范围日志
// 如果 ILoggerProvider 实现了 ISupportExternalScope 接口就表明其自身不具有日志范围的活动跟踪
// 这时候就需要通过 IExternalScopeProvider 来提供日志范围的活动跟踪
internal readonly struct ScopeLogger
{
    public ScopeLogger(ILogger? logger, IExternalScopeProvider? externalScopeProvider)
    {
        Debug.Assert(logger != null || externalScopeProvider != null, "Logger can't be null when there isn't an ExternalScopeProvider");

        Logger = logger;
        ExternalScopeProvider = externalScopeProvider;
    }

    // 由 ILoggerProvider 创建的 ILogger
    public ILogger? Logger { get; }

    // 实现 IExternalScopeProvider 的范围提供者
    public IExternalScopeProvider? ExternalScopeProvider { get; }

    // 创建日志范围
    // 实现的核心就是创建当前日志范围的结构并指向父日志范围的结构形成一个单向链表（父范围 <- 当前范围），并利用 AsyncLocal<T> 保存来实现在不同线程间传递
    public IDisposable? CreateScope<TState>(TState state) where TState : notnull
    {
        if (ExternalScopeProvider != null)
        {
            return ExternalScopeProvider.Push(state);
        }

        Debug.Assert(Logger != null);
        return Logger.BeginScope<TState>(state);
    }
}
```

- LoggerFactoryOptions  
```C#
// 日志工厂选项
// 主要用来配置活动跟踪时的信息组织
public class LoggerFactoryOptions
{
    public LoggerFactoryOptions() { }

    // 活动跟踪选项
    // ActivityTrackingOptions 是一个带有位标志的枚举类型
    public ActivityTrackingOptions ActivityTrackingOptions { get; set; }
}
```

- LoggerFilterOptions  
```C#
// 日志过滤选项
public class LoggerFilterOptions
{
    public LoggerFilterOptions() { }

    // 是否启用日志范围的活动跟踪
    public bool CaptureScopes { get; set; } = true;

    // 全局最小日志等级
    public LogLevel MinLevel { get; set; }

    // 日志过滤规则集合
    public IList<LoggerFilterRule> Rules => RulesInternal;

    // Concrete representation of the rule list
    internal List<LoggerFilterRule> RulesInternal { get; } = new List<LoggerFilterRule>();
}
```

- LoggerFilterRule  
```C#
public class LoggerFilterRule
{
    // 通过调用 ILoggingBuilder.AddConfiguration 方法从配置文件中得到的 providerName、categoryName、logLevel
    // 通过调用 ILoggingBuilder.AddFilter 方法配置得到的 providerName、categoryName、filter
    public LoggerFilterRule(string? providerName, string? categoryName, LogLevel? logLevel, Func<string?, string?, LogLevel, bool>? filter)
    {
        ProviderName = providerName;
        CategoryName = categoryName;
        LogLevel = logLevel;
        Filter = filter;
    }

    public string? ProviderName { get; }

    public string? CategoryName { get; }

    public LogLevel? LogLevel { get; }

    public Func<string?, string?, LogLevel, bool>? Filter { get; }

    public override string ToString()
    {
        return $"{nameof(ProviderName)}: '{ProviderName}', {nameof(CategoryName)}: '{CategoryName}', {nameof(LogLevel)}: '{LogLevel}', {nameof(Filter)}: '{Filter}'";
    }
}
```

- ILoggerFactory
```C#
// Logger 工厂的抽象表示
public interface ILoggerFactory : IDisposable
{
    // 利用 categoryName 创建对应日志类别的 Logger
    // 创建的 ILogger 只是提供应用程序发送日志事件的入口作用
    ILogger CreateLogger(string categoryName);

    // 添加 ILoggerProvider
    void AddProvider(ILoggerProvider provider);
}
```

- LoggerFactory  
```C#
// ILoggerFactory 的默认实现
public class LoggerFactory : ILoggerFactory
{
    // 缓存根据不同日志类别创建的 ILogger
    private readonly Dictionary<string, Logger> _loggers = new Dictionary<string, Logger>(StringComparer.Ordinal);
    // Logger 提供者注册列表
    private readonly List<ProviderRegistration> _providerRegistrations = new List<ProviderRegistration>();
    // 同步锁
    private readonly object _sync = new object();
    // 是否执行过释放操作标志
    private volatile bool _disposed;
    // 用来取消通过 IOptionsMonitor<LoggerFilterOptions>.OnChange 方法注册的回调
    private IDisposable? _changeTokenRegistration;
    // 日志过滤选项
    private LoggerFilterOptions _filterOptions;
    // 全局的外部范围提供者
    private IExternalScopeProvider? _scopeProvider;
    // 日志工厂选项
    // 主要作用是配置活动跟踪选项
    private LoggerFactoryOptions _factoryOptions;

    public LoggerFactory() : this(Array.Empty<ILoggerProvider>())
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers) : this(providers, new StaticFilterOptionsMonitor(new LoggerFilterOptions()))
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers, LoggerFilterOptions filterOptions) : this(providers, new StaticFilterOptionsMonitor(filterOptions))
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption) : this(providers, filterOption, null)
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions>? options) : this(providers, filterOption, options, null)
    {
    }

    // 参数：
    // 1. 所有注册 ILoggerProvider
    // 2. 基于文件配置的 LoggerFilterOptions 并可以监控配置改变的 IOptionsMonitor<LoggerFilterOptions>
    // 3. 启用日志范围后的活动跟踪选项配置 IOptions<LoggerFactoryOptions>
    // 4. 外部日志范围提供者 IExternalScopeProvider
    // 依赖注入框架会选取此为最优构造函数
    public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions>? options = null, IExternalScopeProvider? scopeProvider = null)
    {
        _scopeProvider = scopeProvider;

        // 可能未注册 LoggerFactoryOptions 的选项配置
        _factoryOptions = options == null || options.Value == null ? new LoggerFactoryOptions() : options.Value;

        // 对除 None 以外的所有枚举按位或后取非
        const ActivityTrackingOptions ActivityTrackingOptionsMask = ~(ActivityTrackingOptions.SpanId | ActivityTrackingOptions.TraceId | ActivityTrackingOptions.ParentId |
                                                                      ActivityTrackingOptions.TraceFlags | ActivityTrackingOptions.TraceState | ActivityTrackingOptions.Tags
                                                                      | ActivityTrackingOptions.Baggage);

        // 如果和 ActivityTrackingOptionsMask 按位与操作后不为零，表明配置了未定义的枚举值，则抛出异常
        if ((_factoryOptions.ActivityTrackingOptions & ActivityTrackingOptionsMask) != 0)
        {
            throw new ArgumentException(SR.Format(SR.InvalidActivityTrackingOptions, _factoryOptions.ActivityTrackingOptions), nameof(options));
        }
        // 遍历 Logger 提供者，添加进注册中心
        foreach (ILoggerProvider provider in providers)
        {
            // 如果是实现了 ISupportExternalScope 接口的 ILoggerProvider
            // 则需要对其设置 IExternalScopeProvider 提供日志范围的活动跟踪
            AddProviderRegistration(provider, dispose: false);
        }
        
        // 监控日志过滤规则配置文件的改变
        // 在改变后重新获取 LoggerFilterOptions 并刷新应用过滤规则
        _changeTokenRegistration = filterOption.OnChange(RefreshFilters);
        // 初始化使用 IOptionsMonitor<LoggerFilterOptions> 的 CurrentValue（空字符串命名）获取选项
        // 刷新应用过滤规则
        RefreshFilters(filterOption.CurrentValue);
    }

    // 刷新应用规则
    private void RefreshFilters(LoggerFilterOptions filterOptions)
    {
        lock (_sync)
        {
            // 更新 LoggerFilterOptions
            _filterOptions = filterOptions;
            foreach (KeyValuePair<string, Logger> registeredLogger in _loggers)
            {
                Logger logger = registeredLogger.Value;
                // 应用新的过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);
            }
        }
    }

    // 根据 categoryName 日志类别创建获取 ILogger
    public ILogger CreateLogger(string categoryName)
    {
        if (CheckDisposed())
        {
            throw new ObjectDisposedException(nameof(LoggerFactory));
        }

        // 在并发情况下创建对应日志类别的 ILogger 和应用新的过滤规则需要同步完成
        lock (_sync)
        {
            if (!_loggers.TryGetValue(categoryName, out Logger? logger))
            {
                // 基于日志类别创建 ILogger
                // 利用 CreateLoggers 方法创建 LoggerInformation 数组
                logger = new Logger(CreateLoggers(categoryName));

                // 应用过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);

                // 添加新的日志类别和对应的 ILogger
                _loggers[categoryName] = logger;
            }

            return logger;
        }
    }

    // 添加新的 ILoggerProvider
    public void AddProvider(ILoggerProvider provider)
    {
        if (CheckDisposed())
        {
            throw new ObjectDisposedException(nameof(LoggerFactory));
        }

        ThrowHelper.ThrowIfNull(provider);

        // 在并发情况下 ILogger 的创建需要同步完成
        lock (_sync)
        {
            // 添加进注册中心
            AddProviderRegistration(provider, dispose: true);
            // 遍历所有已经创建的 Logger
            // 利用新添加的 ILoggerProvider 创建新的 LoggerInformation，并应用过滤规则
            foreach (KeyValuePair<string, Logger> existingLogger in _loggers)
            {
                Logger logger = existingLogger.Value;
                LoggerInformation[] loggerInformation = logger.Loggers;

                int newLoggerIndex = loggerInformation.Length;
                // 扩容数组
                Array.Resize(ref loggerInformation, loggerInformation.Length + 1);
                // 根据 ILoggerProvider 和日志类别的组合创建新的 LoggerInformation，并添加到添加到末尾
                loggerInformation[newLoggerIndex] = new LoggerInformation(provider, existingLogger.Key);

                logger.Loggers = loggerInformation;
                // 应用过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);
            }
        }
    }

    // 将 ILoggerProvider 添加进列表
    // 便于维护和释放
    private void AddProviderRegistration(ILoggerProvider provider, bool dispose)
    {
        _providerRegistrations.Add(new ProviderRegistration
        {
            Provider = provider,
            ShouldDispose = dispose
        });

        // 如果 ILoggerProvider 实现了 ISupportExternalScope 
        // 就为 ILoggerProvider 添加 LoggerFactoryScopeProvider（LoggerFactoryScopeProvider 实现了 IExternalScopeProvider）
        // 利用 IExternalScopeProvider 为 ILoggerProvider 提供基于范围的活动跟踪
        if (provider is ISupportExternalScope supportsExternalScope)
        {
            // 利用 ActivityTrackingOptions 创建 LoggerFactoryScopeProvider
            _scopeProvider ??= new LoggerFactoryScopeProvider(_factoryOptions.ActivityTrackingOptions);

            supportsExternalScope.SetScopeProvider(_scopeProvider);
        }
    }

    // 利用 categoryName 和所有已注册的 ILoggerProvider 创建 LoggerInformation 数组
    private LoggerInformation[] CreateLoggers(string categoryName)
    {
        var loggers = new LoggerInformation[_providerRegistrations.Count];
        for (int i = 0; i < _providerRegistrations.Count; i++)
        {
            loggers[i] = new LoggerInformation(_providerRegistrations[i].Provider, categoryName);
        }
        return loggers;
    }

    // 应用过滤规则
    private (MessageLogger[] MessageLoggers, ScopeLogger[]? ScopeLoggers) ApplyFilters(LoggerInformation[] loggers)
    {
        var messageLoggers = new List<MessageLogger>();
        // 根据 LoggerFilterOptions.CaptureScopes 属性决定是否启用日志范围的活动跟踪，这个属性默认值为 true
        // 启用情况下才需要创建 ScopeLogger 集合
        List<ScopeLogger>? scopeLoggers = _filterOptions.CaptureScopes ? new List<ScopeLogger>() : null;

        foreach (LoggerInformation loggerInformation in loggers)
        {
            // 选择最优的 LoggerFilterRule
            // 匹配规则：
            // 1. 具体的针对 ILoggerProvider 的规则优先级高于默认规则
            // 2. 日志类别基于前缀匹配规则
            // 3. 对于 Foo.Bar.Baz 的日志类别，配置中 Foo.Bar 的规则比 Foo 的规则优先级更高
            // 4. 有多个优先级相同的规则选择最后一个
            // 5. 以上规则没有匹配到则使用全局最低日志等级 LoggerFilterOptions.MinLevel
            LoggerRuleSelector.Select(_filterOptions,
                loggerInformation.ProviderType,
                loggerInformation.Category,
                out LogLevel? minLevel,
                out Func<string?, string?, LogLevel, bool>? filter);

            // 无效的最低日志等级
            if (minLevel is not null and > LogLevel.Critical)
            {
                continue;
            }

            messageLoggers.Add(new MessageLogger(loggerInformation.Logger, loggerInformation.Category, loggerInformation.ProviderType.FullName, minLevel, filter));

            // 不需要由 IExternalScopeProvider 提供日志范围的活动跟踪
            // 直接使用 ILoggerProvider 创建的 ILogger 构建 ScopeLogger
            if (!loggerInformation.ExternalScope)
            {
                scopeLoggers?.Add(new ScopeLogger(logger: loggerInformation.Logger, externalScopeProvider: null));
            }
        }

        // 是否有提供默认的 IExternalScopeProvider
        // 如果有表明存在实现了 ISupportExternalScope 接口的 IServiceProvider，需要通过 IExternalScopeProvider 来提供日志范围的活动跟踪
        if (_scopeProvider != null)
        {
            scopeLoggers?.Add(new ScopeLogger(logger: null, externalScopeProvider: _scopeProvider));
        }

        return (messageLoggers.ToArray(), scopeLoggers?.ToArray());
    }

    // 检查是否已经执行过释放
    protected virtual bool CheckDisposed() => _disposed;

    // 释放
    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;

            _changeTokenRegistration?.Dispose();

            foreach (ProviderRegistration registration in _providerRegistrations)
            {
                try
                {
                    if (registration.ShouldDispose)
                    {
                        registration.Provider.Dispose();
                    }
                }
                catch
                {

                }
            }
        }
    }

    private struct ProviderRegistration
    {
        public ILoggerProvider Provider;
        public bool ShouldDispose;
    }
}
```

- IExternalScopeProvider  
```C#
public interface IExternalScopeProvider
{
    // 遍历从根范围到当前范围，使用每个范围的 Scope.State 上发出 callback 回调
    void ForEachScope<TState>(Action<object?, TState> callback, TState state);

    // 新建一个范围结构（可以理解为压栈操作）
    // 核心是创建一个新的范围结构，并将当前范围结构保存到新范围结构的 Parent 属性中，作为父范围
    // 将新创建的范围结构作为当前范围存储到 AsyncLocal<> 中
    IDisposable Push(object? state);
}
```

- LoggerFactoryScopeProvider  
```C#
// IExternalScopeProvider 的默认实现
// 用来管理范围的入栈和出栈
internal sealed class LoggerFactoryScopeProvider : IExternalScopeProvider
{
    private readonly AsyncLocal<Scope?> _currentScope = new AsyncLocal<Scope?>();
    private readonly ActivityTrackingOptions _activityTrackingOption;

    public void ForEachScope<TState>(Action<object?, TState> callback, TState state)
    {
        void Report(Scope? current)
        {
            if (current == null)
            {
                return;
            }
            Report(current.Parent);
            callback(current.State, state);
        }

        if (_activityTrackingOption != ActivityTrackingOptions.None)
        {
            Activity? activity = Activity.Current;
            // 如果 activity != null，则表明开始日志范围是调用了 Activity.Start 方法
            if (activity != null)
            {
                const string propertyKey = "__ActivityLogScope__";

                ActivityLogScope? activityLogScope = activity.GetCustomProperty(propertyKey) as ActivityLogScope;
                if (activityLogScope == null)
                {
                    activityLogScope = new ActivityLogScope(activity, _activityTrackingOption);
                    activity.SetCustomProperty(propertyKey, activityLogScope);
                }

                callback(activityLogScope, state);

                if ((_activityTrackingOption & ActivityTrackingOptions.Tags) != 0
                    && activity.TagObjects.GetEnumerator().MoveNext())
                {
                    callback(activity.TagObjects, state);
                }

                if ((_activityTrackingOption & ActivityTrackingOptions.Baggage) != 0)
                {
                    IEnumerable<KeyValuePair<string, string?>> baggage = activity.Baggage;
                    if (baggage.GetEnumerator().MoveNext())
                    {
                        ActivityBaggageLogScopeWrapper scope = GetOrCreateActivityBaggageLogScopeWrapper(activity, baggage);
                        callback(scope, state);
                    }
                }
            }
        }

        // 如果使用 Activity 方式的活动跟踪，则 _currentScope.Value 就等于 null（因为开始日志范围没有调用 ILogger.BeginScope 方法）
        // Report 方法将直接返回
        Report(_currentScope.Value);
    }

    // 新建一个范围，并压栈
    public IDisposable Push(object? state)
    {
        // 当前范围作为父范围
        Scope? parent = _currentScope.Value;
        // 新建一个范围
        var newScope = new Scope(this, state, parent);
        // 将新建的范围保存到 AsyncLocal<> 中，作为当前范围
        _currentScope.Value = newScope;

        return newScope;
    }
}
```

- Scope  
```C#
// 表示日志范围的数据结构
// 实现 IDisposable.Dispose 方法（用来完成日志范围的出栈）
private sealed class Scope : IDisposable
{
    // IExternalScopeProvider
    private readonly LoggerFactoryScopeProvider _provider;
    private bool _isDisposed;

    internal Scope(LoggerFactoryScopeProvider provider, object? state, Scope? parent)
    {
        _provider = provider;
        State = state;
        Parent = parent;
    }

    // 父范围
    public Scope? Parent { get; }

    public object? State { get; }

    public override string? ToString()
    {
        return State?.ToString();
    }

    // 将父范围保存到 AsyncLocal<> 中，实现当前范围的出栈
    public void Dispose()
    {
        if (!_isDisposed)
        {
            _provider._currentScope.Value = Parent;
            _isDisposed = true;
        }
    }
}
```

- LoggerMessage  
```C#
// 提供基于占位符的日志消息模板方法
// 可以避免消息模板的重复解析
public static class LoggerMessage
{
    // 利用模板字符串得到发送日志事件消息的委托（最全参数签名）
    // formateString 支持 {数字} 和 {文本} 占位符
    public static Action<ILogger, T1, T2, T3, T4, T5, T6, Exception?> Define<T1, T2, T3, T4, T5, T6>(LogLevel logLevel, EventId eventId, string formatString, LogDefineOptions? options)
    {
        // 根据消息模板字符串解析得到格式化器
        // 不管是使用 {数字} 或 {文本} 占位符，内部最终会转换为 string.Format 方法所支持的以参数索引形式的格式化字符串
        LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, expectedNamedParameterCount: 6);

        // 编译器会根据闭包变量 formatter 和泛型参数创建内部匿名泛型类型
        // 避免重复解析的关键就是通过编译时生成的内部匿名泛型类型并定义 LogValuesFormatter 类型的字段
        void Log(ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, Exception? exception)
        {
            logger.Log(logLevel, eventId, new LogValues<T1, T2, T3, T4, T5, T6>(formatter, arg1, arg2, arg3, arg4, arg5, arg6), exception, LogValues<T1, T2, T3, T4, T5, T6>.Callback);
        }

        // 是否跳过 IsEnable 检查
        if (options != null && options.SkipEnabledCheck)
        {
            return Log;
        }

        // 不跳过 IsEnable 检查
        // 确定是否至少有一个由 ILoggerProvider 创建的 ILogger 可以发送日志事件消息
        return (logger, arg1, arg2, arg3, arg4, arg5, arg6, exception) =>
        {
            if (logger.IsEnabled(logLevel))
            {
                Log(logger, arg1, arg2, arg3, arg4, arg5, arg6, exception);
            }
        };
    }

    // 利用模板字符串得到开始日志范围消息的委托（最全参数签名）
    // formateString 支持 {数字} 和 {文本} 占位符
    public static Func<ILogger, T1, T2, T3, T4, T5, T6, IDisposable?> DefineScope<T1, T2, T3, T4, T5, T6>(string formatString)
    {
        LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, expectedNamedParameterCount: 6);

        return (logger, arg1, arg2, arg3, arg4, arg5, arg6) => logger.BeginScope(new LogValues<T1, T2, T3, T4, T5, T6>(formatter, arg1, arg2, arg3, arg4, arg5, arg6));
    }

    // 日志事件消息的生成器
    // 利用格式化器对日志事件消息进行格式化输出
    private readonly struct LogValues<T0, T1, T2, T3, T4, T5> : IReadOnlyList<KeyValuePair<string, object?>>
    {
        // 消息格式化委托
        // 对消息进行格式化输出
        public static readonly Func<LogValues<T0, T1, T2, T3, T4, T5>, Exception?, string> Callback = (state, exception) => state.ToString();

        private readonly LogValuesFormatter _formatter;
        private readonly T0 _value0;
        private readonly T1 _value1;
        private readonly T2 _value2;
        private readonly T3 _value3;
        private readonly T4 _value4;
        private readonly T5 _value5;

        public int Count => 7;

        public KeyValuePair<string, object?> this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[0], _value0);
                    case 1:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[1], _value1);
                    case 2:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[2], _value2);
                    case 3:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[3], _value3);
                    case 4:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[4], _value4);
                    case 5:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[5], _value5);
                    case 6:
                        return new KeyValuePair<string, object?>("{OriginalFormat}", _formatter.OriginalFormat);
                    default:
                        throw new IndexOutOfRangeException(nameof(index));
                }
            }
        }

        public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)
        {
            _formatter = formatter;
            _value0 = value0;
            _value1 = value1;
            _value2 = value2;
            _value3 = value3;
            _value4 = value4;
            _value5 = value5;
        }

        // 输出日志事件消息的参数
        private object?[] ToArray() => new object?[] { _value0, _value1, _value2, _value3, _value4, _value5 };

        // 格式化器根据解析得到的格式化字符串利用传入的参数输出格式化消息
        public override string ToString() => _formatter.FormatWithOverwrite(ToArray());

        public IEnumerator<KeyValuePair<string, object?>> GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
```

## 依赖注入

- LoggingServiceCollectionExtensions  
```C#
// 提供日志核心服务注册的扩展方法
public static class LoggingServiceCollectionExtensions
{
    public static IServiceCollection AddLogging(this IServiceCollection services)
    {
        return AddLogging(services, builder => { });
    }

    public static IServiceCollection AddLogging(this IServiceCollection services, Action<ILoggingBuilder> configure)
    {
        ThrowHelper.ThrowIfNull(services);

        // 注册选项核心服务
        services.AddOptions();

        // 注册日志工厂
        services.TryAdd(ServiceDescriptor.Singleton<ILoggerFactory, LoggerFactory>());
        // 注册泛型 ILogger<>
        services.TryAdd(ServiceDescriptor.Singleton(typeof(ILogger<>), typeof(Logger<>)));

        // 注册默认最低日志等级的选项配置
        services.TryAddEnumerable(ServiceDescriptor.Singleton<IConfigureOptions<LoggerFilterOptions>>(
            new DefaultLoggerLevelConfigureOptions(LogLevel.Information)));

        // 创建 LoggingBuilder
        configure(new LoggingBuilder(services));
        return services;
    }
}
```

- LoggingBuilder  
```C#
// 日志构建者
// 本质是对 IServiceCollection 的封装
// 便于利用其它 ILoggingBuilder 扩展方法提供日志相关服务的注册
internal sealed class LoggingBuilder : ILoggingBuilder
{
    public LoggingBuilder(IServiceCollection services)
    {
        Services = services;
    }

    public IServiceCollection Services { get; }
}
```

- LoggingBuilderExtensions  
```C#
// 基于 ILoggingBuilder 的扩展方法
// 提供日志相关服务的注册
// Microsoft.Extensions.Logging.LoggingBuilderExtensions
public static class LoggingBuilderExtensions
{
    // 注册 LoggerFilterOptions 选项配置
    // 用来设置最小日志事件等级
    public static ILoggingBuilder SetMinimumLevel(this ILoggingBuilder builder, LogLevel level)
    {
        builder.Services.Add(ServiceDescriptor.Singleton<IConfigureOptions<LoggerFilterOptions>>(
            new DefaultLoggerLevelConfigureOptions(level)));
        return builder;
    }

    // 注册 ILoggerProvider 实例
    public static ILoggingBuilder AddProvider(this ILoggingBuilder builder, ILoggerProvider provider)
    {
        builder.Services.AddSingleton(provider);
        return builder;
    }

    // 清空所有已注册的 ILoggerProvider 服务
    public static ILoggingBuilder ClearProviders(this ILoggingBuilder builder)
    {
        builder.Services.RemoveAll<ILoggerProvider>();
        return builder;
    }

    // 注册 LoggerFactoryOptions 选项配置
    // 用来设置活动跟踪选项
    public static ILoggingBuilder Configure(this ILoggingBuilder builder, Action<LoggerFactoryOptions> action)
    {
        builder.Services.Configure(action);
        return builder;
    }

    // 使用 IConfiguration 注册服务
    public static ILoggingBuilder AddConfiguration(this ILoggingBuilder builder, IConfiguration configuration)
    {
        builder.AddConfiguration();

        // 注册 LoggerFilterOptions 选项配置
        // 使用基于文件配置来设置选项中的 LoggerFilterRule 集合
        builder.Services.AddSingleton<IConfigureOptions<LoggerFilterOptions>>(new LoggerFilterConfigureOptions(configuration));
        // 注册 IOptionsChangeTokenSource<LoggerFilterOptions> 服务
        // 通过注入 IOptionsMonitor<LoggerFilterOptions> 来得到选项，所以需要监控配置文件的变动随时更新过滤选项
        builder.Services.AddSingleton<IOptionsChangeTokenSource<LoggerFilterOptions>>(new ConfigurationChangeTokenSource<LoggerFilterOptions>(configuration));

        // 注册 LoggingConfiguration
        // 作为 IConfigurationRoot 的封装
        builder.Services.AddSingleton(new LoggingConfiguration(configuration));

        return builder;
    }
}
```

- LoggingBuilderConfigurationExtensions  
```C#
// ILoggerProvider 配置相关服务注册的扩展方法
public static class LoggingBuilderConfigurationExtensions
{
    public static void AddConfiguration(this ILoggingBuilder builder)
    {
        // 注册 ILoggerProviderConfigurationFactory
        builder.Services.TryAddSingleton<ILoggerProviderConfigurationFactory, LoggerProviderConfigurationFactory>();
        // 注册 ILoggerProviderConfiguration<>
        // 在服务消费时，泛型实参对应不同的 ILoggerProvider 类型
        builder.Services.TryAddSingleton(typeof(ILoggerProviderConfiguration<>), typeof(LoggerProviderConfiguration<>));
    }
}
```

- ILoggerProviderConfigurationFactory  
```C#
// ILoggerProvider 配置工厂
public interface ILoggerProviderConfigurationFactory
{
    // 根据不同的 ILoggerProvider 类型从 IConfigurationRoot 中得到对应配置节的 IConfigurationSection
    // 然后通过 IConfigurationBuilder.AddConfiguration 方法将 IConfigurationSection 构建为 ChainedConfigurationSource
    // 最终得到一个新的针对具体 ILoggerProvider 类型的 IConfigurationRoot
    IConfiguration GetConfiguration(Type providerType);
}
```

- LoggerProviderConfigurationFactory  
```C#
// ILoggerProviderConfigurationFactory 默认实现
internal sealed class LoggerProviderConfigurationFactory : ILoggerProviderConfigurationFactory
{
    private readonly IEnumerable<LoggingConfiguration> _configurations;

    public LoggerProviderConfigurationFactory(IEnumerable<LoggingConfiguration> configurations)
    {
        _configurations = configurations;
    }

    // 得到一个新的针对具体 ILoggerProvider 类型的 IConfigurationRoot
    public IConfiguration GetConfiguration(Type providerType)
    {
        ThrowHelper.ThrowIfNull(providerType);

        string fullName = providerType.FullName!;
        string? alias = ProviderAliasUtilities.GetAlias(providerType);
        // 创建 ConfigurationBuilder 用来构建 IConfigurationRoot
        var configurationBuilder = new ConfigurationBuilder();
        foreach (LoggingConfiguration configuration in _configurations)
        {
            IConfigurationSection sectionFromFullName = configuration.Configuration.GetSection(fullName);
            configurationBuilder.AddConfiguration(sectionFromFullName);

            if (!string.IsNullOrWhiteSpace(alias))
            {
                IConfigurationSection sectionFromAlias = configuration.Configuration.GetSection(alias);
                configurationBuilder.AddConfiguration(sectionFromAlias);
            }
        }
        return configurationBuilder.Build();
    }
}
```

- ILoggerProviderConfiguration\<\>  
```C#
// ILoggerProvider 配置的抽象表示
public interface ILoggerProviderConfiguration<T>
{
    // 根据 ILoggerProvider 类型得到的 IConfigurationRoot
    IConfiguration Configuration { get; }
}
```

- LoggerProviderConfiguration\<\>  
```C#
// ILoggerProviderConfiguration<> 默认实现
internal sealed class LoggerProviderConfiguration<T> : ILoggerProviderConfiguration<T>
{
    public LoggerProviderConfiguration(ILoggerProviderConfigurationFactory providerConfigurationFactory)
    {
        // 根据 ILoggerProvider 类型得到对应的 IConfigurationRoot
        Configuration = providerConfigurationFactory.GetConfiguration(typeof(T));
    }

    public IConfiguration Configuration { get; }
}
```

- LoggerProviderOptions  
```C#
// ILoggerProvider 选项
// 由于可以通过依赖注入方式得到 ILoggerProviderConfiguration<> 并通过 Configuration 属性所引用的 IConfigurationRoot 访问配置
// 所以可以通过注册选项配置来将对应的配置绑定到选项上
// 此处没有使用扩展方法令人费解？
public static class LoggerProviderOptions
{
    public static void RegisterProviderOptions<TOptions, TProvider>(IServiceCollection services) where TOptions : class
    {
        // 根据选项类型和 ILoggerProvider 类型注册选项配置
        services.TryAddEnumerable(ServiceDescriptor.Singleton<IConfigureOptions<TOptions>, LoggerProviderConfigureOptions<TOptions, TProvider>>());
        // 由于配置来源于文件，所以会使用 IOptionsMonitor<> 作为依赖注入时的服务类型，可以通过注册 IOptionsChangeTokenSource<> 来监控文件的变动
        // 并在变动后发出回调更新选项
        services.TryAddEnumerable(ServiceDescriptor.Singleton<IOptionsChangeTokenSource<TOptions>, LoggerProviderOptionsChangeTokenSource<TOptions, TProvider>>());
    }
}
```

- LoggerProviderConfigureOptions\<,\>  
```C#
// 针对 ILoggerProvider 配置选项的默认实现
// 通过继承 ConfigureFromConfigurationOptions<> 绑定配置
internal sealed class LoggerProviderConfigureOptions<TOptions, TProvider> : ConfigureFromConfigurationOptions<TOptions> where TOptions : class
{
    public LoggerProviderConfigureOptions(ILoggerProviderConfiguration<TProvider> providerConfiguration)
        : base(providerConfiguration.Configuration)
    {
    }
}
```

- LoggerProviderOptionsChangeTokenSource\<,\>  
```C#
// 针对 ILoggerProvider 配置变化的监控
// 通过继承 ConfigurationChangeTokenSource<> 监控变化
public class LoggerProviderOptionsChangeTokenSource<TOptions, TProvider> : ConfigurationChangeTokenSource<TOptions>
{
    public LoggerProviderOptionsChangeTokenSource(ILoggerProviderConfiguration<TProvider> providerConfiguration) : base(providerConfiguration.Configuration)
    {
    }
}
```

- FilterLoggingBuilderExtensions  
```C#
// 通过提供 filter 委托注册 LoggerFilterOptions 选项配置的扩展方法
public static class FilterLoggingBuilderExtensions
{
    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string?, string?, LogLevel, bool> filter) =>
        builder.ConfigureFilter(options => options.AddFilter(filter));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string?, LogLevel, bool> categoryLevelFilter) =>
        builder.ConfigureFilter(options => options.AddFilter(categoryLevelFilter));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, Func<string?, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(categoryLevelFilter));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<LogLevel, bool> levelFilter) =>
        builder.ConfigureFilter(options => options.AddFilter(levelFilter));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(levelFilter));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string? category, LogLevel level) =>
        builder.ConfigureFilter(options => options.AddFilter(category, level));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string? category, LogLevel level) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(category, level));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string? category, Func<LogLevel, bool> levelFilter) =>
        builder.ConfigureFilter(options => options.AddFilter(category, levelFilter));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string? category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(category, levelFilter));

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string?, string?, LogLevel, bool> filter) =>
        AddRule(builder, filter: filter);

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string?, LogLevel, bool> categoryLevelFilter) =>
        AddRule(builder, filter: (type, name, level) => categoryLevelFilter(name, level));

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, Func<string?, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, filter: (type, name, level) => categoryLevelFilter(name, level));

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<LogLevel, bool> levelFilter) =>
        AddRule(builder, filter: (type, name, level) => levelFilter(level));

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, filter: (type, name, level) => levelFilter(level));

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string? category, LogLevel level) =>
        AddRule(builder, category: category, level: level);

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string? category, LogLevel level) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, category: category, level: level);

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string? category, Func<LogLevel, bool> levelFilter) =>
        AddRule(builder, category: category, filter: (type, name, level) => levelFilter(level));

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string? category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, category: category, filter: (type, name, level) => levelFilter(level));

    private static ILoggingBuilder ConfigureFilter(this ILoggingBuilder builder, Action<LoggerFilterOptions> configureOptions)
    {
        builder.Services.Configure(configureOptions);
        return builder;
    }

    private static LoggerFilterOptions AddRule(LoggerFilterOptions options,
        string? type = null,
        string? category = null,
        LogLevel? level = null,
        Func<string?, string?, LogLevel, bool>? filter = null)
    {
        options.Rules.Add(new LoggerFilterRule(type, category, level, filter));
        return options;
    }
}
```

- LoggerExtensions  
```C#
// 提供各种基于日志等级名称的日志记录方法
// 在运行时调用 ILogger.Log<> 方法时将 TState 泛型实参指定为 FormattedLogValues
// 并统一利用 MessageFormatter 作为格式化日志消息的委托
public static class LoggerExtensions
{
    private static readonly Func<FormattedLogValues, Exception?, string> _messageFormatter = MessageFormatter;

    public static void LogDebug(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, eventId, exception, message, args);
    }

    public static void LogDebug(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, eventId, message, args);
    }

    public static void LogDebug(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, exception, message, args);
    }

    public static void LogDebug(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, message, args);
    }

    public static void LogTrace(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, eventId, exception, message, args);
    }

    public static void LogTrace(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, eventId, message, args);
    }

    public static void LogTrace(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, exception, message, args);
    }

    public static void LogTrace(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, message, args);
    }

    public static void LogInformation(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, eventId, exception, message, args);
    }

    public static void LogInformation(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, eventId, message, args);
    }

    public static void LogInformation(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, exception, message, args);
    }

    public static void LogInformation(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, message, args);
    }

    public static void LogWarning(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, eventId, exception, message, args);
    }

    public static void LogWarning(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, eventId, message, args);
    }

    public static void LogWarning(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, exception, message, args);
    }

    public static void LogWarning(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, message, args);
    }

    public static void LogError(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, eventId, exception, message, args);
    }

    public static void LogError(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, eventId, message, args);
    }

    public static void LogError(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, exception, message, args);
    }

    public static void LogError(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, message, args);
    }

    public static void LogCritical(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, eventId, exception, message, args);
    }

    public static void LogCritical(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, eventId, message, args);
    }

    public static void LogCritical(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, exception, message, args);
    }

    public static void LogCritical(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, string? message, params object?[] args)
    {
        logger.Log(logLevel, 0, null, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(logLevel, eventId, null, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(logLevel, 0, exception, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        ThrowHelper.ThrowIfNull(logger);

        logger.Log(logLevel, eventId, new FormattedLogValues(message, args), exception, _messageFormatter);
    }

    public static IDisposable? BeginScope(
        this ILogger logger,
        string messageFormat,
        params object?[] args)
    {
        ThrowHelper.ThrowIfNull(logger);

        return logger.BeginScope(new FormattedLogValues(messageFormat, args));
    }

    private static string MessageFormatter(FormattedLogValues state, Exception? error)
    {
        return state.ToString();
    }
}
```