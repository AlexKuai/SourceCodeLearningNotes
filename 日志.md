## 源码涉及的核心类型
- EventId  
- LogLevel  

## 日志模型

- EventId  
```C#
// 表示日志事件的 ID 和 Name
public readonly struct EventId : IEquatable<EventId>
{
    // 重载隐式转换操作（支持 int 隐式转换为 EventId 类型）
    public static implicit operator EventId(int i)
    {
        return new EventId(i);
    }

    // 重载 == 运算符
    public static bool operator ==(EventId left, EventId right)
    {
        return left.Equals(right);
    }

    // 重载 != 运算符
    public static bool operator !=(EventId left, EventId right)
    {
        return !left.Equals(right);
    }

    // name 默认为 null
    public EventId(int id, string? name = null)
    {
        Id = id;
        Name = name;
    }

    // 事件 ID
    public int Id { get; }

    // 事件 Name
    public string? Name { get; }

    // 重写 ToString
    public override string ToString()
    {
        return Name ?? Id.ToString();
    }

    // 实现 IEquatable<EventId>
    public bool Equals(EventId other)
    {
        return Id == other.Id;
    }

    // 重写 Equals
    public override bool Equals(object? obj)
    {
        if (obj is null)
        {
            return false;
        }

        return obj is EventId eventId && Equals(eventId);
    }

    // 重写 GetHashCode
    public override int GetHashCode()
    {
        return Id;
    }
}
```

- LogLevel  
```C#
// 日志事件等级
// 严重程度由低到高（除 None 以外）
public enum LogLevel
{
    Trace = 0,
    Debug = 1,
    Information = 2,
    Warning = 3,
    Error = 4,
    Critical = 5,
    None = 6
}
```

- LoggerInformation  
```C#
// 日志信息
// 每个日志类别和不同 ILoggerProvider 的组合对应一个 ILogger
internal readonly struct LoggerInformation
{
    public LoggerInformation(ILoggerProvider provider, string category) : this()
    {
        ProviderType = provider.GetType();
        Logger = provider.CreateLogger(category);
        Category = category;
        ExternalScope = provider is ISupportExternalScope;
    }
    
    // 由 ILoggerProvider 创建的 ILogger
    // ILogger 内部通过对应的日志发布源（可被观察对象）发送日志事件
    // 订阅者（观察者）收到日志事件后将其输出到相应的渠道
    public ILogger Logger { get; }

    // 日志类别
    public string Category { get; }

    // ILoggerProvider 具体类型
    public Type ProviderType { get; }

    // ILoggerProvider 是否实现了 ISupportExternalScope
    // 实现了 ISupportExternalScope 就表明需要借助 IExternalScopeProvider 提供日志范围的活动跟踪
    // 没有实现的表明 ILoggerProvider 自身可以提供日志范围的活动跟踪
    public bool ExternalScope { get; }
}
```

- MessageLogger  
```C#
// 消息日志
// 利用 ILoggerProvider 全名、日志类别、日志等级过滤日志
internal readonly struct MessageLogger
{
    // 基于 LoggerInformation 得到的 logger、category、providerTypeFullName
    // 利用 category、providerTypeFullName 从 ILoggingBuilder.AddConfiguration、ILoggingBuilder.AddFilter、ILoggingBuilder.SetMinimumLevel 得到
    // 匹配的 minLevel 和 filter
    public MessageLogger(ILogger logger, string? category, string? providerTypeFullName, LogLevel? minLevel, Func<string?, string?, LogLevel, bool>? filter)
    {
        Logger = logger;
        Category = category;
        ProviderTypeFullName = providerTypeFullName;
        MinLevel = minLevel;
        Filter = filter;
    }

    // 由 ILoggerProvider 创建的 ILogger
    public ILogger Logger { get; }

    // 日志类别
    public string? Category { get; }

    // ILoggerProvider 全名
    // 可以使用 ProviderAliasAttribute 特性配置对应的别名
    private string? ProviderTypeFullName { get; }

    // 调用 ILoggingBuilder.AddConfiguration 从日志配置文件中根据 ILoggerProvider 全名和日志类别匹配到的最低日志等级
    // 或者全局最低日志等级
    public LogLevel? MinLevel { get; }

    // 利用 ILoggingBuilder.AddFilter 配置的针对 ILoggerProvider 全名、日志类别、日志等级的过滤规则方法
    public Func<string?, string?, LogLevel, bool>? Filter { get; }

    // 根据最低日志等级和过滤规则方法方法过滤发送的日志事件
    public bool IsEnabled(LogLevel level)
    {
        // 不满足最低日志级别直接返回 false
        if (MinLevel != null && level < MinLevel)
        {
            return false;
        }

        // 满足最低日志级别后可以继续使用过滤规则方法判断
        if (Filter != null)
        {
            return Filter(ProviderTypeFullName, Category, level);
        }

        return true;
    }
}
```

- ScopeLogger  
```C#
// 范围日志
// 如果 ILoggerProvider 实现了 ISupportExternalScope 就表明其自身不具有基于日志范围的活动跟踪
// 这时候就需要通过 IExternalScopeProvider 提供日志范围的活动跟踪
internal readonly struct ScopeLogger
{
    public ScopeLogger(ILogger? logger, IExternalScopeProvider? externalScopeProvider)
    {
        Debug.Assert(logger != null || externalScopeProvider != null, "Logger can't be null when there isn't an ExternalScopeProvider");

        Logger = logger;
        ExternalScopeProvider = externalScopeProvider;
    }

    // 由 ILoggerProvider 创建的 ILogger
    public ILogger? Logger { get; }

    // 实现 IExternalScopeProvider 接口的 ILoggerProvider
    public IExternalScopeProvider? ExternalScopeProvider { get; }

    // 创建范围
    // 实现的核心就是创建当前范围的数据结构并指向父范围的数据结构形成一个单向链表（父范围 <- 当前范围），并利用 AsyncLocal<T> 保存表示当前范围的数据结构
    public IDisposable? CreateScope<TState>(TState state) where TState : notnull
    {
        if (ExternalScopeProvider != null)
        {
            return ExternalScopeProvider.Push(state);
        }

        Debug.Assert(Logger != null);
        return Logger.BeginScope<TState>(state);
    }
}
```

- ILoggerFactory
```C#
// Logger 工厂的抽象表示
public interface ILoggerFactory : IDisposable
{
    // 利用 categoryName 创建对应日志类别的 Logger
    // 创建的 ILogger 只是提供应用程序写入日志事件的入口
    ILogger CreateLogger(string categoryName);

    // 添加 ILoggerProvider
    void AddProvider(ILoggerProvider provider);
}
```

- LoggerFactory  
```C#
// ILoggerFactory 的默认实现
public class LoggerFactory : ILoggerFactory
{
    // 缓存根据不同日志类别创建的 Logger
    private readonly Dictionary<string, Logger> _loggers = new Dictionary<string, Logger>(StringComparer.Ordinal);
    // Logger 提供者注册列表
    private readonly List<ProviderRegistration> _providerRegistrations = new List<ProviderRegistration>();
    // 同步锁
    private readonly object _sync = new object();
    // 是否执行过释放操作标志
    private volatile bool _disposed;
    // 用来取消注册 IOptionsMonitor<LoggerFilterOptions> 的 OnChange 回调
    private IDisposable? _changeTokenRegistration;
    // 日志过滤选项
    private LoggerFilterOptions _filterOptions;
    // 外部范围提供者
    private IExternalScopeProvider? _scopeProvider;
    // 日志工厂选项
    // 主要作用是配置活动跟踪选项
    private LoggerFactoryOptions _factoryOptions;

    public LoggerFactory() : this(Array.Empty<ILoggerProvider>())
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers) : this(providers, new StaticFilterOptionsMonitor(new LoggerFilterOptions()))
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers, LoggerFilterOptions filterOptions) : this(providers, new StaticFilterOptionsMonitor(filterOptions))
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption) : this(providers, filterOption, null)
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions>? options) : this(providers, filterOption, options, null)
    {
    }

    // 参数：
    // 1. 所有注册的 Logger 提供者
    // 2. 基于文件配置的 LoggerFilterOptions 并可以监控配置改变的 IOptionsMonitor<LoggerFilterOptions>
    // 3. 启用日志范围后的活动跟踪选项配置 IOptions<LoggerFactoryOptions>
    // 4. 外部日志范围提供者 IExternalScopeProvider
    // 依赖注入框架会选取此为最优构造函数
    public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption, IOptions<LoggerFactoryOptions>? options = null, IExternalScopeProvider? scopeProvider = null)
    {
        _scopeProvider = scopeProvider;

        // 可能未注册 LoggerFactoryOptions 的选项配置
        _factoryOptions = options == null || options.Value == null ? new LoggerFactoryOptions() : options.Value;

        // 对除 None 以外的所有枚举按位或后取非
        const ActivityTrackingOptions ActivityTrackingOptionsMask = ~(ActivityTrackingOptions.SpanId | ActivityTrackingOptions.TraceId | ActivityTrackingOptions.ParentId |
                                                                      ActivityTrackingOptions.TraceFlags | ActivityTrackingOptions.TraceState | ActivityTrackingOptions.Tags
                                                                      | ActivityTrackingOptions.Baggage);

        // 如果和 ActivityTrackingOptionsMask 按位与操作后不为零，表明配置了未定义的枚举值，则抛出异常
        if ((_factoryOptions.ActivityTrackingOptions & ActivityTrackingOptionsMask) != 0)
        {
            throw new ArgumentException(SR.Format(SR.InvalidActivityTrackingOptions, _factoryOptions.ActivityTrackingOptions), nameof(options));
        }
        // 遍历 Logger 提供者，添加进注册中心
        foreach (ILoggerProvider provider in providers)
        {
            AddProviderRegistration(provider, dispose: false);
        }
        
        // 监控日志过滤规则配置文件的改变
        // 在改变后重新获取 LoggerFilterOptions 并刷新应用规则
        _changeTokenRegistration = filterOption.OnChange(RefreshFilters);
        // 初始化使用 IOptionsMonitor<LoggerFilterOptions> 的 CurrentValue（空字符串命名）获取选项
        // 刷新应用规则
        RefreshFilters(filterOption.CurrentValue);
    }

    // 刷新应用规则
    private void RefreshFilters(LoggerFilterOptions filterOptions)
    {
        lock (_sync)
        {
            // 更新 LoggerFilterOptions
            _filterOptions = filterOptions;
            foreach (KeyValuePair<string, Logger> registeredLogger in _loggers)
            {
                Logger logger = registeredLogger.Value;
                // 应用新的过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);
            }
        }
    }

    // 根据 categoryName 日志类别创建获取 Logger
    public ILogger CreateLogger(string categoryName)
    {
        if (CheckDisposed())
        {
            throw new ObjectDisposedException(nameof(LoggerFactory));
        }

        // 在并发情况下应用新的过滤规则需要同步完成
        lock (_sync)
        {
            if (!_loggers.TryGetValue(categoryName, out Logger? logger))
            {
                // 基于日志类别创建 ILogger
                // 利用 CreateLoggers 方法创建 LoggerInformation 数组
                logger = new Logger(CreateLoggers(categoryName));

                // 应用过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);

                // 添加新的日志类别和对应的 ILogger
                _loggers[categoryName] = logger;
            }

            return logger;
        }
    }

    // 添加新的 ILoggerProvider
    public void AddProvider(ILoggerProvider provider)
    {
        if (CheckDisposed())
        {
            throw new ObjectDisposedException(nameof(LoggerFactory));
        }

        ThrowHelper.ThrowIfNull(provider);

        // 在并发情况下 ILogger 的创建需要同步完成
        lock (_sync)
        {
            // 添加进注册中心
            AddProviderRegistration(provider, dispose: true);
            // 遍历所有已经创建的 Logger
            // 利用新添加的 ILoggerProvider 创建新的 LoggerInformation，并应用过滤规则
            foreach (KeyValuePair<string, Logger> existingLogger in _loggers)
            {
                Logger logger = existingLogger.Value;
                LoggerInformation[] loggerInformation = logger.Loggers;

                int newLoggerIndex = loggerInformation.Length;
                // 扩容数组
                Array.Resize(ref loggerInformation, loggerInformation.Length + 1);
                // 根据 ILoggerProvider 和日志类别的组合创建新的 LoggerInformation，并添加到添加到末尾
                loggerInformation[newLoggerIndex] = new LoggerInformation(provider, existingLogger.Key);

                logger.Loggers = loggerInformation;
                //// 应用过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);
            }
        }
    }

    // 将 ILoggerProvider 添加进列表
    // 便于维护和释放
    private void AddProviderRegistration(ILoggerProvider provider, bool dispose)
    {
        _providerRegistrations.Add(new ProviderRegistration
        {
            Provider = provider,
            ShouldDispose = dispose
        });

        // 如果 ILoggerProvider 实现了 ISupportExternalScope 
        // 就为 ILoggerProvider 添加 LoggerFactoryScopeProvider（LoggerFactoryScopeProvider 实现了 IExternalScopeProvider）
        // 利用 IExternalScopeProvider 为 ILoggerProvider 提供基于范围的活动跟踪
        if (provider is ISupportExternalScope supportsExternalScope)
        {
            // 利用 ActivityTrackingOptions 创建 LoggerFactoryScopeProvider
            _scopeProvider ??= new LoggerFactoryScopeProvider(_factoryOptions.ActivityTrackingOptions);

            supportsExternalScope.SetScopeProvider(_scopeProvider);
        }
    }

    // 利用 categoryName 和所有已注册的 ILoggerProvider 创建 LoggerInformation 数组
    private LoggerInformation[] CreateLoggers(string categoryName)
    {
        var loggers = new LoggerInformation[_providerRegistrations.Count];
        for (int i = 0; i < _providerRegistrations.Count; i++)
        {
            loggers[i] = new LoggerInformation(_providerRegistrations[i].Provider, categoryName);
        }
        return loggers;
    }

    // 应用过滤规则
    private (MessageLogger[] MessageLoggers, ScopeLogger[]? ScopeLoggers) ApplyFilters(LoggerInformation[] loggers)
    {
        var messageLoggers = new List<MessageLogger>();
        // 根据 LoggerFilterOptions 的 CaptureScopes 属性决定是否启用日志范围的活动跟踪，这个属性默认值为 true
        List<ScopeLogger>? scopeLoggers = _filterOptions.CaptureScopes ? new List<ScopeLogger>() : null;

        foreach (LoggerInformation loggerInformation in loggers)
        {
            // 选择最优的 LoggerFilterRule
            // 匹配规则：
            // 1. 具体的针对 ILoggerProvider 的规则优先级高于默认规则
            // 2. 日志类别基于前缀匹配规则
            // 3. 对于 Foo.Bar.Baz 的日志类别，配置中 Foo.Bar 的规则比 Foo 的规则优先级更高
            // 4. 有多个优先级相同的规则选择最后一个
            // 5. 以上规则没有匹配到选择最后一个通过 ILoggingBuilder.AddFilter 添加的配置方法
            // 6. 以上规则没有匹配到使用全局最低日志等级
            LoggerRuleSelector.Select(_filterOptions,
                loggerInformation.ProviderType,
                loggerInformation.Category,
                out LogLevel? minLevel,
                out Func<string?, string?, LogLevel, bool>? filter);

            // 无效的最低日志等级
            if (minLevel is not null and > LogLevel.Critical)
            {
                continue;
            }

            messageLoggers.Add(new MessageLogger(loggerInformation.Logger, loggerInformation.Category, loggerInformation.ProviderType.FullName, minLevel, filter));

            // 不需要由 IExternalScopeProvider 提供日志范围的活动跟踪
            // 直接使用 ILoggerProvider 创建的 ILogger 构建 ScopeLogger
            if (!loggerInformation.ExternalScope)
            {
                scopeLoggers?.Add(new ScopeLogger(logger: loggerInformation.Logger, externalScopeProvider: null));
            }
        }

        // 是否有提供的默认 IExternalScopeProvider
        // 如果有就追加上，表明有实现了 ISupportExternalScope 接口的 IServiceProvider 需要由 IExternalScopeProvider 提供日志范围的活动跟踪
        if (_scopeProvider != null)
        {
            scopeLoggers?.Add(new ScopeLogger(logger: null, externalScopeProvider: _scopeProvider));
        }

        return (messageLoggers.ToArray(), scopeLoggers?.ToArray());
    }

    // 检查是否已经执行过释放
    protected virtual bool CheckDisposed() => _disposed;

    // 释放
    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;

            _changeTokenRegistration?.Dispose();

            foreach (ProviderRegistration registration in _providerRegistrations)
            {
                try
                {
                    if (registration.ShouldDispose)
                    {
                        registration.Provider.Dispose();
                    }
                }
                catch
                {

                }
            }
        }
    }

    private struct ProviderRegistration
    {
        public ILoggerProvider Provider;
        public bool ShouldDispose;
    }
}
```