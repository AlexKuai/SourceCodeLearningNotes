## 源码涉及的核心类型
- EventId  
- LogLevel  
- ILogger  
- Logger  
- ILogger\<\>  
- Logger\<\>  
- LoggerInformation  
- MessageLogger  
- ScopeLogger  
- LoggerFactoryOptions  
- LoggerFilterOptions  
- LoggerFilterRule  
- ILoggerFactory  
- LoggerFactory  
- ILoggerProvider  
- IExternalScopeProvider  
- LoggerFactoryScopeProvider  
- Scope  
- Activity  
- ActivitySource  
- ActivityListener  
- LoggerMessage  
- LoggingServiceCollectionExtensions  
- DefaultLoggerLevelConfigureOptions  
- LoggerFilterConfigureOptions  
- LoggingBuilder  
- LoggingBuilderExtensions  
- LoggingBuilderConfigurationExtensions  
- LoggingConfiguration  
- ILoggerProviderConfigurationFactory  
- LoggerProviderConfigurationFactory  
- ILoggerProviderConfiguration\<\>  
- LoggerProviderConfiguration\<\>  
- LoggerProviderOptions  
- LoggerProviderConfigureOptions\<,\>  
- LoggerProviderOptionsChangeTokenSource\<,\>  
- FilterLoggingBuilderExtensions  
- LoggerExtensions  
- ConsoleLoggerProvider  
- ConsoleLogger  
- LogEntry\<\>  
- ConsoleLoggerOptions  
- ConsoleFormatter  
- ConsoleFormatterOptions  
- SimpleConsoleFormatterOptions  
- ConsoleLoggerExtensions  
- ConsoleLoggerFormatterConfigureOptions\<,\>  
- ConsoleLoggerFormatterOptionsChangeTokenSource\<,\>  

## 日志模型

- EventId  
```C#
// 表示日志事件的 ID 和 Name
public readonly struct EventId : IEquatable<EventId>
{
    // 重载隐式转换操作
    // 支持将 int 类型隐式转换为 EventId 类型
    public static implicit operator EventId(int i)
    {
        return new EventId(i);
    }

    // 重载 == 运算符
    public static bool operator ==(EventId left, EventId right)
    {
        return left.Equals(right);
    }

    // 重载 != 运算符
    public static bool operator !=(EventId left, EventId right)
    {
        return !left.Equals(right);
    }

    // name 默认为 null
    public EventId(int id, string? name = null)
    {
        Id = id;
        Name = name;
    }

    // 事件 ID
    public int Id { get; }

    // 事件 Name
    public string? Name { get; }

    // 重写 ToString
    public override string ToString()
    {
        return Name ?? Id.ToString();
    }

    // 实现 IEquatable<EventId>
    public bool Equals(EventId other)
    {
        return Id == other.Id;
    }

    // 重写 Equals
    public override bool Equals(object? obj)
    {
        if (obj is null)
        {
            return false;
        }

        return obj is EventId eventId && Equals(eventId);
    }

    // 重写 GetHashCode
    public override int GetHashCode()
    {
        return Id;
    }
}
```

- LogLevel  
```C#
// 日志事件等级
// 严重程度由低到高（除 None 以外）
public enum LogLevel
{
    Trace = 0,
    Debug = 1,
    Information = 2,
    Warning = 3,
    Error = 4,
    Critical = 5,
    None = 6
}
```

- ILogger  
```C#
// 日志记录器接口
public interface ILogger
{
    // 为应用程序提供的日志写入方法
    void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter);

    // 日志事件等级检查方法
    // 本质是遍历当前日志类别下的所有 MessageLogger 并调用 MessageLogger.IsEnable 方法
    // 并且还会继续调用 ILogger.IsEnable 方法（由 ILoggerProvider 创建的 ILogger）
    // 只有这些调用没有一个返回 false，此方法才会返回 true
    bool IsEnabled(LogLevel logLevel);

    // 日志范围开始方法
    // 用于记录日志范围的活动跟踪
    IDisposable? BeginScope<TState>(TState state) where TState : notnull;
}
```

- Logger  
```C#
// ILogger 的默认实现
// 提供应用程序发送日志事件的入口对象
// 每个日志类别对应一个 Logger
internal sealed class Logger : ILogger
{
    public Logger(LoggerInformation[] loggers) => Loggers = loggers;

    // 数组的元素数量与注册的 ILoggerProvider 数量一致
    public LoggerInformation[] Loggers { get; set; }
    // 数组的元素数量与注册的 ILoggerProvider 数量一致
    public MessageLogger[]? MessageLoggers { get; set; }
    // 数组的元素数量与注册的 ILoggerProvider 数量可能不一致
    // 如果注册的 ILoggerProvider 没有一个实现了 ISupportExternalScope 接口，则数量一致
    // 如果注册的 ILoggerProvider 至少有一个实现了 ISupportExternalScope 接口，则数量就会少于注册的 ILoggerProvider 数量
    // 因为实现了 ISupportExternalScope 接口的所有 ILoggerProvider 本质上共用一个 IExternalScopeProvider 来提供日志范围的活动跟踪
    public ScopeLogger[]? ScopeLoggers { get; set; }

    // 作为提供应用程序发送日志事件的入口函数
    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        MessageLogger[]? loggers = MessageLoggers;
        if (loggers == null)
        {
            return;
        }

        List<Exception>? exceptions = null;
        for (int i = 0; i < loggers.Length; i++)
        {
            ref readonly MessageLogger loggerInfo = ref loggers[i];
            // 根据最低日志等级或过滤规则过滤日志事件输出
            if (!loggerInfo.IsEnabled(logLevel))
            {
                continue;
            }

            // 满足最低日志事件等级或过滤规则，则使用由 ILoggerProvider 创建的 ILogger 发送日志事件
            LoggerLog(logLevel, eventId, loggerInfo.Logger, exception, formatter, ref exceptions, state);
        }

        if (exceptions != null && exceptions.Count > 0)
        {
            ThrowLoggingError(exceptions);
        }

        // 调用由 ILoggerProvider 创建的 ILogger 利用对应的日志事件源发送日志事件
        static void LoggerLog(
            LogLevel logLevel, 
            EventId eventId, 
            ILogger logger, 
            Exception? exception, 
            Func<TState, Exception?, string> formatter, 
            ref List<Exception>? exceptions, 
            in TState state)
        {
            try
            {
                logger.Log(logLevel, eventId, state, exception, formatter);
            }
            catch (Exception ex)
            {
                exceptions ??= new List<Exception>();
                exceptions.Add(ex);
            }
        }
    }

    // 最低日志事件等级或过滤规则检查方法
    // 可以利用此方法检查是否存在至少一个满足最低日志事件等级或过滤规则的 ILogger
    public bool IsEnabled(LogLevel logLevel)
    {
        MessageLogger[]? loggers = MessageLoggers;
        if (loggers == null)
        {
            return false;
        }

        List<Exception>? exceptions = null;
        int i = 0;
        for (; i < loggers.Length; i++)
        {
            ref readonly MessageLogger loggerInfo = ref loggers[i];
            if (!loggerInfo.IsEnabled(logLevel))
            {
                continue;
            }

            // 继续使用由 ILoggerProvider 创建的 ILogger 检查是否满足最低日志事件等级或其他过滤规则
            if (LoggerIsEnabled(logLevel, loggerInfo.Logger, ref exceptions))
            {
                break;
            }
        }

        if (exceptions != null && exceptions.Count > 0)
        {
            ThrowLoggingError(exceptions);
        }

        // i < loggers.Length 表明至少有一个由 ILoggerProvider 创建的 ILogger 满足最低日志事件等级或过滤规则，可以发送日志事件
        return i < loggers.Length ? true : false;

        static bool LoggerIsEnabled(LogLevel logLevel, ILogger logger, ref List<Exception>? exceptions)
        {
            try
            {
                if (logger.IsEnabled(logLevel))
                {
                    return true;
                }
            }
            catch (Exception ex)
            {
                exceptions ??= new List<Exception>();
                exceptions.Add(ex);
            }

            return false;
        }
    }

    // 开始日志范围的活动跟踪
    // 本质上就是由 ILoggerProvider 创建的 ILogger 来创建一个表示日志范围的结构
    // 当前日志范围指向父日志范围形成一个单向链表（父范围 <- 当前范围），并利用 AsyncLocal<T> 保存当前范围，实现在不同线程间传递
    public IDisposable? BeginScope<TState>(TState state) where TState : notnull
    {
        ScopeLogger[]? loggers = ScopeLoggers;

        if (loggers == null)
        {
            return NullScope.Instance;
        }

        if (loggers.Length == 1)
        {
            return loggers[0].CreateScope(state);
        }

        // 此处的 Scope 作用是对多个日志范围的收集器
        // 便于对收集的多个日志范围出栈
        var scope = new Scope(loggers.Length);
        List<Exception>? exceptions = null;
        for (int i = 0; i < loggers.Length; i++)
        {
            ref readonly ScopeLogger scopeLogger = ref loggers[i];

            try
            {
                // 代表日志范围的类型实现了 IDisposable 接口
                // 可以在范围结束时通过调用 IDisposable.Dispose 方法完成当前范围的出栈操作
                scope.SetDisposable(i, scopeLogger.CreateScope(state));
            }
            catch (Exception ex)
            {
                exceptions ??= new List<Exception>();
                exceptions.Add(ex);
            }
        }

        if (exceptions != null && exceptions.Count > 0)
        {
            ThrowLoggingError(exceptions);
        }

        return scope;
    }

    private static void ThrowLoggingError(List<Exception> exceptions)
    {
        throw new AggregateException(
            message: "An error occurred while writing to logger(s).", innerExceptions: exceptions);
    }
}
```

- ILogger\<\>  
```C#
// 便于利用依赖注入方式使用日志
// 泛型参数可以将组件、服务等类型的名称作为日志类别
public interface ILogger<out TCategoryName> : ILogger
{

}
```

- Logger\<\>  
```C#
// ILogger<> 默认实现
// 本质是 ILogger 的包装类型
// 利用泛型强类型名称表示日志类别
// 便于将组件、服务等类型作为日志类别
// 内部实际是对 ILogger 方法的调用
public class Logger<T> : ILogger<T>
{
    private readonly ILogger _logger;

    public Logger(ILoggerFactory factory)
    {
        ThrowHelper.ThrowIfNull(factory);

        // 使用泛型实参 T 的类型全名作为日志类别
        // 如果是泛型类型，则不包含泛型参数类型
        // 如果是内嵌类型，则使用 . 号分割
        _logger = factory.CreateLogger(TypeNameHelper.GetTypeDisplayName(typeof(T), includeGenericParameters: false, nestedTypeDelimiter: '.'));
    }

    void ILogger.Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        _logger.Log(logLevel, eventId, state, exception, formatter);
    }

    bool ILogger.IsEnabled(LogLevel logLevel)
    {
        return _logger.IsEnabled(logLevel);
    }

    IDisposable? ILogger.BeginScope<TState>(TState state)
    {
        return _logger.BeginScope(state);
    }
}
```

- LoggerInformation  
```C#
// 日志信息
// 所有注册的 ILoggerProvider 和日志类别的组合对应一个 ILogger
internal readonly struct LoggerInformation
{
    public LoggerInformation(ILoggerProvider provider, string category) : this()
    {
        ProviderType = provider.GetType();
        // 利用 ILoggerProvider 创建对应的 ILogger
        Logger = provider.CreateLogger(category);
        Category = category;
        ExternalScope = provider is ISupportExternalScope;
    }
    
    // 由 ILoggerProvider 创建的 ILogger
    // ILogger 内部通过对应的日志事件源发送日志事件
    // 订阅者（观察者）收到日志事件后将其输出到相应的渠道
    public ILogger Logger { get; }

    // 日志类别
    public string Category { get; }

    // ILoggerProvider 具体类型
    public Type ProviderType { get; }

    // ILoggerProvider 是否实现了 ISupportExternalScope 接口
    // 实现了 ISupportExternalScope 接口就表明需要借助 IExternalScopeProvider 来提供日志范围的活动跟踪
    // 没有实现的代表 ILoggerProvider 自身可以提供日志范围的活动跟踪
    public bool ExternalScope { get; }
}
```

- MessageLogger  
```C#
// 消息日志
// 主要用来过滤日志
internal readonly struct MessageLogger
{
    // 匹配得到对应的 MinLevel 和 Filter
    public MessageLogger(ILogger logger, string? category, string? providerTypeFullName, LogLevel? minLevel, Func<string?, string?, LogLevel, bool>? filter)
    {
        Logger = logger;
        Category = category;
        ProviderTypeFullName = providerTypeFullName;
        MinLevel = minLevel;
        Filter = filter;
    }

    // 由 ILoggerProvider 创建的 ILogger
    public ILogger Logger { get; }

    // 日志类别
    public string? Category { get; }

    // ILoggerProvider 全名
    // 可以使用 ProviderAliasAttribute 特性配置对应的别名
    private string? ProviderTypeFullName { get; }

    // 通过 Category 和 ProviderTypeFullName 根据最优筛选逻辑得到的最优 LoggerFilterRule 中的 LogLevel 属性值
    public LogLevel? MinLevel { get; }

    // 通过 Category 和 ProviderTypeFullName 根据最优筛选逻辑得到的最优 LoggerFilterRule 中的 Filter 属性值
    public Func<string?, string?, LogLevel, bool>? Filter { get; }

    // 根据最低日志等级和过滤规则方法方法过滤发送的日志事件
    public bool IsEnabled(LogLevel level)
    {
        // 不满足最低日志级别直接返回 false
        if (MinLevel != null && level < MinLevel)
        {
            return false;
        }

        // 如果存在过滤方法则继续检查
        if (Filter != null)
        {
            return Filter(ProviderTypeFullName, Category, level);
        }

        return true;
    }
}
```

- ScopeLogger  
```C#
// 范围日志
// 如果 ILoggerProvider 实现了 ISupportExternalScope 接口就表明其自身不具有日志范围的活动跟踪
// 这时候就需要通过 IExternalScopeProvider 来提供日志范围的活动跟踪
internal readonly struct ScopeLogger
{
    public ScopeLogger(ILogger? logger, IExternalScopeProvider? externalScopeProvider)
    {
        // logger 和 externalScopeProvider 不能同时为 null
        Debug.Assert(logger != null || externalScopeProvider != null, "Logger can't be null when there isn't an ExternalScopeProvider");

        Logger = logger;
        ExternalScopeProvider = externalScopeProvider;
    }

    // 由 ILoggerProvider 创建的 ILogger
    public ILogger? Logger { get; }

    // 实现 IExternalScopeProvider 的范围提供者
    public IExternalScopeProvider? ExternalScopeProvider { get; }

    // 创建日志范围
    // 实现的核心就是创建当前日志范围并指向父日志范围形成一个单向链表（父范围 <- 当前范围），并利用 AsyncLocal<T> 保存当前范围，实现在不同线程间传递
    public IDisposable? CreateScope<TState>(TState state) where TState : notnull
    {
        if (ExternalScopeProvider != null)
        {
            return ExternalScopeProvider.Push(state);
        }

        Debug.Assert(Logger != null);
        return Logger.BeginScope<TState>(state);
    }
}
```

- LoggerFactoryOptions  
```C#
// 日志工厂选项
// 主要用来配置活动跟踪时的信息组织
public class LoggerFactoryOptions
{
    public LoggerFactoryOptions() { }

    // 活动跟踪选项
    // ActivityTrackingOptions 是一个带有位标志的枚举类型（主要用于针对 Activity 类型启动的活动跟踪）
    public ActivityTrackingOptions ActivityTrackingOptions { get; set; }
}
```

- LoggerFilterOptions  
```C#
// 日志过滤选项
public class LoggerFilterOptions
{
    public LoggerFilterOptions() { }

    // 是否启用日志范围的活动跟踪
    // 此开关决定是否会创建 ScopeLogger
    // 这是一个针对所有 ILoggerProvider 的全局配置
    public bool CaptureScopes { get; set; } = true;

    // 全局最小日志等级
    public LogLevel MinLevel { get; set; }

    // 日志过滤规则集合
    public IList<LoggerFilterRule> Rules => RulesInternal;

    internal List<LoggerFilterRule> RulesInternal { get; } = new List<LoggerFilterRule>();
}
```

- LoggerFilterRule  
```C#
public class LoggerFilterRule
{
    // 通过调用 ILoggingBuilder.AddConfiguration 方法从配置文件中得到的 providerName、categoryName、logLevel
    // 通过调用 ILoggingBuilder.AddFilter 方法配置得到的 providerName、categoryName、filter
    public LoggerFilterRule(string? providerName, string? categoryName, LogLevel? logLevel, Func<string?, string?, LogLevel, bool>? filter)
    {
        ProviderName = providerName;
        CategoryName = categoryName;
        LogLevel = logLevel;
        Filter = filter;
    }

    public string? ProviderName { get; }

    public string? CategoryName { get; }

    public LogLevel? LogLevel { get; }

    public Func<string?, string?, LogLevel, bool>? Filter { get; }

    public override string ToString()
    {
        return $"{nameof(ProviderName)}: '{ProviderName}', {nameof(CategoryName)}: '{CategoryName}', {nameof(LogLevel)}: '{LogLevel}', {nameof(Filter)}: '{Filter}'";
    }
}
```

- ILoggerFactory  
```C#
// Logger 工厂的抽象表示
public interface ILoggerFactory : IDisposable
{
    // 根据 categoryName 创建对应日志类别的 ILogger
    // 创建的 ILogger 只是提供应用程序发送日志事件的入口作用
    ILogger CreateLogger(string categoryName);

    // 添加 ILoggerProvider
    void AddProvider(ILoggerProvider provider);
}
```

- LoggerFactory  
```C#
// ILoggerFactory 的默认实现
public class LoggerFactory : ILoggerFactory
{
    // 缓存根据不同日志类别创建的 ILogger
    private readonly Dictionary<string, Logger> _loggers = new Dictionary<string, Logger>(StringComparer.Ordinal);
    // ILoggerPrivider 注册列表
    private readonly List<ProviderRegistration> _providerRegistrations = new List<ProviderRegistration>();
    // 同步锁
    private readonly object _sync = new object();
    // 是否执行过释放操作标志
    private volatile bool _disposed;
    // 用来取消通过 IOptionsMonitor<LoggerFilterOptions>.OnChange 方法注册的回调
    private IDisposable? _changeTokenRegistration;
    // 日志过滤选项
    private LoggerFilterOptions _filterOptions;
    // 全局的外部范围提供者
    private IExternalScopeProvider? _scopeProvider;
    // 日志工厂选项
    // 主要作用是配置活动跟踪选项
    private LoggerFactoryOptions _factoryOptions;

    public LoggerFactory() : this(Array.Empty<ILoggerProvider>())
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers) : this(providers, new StaticFilterOptionsMonitor(new LoggerFilterOptions()))
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers, LoggerFilterOptions filterOptions) 
        : this(providers, new StaticFilterOptionsMonitor(filterOptions))
    {
    }

    public LoggerFactory(IEnumerable<ILoggerProvider> providers, IOptionsMonitor<LoggerFilterOptions> filterOption) 
        : this(providers, filterOption, null)
    {
    }

    public LoggerFactory(
        IEnumerable<ILoggerProvider> providers, 
        IOptionsMonitor<LoggerFilterOptions> filterOption, 
        IOptions<LoggerFactoryOptions>? options) 
            : this(providers, filterOption, options, null)
    {
    }

    // 依赖注入框架会选取此为最优构造函数
    // 参数：
    // 1. 所有注册的 ILoggerProvider
    // 2. LoggerFilterOptions 选项的配置可能来源于文件，所以需要监控文件改变的 IOptionsMonitor<LoggerFilterOptions>
    // 3. 启用日志范围后需要记录哪些活动跟踪信息的 LoggerFactoryOptions 选项，由 IOptions<LoggerFactoryOptions> 提供
    // 4. 外部日志范围提供者 IExternalScopeProvider
    public LoggerFactory(
        IEnumerable<ILoggerProvider> providers, 
        IOptionsMonitor<LoggerFilterOptions> filterOption, 
        IOptions<LoggerFactoryOptions>? options = null, 
        IExternalScopeProvider? scopeProvider = null)
    {
        // 初始化全局默认的 IExternalScopeProvider
        _scopeProvider = scopeProvider;

        // 可能未注册 LoggerFactoryOptions 的选项配置
        _factoryOptions = options == null || options.Value == null ? new LoggerFactoryOptions() : options.Value;

        // 对除 None 以外的所有枚举按位或后取非
        const ActivityTrackingOptions ActivityTrackingOptionsMask = ~(ActivityTrackingOptions.SpanId | 
                                                                      ActivityTrackingOptions.TraceId | 
                                                                      ActivityTrackingOptions.ParentId | 
                                                                      ActivityTrackingOptions.TraceFlags | 
                                                                      ActivityTrackingOptions.TraceState | 
                                                                      ActivityTrackingOptions.Tags | 
                                                                      ActivityTrackingOptions.Baggage);

        // 如果和上面 ActivityTrackingOptionsMask 按位与操作后不为零，表明配置了未定义的枚举值，则抛出 ArgumentException
        if ((_factoryOptions.ActivityTrackingOptions & ActivityTrackingOptionsMask) != 0)
        {
            throw new ArgumentException(SR.Format(SR.InvalidActivityTrackingOptions, _factoryOptions.ActivityTrackingOptions), nameof(options));
        }
        // 遍历所有注册的 ILoggerPrivider，添加进注册中心
        foreach (ILoggerProvider provider in providers)
        {
            // 如果是实现了 ISupportExternalScope 接口的 ILoggerProvider
            // 则需要对其设置 IExternalScopeProvider 提供日志范围的活动跟踪
            AddProviderRegistration(provider, dispose: false);
        }
        
        // 监控日志过滤规则配置文件的改变
        // 在改变后重新获取 LoggerFilterOptions 并刷新应用过滤规则
        _changeTokenRegistration = filterOption.OnChange(RefreshFilters);
        // 初始化使用 IOptionsMonitor<LoggerFilterOptions> 的 CurrentValue（空字符串命名）获取选项
        // 刷新过滤规则
        RefreshFilters(filterOption.CurrentValue);
    }

    // 刷新过滤规则
    private void RefreshFilters(LoggerFilterOptions filterOptions)
    {
        lock (_sync)
        {
            // 更新 LoggerFilterOptions
            _filterOptions = filterOptions;
            foreach (KeyValuePair<string, Logger> registeredLogger in _loggers)
            {
                Logger logger = registeredLogger.Value;
                // 应用新的过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);
            }
        }
    }

    // 实现 ILoggerFactory
    // 根据 categoryName 日志类别创建获取 ILogger
    public ILogger CreateLogger(string categoryName)
    {
        if (CheckDisposed())
        {
            throw new ObjectDisposedException(nameof(LoggerFactory));
        }

        // 在并发情况下创建对应日志类别的 ILogger 和应用过滤规则需要同步完成
        lock (_sync)
        {
            if (!_loggers.TryGetValue(categoryName, out Logger? logger))
            {
                // 基于日志类别创建 ILogger
                logger = new Logger(CreateLoggers(categoryName));

                // 应用过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);

                // 添加新的日志类别和对应的 ILogger
                _loggers[categoryName] = logger;
            }

            return logger;
        }
    }

    // 实现 ILoggerFactory
    // 添加新的 ILoggerProvider
    public void AddProvider(ILoggerProvider provider)
    {
        if (CheckDisposed())
        {
            throw new ObjectDisposedException(nameof(LoggerFactory));
        }

        ThrowHelper.ThrowIfNull(provider);

        // 在并发情况下 ILogger 的创建需要同步完成
        lock (_sync)
        {
            // 添加进注册中心
            AddProviderRegistration(provider, dispose: true);
            // 遍历所有已经创建的 Logger
            // 利用新添加的 ILoggerProvider 创建新的 LoggerInformation，并应用过滤规则
            foreach (KeyValuePair<string, Logger> existingLogger in _loggers)
            {
                Logger logger = existingLogger.Value;
                LoggerInformation[] loggerInformation = logger.Loggers;

                int newLoggerIndex = loggerInformation.Length;
                // 扩容数组
                Array.Resize(ref loggerInformation, loggerInformation.Length + 1);
                // 根据 ILoggerProvider 和日志类别的组合创建新的 LoggerInformation，并添加到添加到末尾
                loggerInformation[newLoggerIndex] = new LoggerInformation(provider, existingLogger.Key);

                logger.Loggers = loggerInformation;
                // 应用过滤规则
                (logger.MessageLoggers, logger.ScopeLoggers) = ApplyFilters(logger.Loggers);
            }
        }
    }

    // 将 ILoggerProvider 添加进列表
    // 便于维护和释放
    private void AddProviderRegistration(ILoggerProvider provider, bool dispose)
    {
        _providerRegistrations.Add(new ProviderRegistration
        {
            Provider = provider,
            ShouldDispose = dispose
        });

        // 如果 ILoggerProvider 实现了 ISupportExternalScope 
        // 就为 ILoggerProvider 添加 LoggerFactoryScopeProvider（LoggerFactoryScopeProvider 实现了 IExternalScopeProvider）
        // 利用 IExternalScopeProvider 为 ILoggerProvider 提供基于范围的活动跟踪
        if (provider is ISupportExternalScope supportsExternalScope)
        {
            // 利用 ActivityTrackingOptions 创建 LoggerFactoryScopeProvider
            // 作为全局默认 IExternalScopeProvider
            _scopeProvider ??= new LoggerFactoryScopeProvider(_factoryOptions.ActivityTrackingOptions);

            supportsExternalScope.SetScopeProvider(_scopeProvider);
        }
    }

    // 利用 categoryName 和所有已注册的 ILoggerProvider 创建 LoggerInformation 数组
    private LoggerInformation[] CreateLoggers(string categoryName)
    {
        var loggers = new LoggerInformation[_providerRegistrations.Count];
        for (int i = 0; i < _providerRegistrations.Count; i++)
        {
            loggers[i] = new LoggerInformation(_providerRegistrations[i].Provider, categoryName);
        }
        return loggers;
    }

    // 应用过滤规则
    private (MessageLogger[] MessageLoggers, ScopeLogger[]? ScopeLoggers) ApplyFilters(LoggerInformation[] loggers)
    {
        var messageLoggers = new List<MessageLogger>();
        // 根据 LoggerFilterOptions.CaptureScopes 属性决定是否启用日志范围的活动跟踪，这个属性默认值为 true
        // 启用情况下才需要创建 ScopeLogger 集合
        List<ScopeLogger>? scopeLoggers = _filterOptions.CaptureScopes ? new List<ScopeLogger>() : null;

        foreach (LoggerInformation loggerInformation in loggers)
        {
            // 选择最优的 LoggerFilterRule
            // 匹配规则：
            // 1. 具体的针对 ILoggerProvider 名称（类型全名或别名）的规则优先级高于默认规则
            // 2. 日志类别基于前缀匹配规则（对于 Foo.Bar.Baz 的日志类别，配置中 Foo.Bar 的规则比 Foo 的规则优先级更高）
            // 3. 有多个优先级相同的规则选择最后一个
            // 4. 以上规则没有匹配到则使用全局最低日志等级 LoggerFilterOptions.MinLevel
            LoggerRuleSelector.Select(_filterOptions,
                loggerInformation.ProviderType,
                loggerInformation.Category,
                out LogLevel? minLevel,
                out Func<string?, string?, LogLevel, bool>? filter);

            // 无效的最低日志等级
            if (minLevel is not null and > LogLevel.Critical)
            {
                continue;
            }

            messageLoggers.Add(new MessageLogger(loggerInformation.Logger, loggerInformation.Category, loggerInformation.ProviderType.FullName, minLevel, filter));

            // 不需要由 IExternalScopeProvider 提供日志范围的活动跟踪
            // 直接使用 ILoggerProvider 创建的 ILogger 构建 ScopeLogger
            if (!loggerInformation.ExternalScope)
            {
                scopeLoggers?.Add(new ScopeLogger(logger: loggerInformation.Logger, externalScopeProvider: null));
            }
        }

        // 是否有提供默认的 IExternalScopeProvider
        // 如果有表明存在实现了 ISupportExternalScope 接口的 IServiceProvider 被注册，需要由 IExternalScopeProvider 来提供日志范围的活动跟踪
        // 一个日志类别下只需要一个 ScopeLogger 保存 IExternalScopeProvider 即可
        // 其实全局也只有一个 IExternalScopeProvider 实例
        if (_scopeProvider != null)
        {
            scopeLoggers?.Add(new ScopeLogger(logger: null, externalScopeProvider: _scopeProvider));
        }

        return (messageLoggers.ToArray(), scopeLoggers?.ToArray());
    }

    // 创建 ILoggerFactory 的静态工具方法
    // 用来创建一个独立的 ILoggerFactory（DisposingLoggerFactory）
    // DisposingLoggerFactory 实际是对 ServiceProvider 和 LoggerFactory 的包装类型
    // 并在内部实现 IDisposable 接口用来释放 ServiceProvider 和 LoggerFactory
    public static ILoggerFactory Create(Action<ILoggingBuilder> configure)
    {
        var serviceCollection = new ServiceCollection();
        serviceCollection.AddLogging(configure);
        ServiceProvider serviceProvider = serviceCollection.BuildServiceProvider();
        ILoggerFactory loggerFactory = serviceProvider.GetRequiredService<ILoggerFactory>();
        return new DisposingLoggerFactory(loggerFactory, serviceProvider);
    }

    // 检查是否已经执行过释放
    protected virtual bool CheckDisposed() => _disposed;

    // 释放
    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;

            _changeTokenRegistration?.Dispose();

            foreach (ProviderRegistration registration in _providerRegistrations)
            {
                try
                {
                    if (registration.ShouldDispose)
                    {
                        registration.Provider.Dispose();
                    }
                }
                catch
                {

                }
            }
        }
    }

    private struct ProviderRegistration
    {
        public ILoggerProvider Provider;
        public bool ShouldDispose;
    }
}
```

- ILoggerProvider  
```C#
// LoggerProvider 的抽象表示
public interface ILoggerProvider : IDisposable
{
    // 根据 categoryName 创建对应日志类别的 ILogger
    // 和 ILoggerFactory 中的 CreateLogger 方法不同
    // 此处创建是针对具体日志输出渠道的 ILogger
    ILogger CreateLogger(string categoryName);
}
```

- IExternalScopeProvider  
```C#
public interface IExternalScopeProvider
{
    // 遍历从根范围到当前范围，使用范围日志的内容载荷 Scope.State 发出 callback 回调
    void ForEachScope<TState>(Action<object?, TState> callback, TState state);

    // 新建一个范围结构（可以理解为压栈操作）
    // 核心是创建一个新的范围结构，并将当前范围结构保存到新范围结构的 Parent 属性中，作为父范围
    // 将新创建的范围结构作为当前范围存储到 AsyncLocal<> 中
    IDisposable Push(object? state);
}
```

- LoggerFactoryScopeProvider  
```C#
// IExternalScopeProvider 的默认实现
// 用来管理范围的入栈和出栈
internal sealed class LoggerFactoryScopeProvider : IExternalScopeProvider
{
    // 此处可以使用 static readonly
    // 类似 Activity 类中的 s_current 一样
    // private static readonly AsyncLocal<Activity?> s_current = new AsyncLocal<Activity?>();
    private readonly AsyncLocal<Scope?> _currentScope = new AsyncLocal<Scope?>();
    private readonly ActivityTrackingOptions _activityTrackingOption;

    // 遍历从根范围到当前范围
    public void ForEachScope<TState>(Action<object?, TState> callback, TState state)
    {
        void Report(Scope? current)
        {
            if (current == null)
            {
                return;
            }
            Report(current.Parent);
            callback(current.State, state);
        }

        if (_activityTrackingOption != ActivityTrackingOptions.None)
        {
            Activity? activity = Activity.Current;
            // 如果 activity != null，则表明是通过调用 Activity.Start 方法开始日志范围
            if (activity != null)
            {
                const string propertyKey = "__ActivityLogScope__";

                ActivityLogScope? activityLogScope = activity.GetCustomProperty(propertyKey) as ActivityLogScope;
                if (activityLogScope == null)
                {
                    activityLogScope = new ActivityLogScope(activity, _activityTrackingOption);
                    activity.SetCustomProperty(propertyKey, activityLogScope);
                }

                // 最终通过调用 ActivityLogScope.ToString 方法格式化日志范围消息
                // 具体的日志范围消息内容根据配置的 ActivityTrackingOptions 枚举决定
                // 完整的日志范围消息内容如下：
                // SpanId:xxxxxx, TraceId:xxxxxx, ParentId:xxxxxx, TraceState:xxxxxx, TraceFlags:xxxxxx
                callback(activityLogScope, state);

                if ((_activityTrackingOption & ActivityTrackingOptions.Tags) != 0
                    && activity.TagObjects.GetEnumerator().MoveNext())
                {
                    callback(activity.TagObjects, state);
                }

                if ((_activityTrackingOption & ActivityTrackingOptions.Baggage) != 0)
                {
                    IEnumerable<KeyValuePair<string, string?>> baggage = activity.Baggage;
                    if (baggage.GetEnumerator().MoveNext())
                    {
                        ActivityBaggageLogScopeWrapper scope = GetOrCreateActivityBaggageLogScopeWrapper(activity, baggage);
                        callback(scope, state);
                    }
                }
            }
        }

        // 如果使用 Activity.Start 方法开始日志范围，则 _currentScope.Value 就等于 null（因为开始日志范围不是通过调用 ILogger.BeginScope 方法）
        // Report 方法将直接返回
        Report(_currentScope.Value);
    }

    // 新建一个范围压栈
    public IDisposable Push(object? state)
    {
        // 当前范围作为父范围
        Scope? parent = _currentScope.Value;
        // 新建一个范围
        var newScope = new Scope(this, state, parent);
        // 将新建的范围保存到 AsyncLocal<> 中，作为当前范围
        _currentScope.Value = newScope;

        return newScope;
    }
}
```

- Scope  
```C#
// 表示日志范围的数据结构
// 实现 IDisposable.Dispose 方法（用来完成日志范围的出栈）
private sealed class Scope : IDisposable
{
    // IExternalScopeProvider
    private readonly LoggerFactoryScopeProvider _provider;
    private bool _isDisposed;

    internal Scope(LoggerFactoryScopeProvider provider, object? state, Scope? parent)
    {
        _provider = provider;
        State = state;
        Parent = parent;
    }

    // 父 Scope
    public Scope? Parent { get; }

    public object? State { get; }

    public override string? ToString()
    {
        return State?.ToString();
    }

    // 将父范围保存到 AsyncLocal<> 中，实现当前范围的出栈
    public void Dispose()
    {
        if (!_isDisposed)
        {
            _provider._currentScope.Value = Parent;
            _isDisposed = true;
        }
    }
}
```

- Activity  
```C#
// 用于活动跟踪
public partial class Activity : IDisposable
{
    // 此处使用 static readonly 是因为 AsyncLocal<>.Value 的值实际是保存在类型为 IAsyncLocalValueMap 的 ExecutionContext.m_localValues 中的
    // 方法是通过将 AsyncLocal<> 实例自己作为 Key 从 IAsyncLocalValueMap 中读取和保存值
    // 由于 ExecutionContext 和 IAsyncLocalValueMap 在使用时都是不可变的
    // 所以在不同线程中通过 AsyncLocal<> 实例自己作为 Key 来存储新值时都会创建新的 ExecutionContext 和 IAsyncLocalValueMap 实例
    // 其中 IAsyncLocalValueMap 实例的创建又会根据保存值得数量大小使用不同的实现类型
    private static readonly AsyncLocal<Activity?> s_current = new AsyncLocal<Activity?>();
    // 默认会有一个空字符串命名的 ActivitySource 被创建
    private static readonly ActivitySource s_defaultSource = new ActivitySource(string.Empty);

    public Activity(string operationName)
    {
        Source = s_defaultSource;
        // 默认设置采样所有数据
        IsAllDataRequested = true;

        if (string.IsNullOrEmpty(operationName))
        {
            NotifyError(new ArgumentException(SR.OperationNameInvalid));
        }

        OperationName = operationName ?? string.Empty;
    }

    // 操作名称
    public string OperationName { get; }

    // 父 Activity
    public Activity? Parent { get; private set; }

    // 从 AsyncLocal<>.Value 读取和保存 Activity
    public static Activity? Current
    {
        get { return s_current.Value; }
        set
        {
            if (ValidateSetCurrent(value))
            {
                SetCurrent(value);
            }
        }
    }

    // 是否通过外部设置得到 TraceId
    // 如果是，表明是通过调用 SetParentId 方法或通过设置 Parent 属性得到的
    // 否则将由自身生成
    private bool W3CIdFlagsSet
    {
        get => (_w3CIdFlags & ActivityTraceFlagsIsSet) != 0;
    }

    // 通过重新设置 AsyncLocal<>.Value 的值，在逻辑上将新的 Activity 作为活动跟踪栈顶
    private static void SetCurrent(Activity? activity)
    {
        EventHandler<ActivityChangedEventArgs>? handler = CurrentChanged;
        if (handler is null)
        {
            s_current.Value = activity;
        }
        else
        {
            Activity? previous = s_current.Value;
            s_current.Value = activity;
            handler.Invoke(null, new ActivityChangedEventArgs(previous, activity));
        }
    }

    // 设置 ParentId
    // 在分布式应用中，通过从请求头中取出 W3C 格式的父操作 Id
    // 实现分布式链路跟踪
    public Activity SetParentId(string parentId)
    {
        if (Parent != null)
        {
            NotifyError(new InvalidOperationException(SR.SetParentIdOnActivityWithParent));
        }
        else if (ParentId != null || _parentSpanId != null)
        {
            NotifyError(new InvalidOperationException(SR.ParentIdAlreadySet));
        }
        else if (string.IsNullOrEmpty(parentId))
        {
            NotifyError(new ArgumentException(SR.ParentIdInvalid));
        }
        else
        {
            _parentId = parentId;
        }
        return this;
    }

    // 启动 Activity
    // 此操作将实际生成 _id 与 _spanId 的值
    // 并且会将保存在 AsyncLocal<>.Value 中的当前 Activity 作为父 Activity
    // 而自己作为 AsyncLocal<>.Value 的当前值
    public Activity Start()
    {
        // 如果 _id 或 _spanId 存在，表明已经调用过 Start 方法，则抛出 InvalidOperationException
        // 一个 Activity 不能重复调用 Start 方法
        if (_id != null || _spanId != null)
        {
            NotifyError(new InvalidOperationException(SR.ActivityStartAlreadyStarted));
        }
        else
        {
            // 从 AsyncLocal<>.Value 中读取 Activity 作为前一个 Activity 保存在 _previousActiveActivity 中
            _previousActiveActivity = Current;
            if (_parentId == null && _parentSpanId is null)
            {
                if (_previousActiveActivity != null)
                {
                    // 将 _previousActiveActivity 赋给 Parent
                    Parent = _previousActiveActivity;
                }
            }

            if (StartTimeUtc == default)
                StartTimeUtc = GetUtcNow();

            // 如果 IdFormat 为 ActivityIdFormat.Unknown，则根据规则设置
            if (IdFormat == ActivityIdFormat.Unknown)
            {
                IdFormat =
                    ForceDefaultIdFormat ? DefaultIdFormat :
                    Parent != null ? Parent.IdFormat :
                    _parentSpanId != null ? ActivityIdFormat.W3C :
                    _parentId == null ? DefaultIdFormat :
                    IsW3CId(_parentId) ? ActivityIdFormat.W3C :
                    ActivityIdFormat.Hierarchical;
            }

            if (IdFormat == ActivityIdFormat.W3C)
                GenerateW3CId();
            else
                _id = GenerateHierarchicalId();

            // 将自己保存到 AsyncLocal<>.Value 中
            SetCurrent(this);

            // 触发 ActivityListener.ActivityStarted 回调
            Source.NotifyActivityStart(this);
        }
        return this;
    }

    // 停止 Activity
    public void Stop()
    {
        // 如果 _id 或 _spanId 不存在，表明没有调用过 Start 方法，则抛出 InvalidOperationException
        // 一个 Activity 没有启动不能调用 Stop 方法
        if (_id == null && _spanId == null)
        {
            NotifyError(new InvalidOperationException(SR.ActivityNotStarted));
            return;
        }

        if (!IsStopped)
        {
            IsStopped = true;

            if (Duration == TimeSpan.Zero)
            {
                SetEndTime(GetUtcNow());
            }

            Source.NotifyActivityStop(this);
            // 将前一个 Activity 重新赋给 AsyncLocal<>.Value
            SetCurrent(_previousActiveActivity);
        }
    }

    // 实现 IDisposable
    // 通过调用 Stop 将 Parent 保存的 Activity 重新赋给 AsyncLocal<>.Value
    public void Dispose()
    {
        if (!IsStopped)
        {
            Stop();
        }

        Dispose(true);
        GC.SuppressFinalize(this);
    }

    // 创建 Activity 的静态方法
    internal static Activity Create(ActivitySource source, string name, ActivityKind kind, string? parentId, ActivityContext parentContext,
                                    IEnumerable<KeyValuePair<string, object?>>? tags, IEnumerable<ActivityLink>? links, DateTimeOffset startTime,
                                    ActivityTagsCollection? samplerTags, ActivitySamplingResult request, bool startIt, ActivityIdFormat idFormat, string? traceState)
    {
        Activity activity = new Activity(name);

        activity.Source = source;
        activity.Kind = kind;
        activity.IdFormat = idFormat;
        activity._traceState = traceState;

        if (links != null)
        {
            using (IEnumerator<ActivityLink> enumerator = links.GetEnumerator())
            {
                if (enumerator.MoveNext())
                {
                    activity._links = new DiagLinkedList<ActivityLink>(enumerator);
                }
            }
        }

        if (tags != null)
        {
            using (IEnumerator<KeyValuePair<string, object?>> enumerator = tags.GetEnumerator())
            {
                if (enumerator.MoveNext())
                {
                    activity._tags = new TagsLinkedList(enumerator);
                }
            }
        }

        if (samplerTags != null)
        {
            if (activity._tags == null)
            {
                activity._tags = new TagsLinkedList(samplerTags!);
            }
            else
            {
                activity._tags.Add(samplerTags!);
            }
        }

        if (parentId != null)
        {
            activity._parentId = parentId;
        }
        else if (parentContext != default)
        {
            activity._traceId = parentContext.TraceId.ToString();

            if (parentContext.SpanId != default)
            {
                activity._parentSpanId = parentContext.SpanId.ToString();
            }

            activity.ActivityTraceFlags = parentContext.TraceFlags;
            activity._parentTraceFlags = (byte) parentContext.TraceFlags;
            activity.HasRemoteParent = parentContext.IsRemote;
        }

        // 根据采样结果设置是否采样所有数据
        activity.IsAllDataRequested = request == ActivitySamplingResult.AllData || request == ActivitySamplingResult.AllDataAndRecorded;

        if (request == ActivitySamplingResult.AllDataAndRecorded)
        {
            activity.ActivityTraceFlags |= ActivityTraceFlags.Recorded;
        }

        if (startTime != default)
        {
            activity.StartTimeUtc = startTime.UtcDateTime;
        }

        if (startIt)
        {
            // 启动 Activity
            activity.Start();
        }

        return activity;
    }
}
```

- ActivitySource  
```C#
// 表示 Activity 创建源
public sealed class ActivitySource : IDisposable
{
    // 启动 Activity
    public Activity? StartActivity(string name = "", ActivityKind kind = ActivityKind.Internal)
        => CreateActivity(name, kind, default, null, null, null, default);

    // 启动 Activity
    public Activity? StartActivity(string name, ActivityKind kind, ActivityContext parentContext, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, DateTimeOffset startTime = default)
        => CreateActivity(name, kind, parentContext, null, tags, links, startTime);
    
    // 启动 Activity
    public Activity? StartActivity(string name, ActivityKind kind, string? parentId, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, DateTimeOffset startTime = default)
        => CreateActivity(name, kind, default, parentId, tags, links, startTime);
    
    // 启动 Activity
    public Activity? StartActivity(ActivityKind kind, ActivityContext parentContext = default, IEnumerable<KeyValuePair<string, object?>>? tags = null, IEnumerable<ActivityLink>? links = null, DateTimeOffset startTime = default, string name = "")
        => CreateActivity(name, kind, parentContext, null, tags, links, startTime);

    // 创建并启动 Activity
    private Activity? CreateActivity(string name, ActivityKind kind, ActivityContext context, string? parentId, IEnumerable<KeyValuePair<string, object?>>? tags, IEnumerable<ActivityLink>? links, DateTimeOffset startTime, bool startIt = true, ActivityIdFormat idFormat = ActivityIdFormat.Unknown)
    {
        SynchronizedList<ActivityListener>? listeners = _listeners;
        // 如果没有注册的 ActivityListener 直接返回
        if (listeners == null || listeners.Count == 0)
        {
            return null;
        }

        Activity? activity = null;
        ActivityTagsCollection? samplerTags;
        string? traceState;

        // 默认采样结果为 ActivitySamplingResult.None
        ActivitySamplingResult samplingResult = ActivitySamplingResult.None;

        if (parentId != null)
        {
            ActivityCreationOptions<string> aco = default;
            ActivityCreationOptions<ActivityContext> acoContext = default;

            aco = new ActivityCreationOptions<string>(this, name, parentId, kind, tags, links, idFormat);
            if (aco.IdFormat == ActivityIdFormat.W3C)
            {
                acoContext = new ActivityCreationOptions<ActivityContext>(this, name, aco.GetContext(), kind, tags, links, ActivityIdFormat.W3C);
            }

            listeners.EnumWithFunc(
                (ActivityListener listener, ref ActivityCreationOptions<string> data, ref ActivitySamplingResult result, ref ActivityCreationOptions<ActivityContext> dataWithContext) => 
                {
                    SampleActivity<string>? sampleUsingParentId = listener.SampleUsingParentId;
                    if (sampleUsingParentId != null)
                    {
                        ActivitySamplingResult sr = sampleUsingParentId(ref data);
                        dataWithContext.SetTraceState(data.TraceState);

                        if (sr > result)
                        {
                            result = sr;
                        }
                    }
                    else if (data.IdFormat == ActivityIdFormat.W3C)
                    {
                        SampleActivity<ActivityContext>? sample = listener.Sample;
                        if (sample != null)
                        {
                            // 触发 ActivityListener.Sample 回调
                            ActivitySamplingResult sr = sample(ref dataWithContext);
                            data.SetTraceState(dataWithContext.TraceState);

                            if (sr > result)
                            {
                                result = sr;
                            }
                        }
                    }
                }, ref aco, ref samplingResult, ref acoContext);

            if (context == default)
            {
                if (aco.GetContext() != default)
                {
                    context = aco.GetContext();
                    parentId = null;
                }
                else if (acoContext.GetContext() != default)
                {
                    context = acoContext.GetContext();
                    parentId = null;
                }
            }

            samplerTags = aco.GetSamplingTags();
            ActivityTagsCollection? atc = acoContext.GetSamplingTags();
            if (atc != null)
            {
                if (samplerTags == null)
                {
                    samplerTags = atc;
                }
                else
                {
                    foreach (KeyValuePair<string, object?> tag in atc)
                    {
                        samplerTags.Add(tag);
                    }
                }
            }

            idFormat = aco.IdFormat;
            traceState = aco.TraceState;
        }
        else
        {
            bool useCurrentActivityContext = context == default && Activity.Current != null;
            var aco = new ActivityCreationOptions<ActivityContext>(this, name, useCurrentActivityContext ? Activity.Current!.Context : context, kind, tags, links, idFormat);
            listeners.EnumWithFunc(
                (ActivityListener listener, ref ActivityCreationOptions<ActivityContext> data, ref ActivitySamplingResult result, ref ActivityCreationOptions<ActivityContext> unused) => 
                {
                    SampleActivity<ActivityContext>? sample = listener.Sample;
                    if (sample != null)
                    {
                        // 触发 ActivityListener.Sample 回调
                        ActivitySamplingResult dr = sample(ref data);
                        if (dr > result)
                        {
                            result = dr;
                        }
                    }
                }, ref aco, ref samplingResult, ref aco);

            if (!useCurrentActivityContext)
            {
                context = aco.GetContext();
            }

            samplerTags = aco.GetSamplingTags();
            idFormat = aco.IdFormat;
            traceState = aco.TraceState;
        }

        // 采样结果不为 ActivitySamplingResult.None，则创建并启动 Activity
        if (samplingResult != ActivitySamplingResult.None)
        {   
            // 创建并启动 Activity
            activity = Activity.Create(this, name, kind, parentId, context, tags, links, startTime, samplerTags, samplingResult, startIt, idFormat, traceState);
        }

        return activity;
    }
}
```

- ActivityListener  
```C#
public delegate ActivitySamplingResult SampleActivity<T>(ref ActivityCreationOptions<T> options);

// ActivitySource 的监听器
// 通过 ActivitySource.AddActivityListener 方法全局注册
// 通过调用 ShouldListenTo 的 Func<ActivitySource, bool> 委托来决定与具体的 ActivitySource 建立绑定监听
public sealed class ActivityListener : IDisposable
{ 
    public ActivityListener()
    {
    }

    // 被监听的 ActivitySource 创建的 Activity 执行 Start 方法后的回调
    public Action<Activity>? ActivityStarted { get; set; }

    // 被监听的 ActivitySource 创建的 Activity 执行 Stop 方法后的回调
    public Action<Activity>? ActivityStopped { get; set; }

    // 创建 ActivitySource 时执行的绑定监听
    // 如果调用 ShouldListenTo 返回 true，则将绑定并监听对应的 ActivitySource
    public Func<ActivitySource, bool>? ShouldListenTo { get; set; }

    // 被监听的 ActivitySource 创建 Activity 前执行的采样回调
    // 如果调用 Sample 返回 ActivitySamplingResult.None，则 ActivitySource 最终不会创建 Activity
    public SampleActivity<ActivityContext>? Sample { get; set; }

    // 将自己与监听的 ActivitySource 解除绑定
    public void Dispose() => ActivitySource.DetachListener(this);
}
```

- LoggerMessage  
```C#
// 提供基于占位符的日志消息模板方法
// 避免消息模板的重复解析
public static class LoggerMessage
{
    // 利用模板字符串得到发送日志事件消息的委托
    // 最多支持 6 个日志荷载类型
    // formateString 支持 {数字} 和 {文本} 占位符
    public static Action<ILogger, T1, T2, T3, T4, T5, T6, Exception?> Define<T1, T2, T3, T4, T5, T6>(
        LogLevel logLevel, EventId eventId, string formatString, LogDefineOptions? options)
    {
        // 根据消息模板字符串解析得到格式化器
        // 不管是使用 {数字} 或 {文本} 占位符，内部最终会转换为 string.Format 方法所支持的以参数索引形式的格式化字符串
        LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, expectedNamedParameterCount: 6);

        // 编译器会根据闭包变量 formatter、logLevel、eventId 和泛型参数创建内部匿名泛型类型
        // 避免重复解析的关键就是通过编译时生成的内部匿名泛型类型和对应 Log 的实例方法
        // 在运行时将闭包变量 formatter、logLevel、eventId 保存到对应的字段上，并利用对应 Log 的实例方法创建 Action 委托
        void Log(ILogger logger, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, Exception? exception)
        {
            logger.Log(logLevel, eventId, new LogValues<T1, T2, T3, T4, T5, T6>(formatter, arg1, arg2, arg3, arg4, arg5, arg6), exception, LogValues<T1, T2, T3, T4, T5, T6>.Callback);
        }

        // 是否跳过 IsEnable 检查
        if (options != null && options.SkipEnabledCheck)
        {
            return Log;
        }

        // 需要执行 IsEnable 检查
        // 确定是否至少有一个由 ILoggerProvider 创建的 ILogger 可以发送日志事件
        return (logger, arg1, arg2, arg3, arg4, arg5, arg6, exception) =>
        {
            if (logger.IsEnabled(logLevel))
            {
                Log(logger, arg1, arg2, arg3, arg4, arg5, arg6, exception);
            }
        };
    }

    // 利用模板字符串得到开始日志范围消息的委托
    // 最多支持 6 个日志荷载类型
    // formateString 支持 {数字} 和 {文本} 占位符
    public static Func<ILogger, T1, T2, T3, T4, T5, T6, IDisposable?> DefineScope<T1, T2, T3, T4, T5, T6>(string formatString)
    {
        LogValuesFormatter formatter = CreateLogValuesFormatter(formatString, expectedNamedParameterCount: 6);

        return (logger, arg1, arg2, arg3, arg4, arg5, arg6) => logger.BeginScope(new LogValues<T1, T2, T3, T4, T5, T6>(formatter, arg1, arg2, arg3, arg4, arg5, arg6));
    }

    // 记录日志事件的荷载
    // 利用格式化器对日志事件消息进行格式化输出
    private readonly struct LogValues<T0, T1, T2, T3, T4, T5> : IReadOnlyList<KeyValuePair<string, object?>>
    {
        // 消息格式化委托
        // 对消息进行格式化输出
        public static readonly Func<LogValues<T0, T1, T2, T3, T4, T5>, Exception?, string> Callback = (state, exception) => state.ToString();

        private readonly LogValuesFormatter _formatter;
        private readonly T0 _value0;
        private readonly T1 _value1;
        private readonly T2 _value2;
        private readonly T3 _value3;
        private readonly T4 _value4;
        private readonly T5 _value5;

        public int Count => 7;

        public KeyValuePair<string, object?> this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[0], _value0);
                    case 1:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[1], _value1);
                    case 2:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[2], _value2);
                    case 3:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[3], _value3);
                    case 4:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[4], _value4);
                    case 5:
                        return new KeyValuePair<string, object?>(_formatter.ValueNames[5], _value5);
                    case 6:
                        return new KeyValuePair<string, object?>("{OriginalFormat}", _formatter.OriginalFormat);
                    default:
                        throw new IndexOutOfRangeException(nameof(index));
                }
            }
        }

        public LogValues(LogValuesFormatter formatter, T0 value0, T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)
        {
            _formatter = formatter;
            _value0 = value0;
            _value1 = value1;
            _value2 = value2;
            _value3 = value3;
            _value4 = value4;
            _value5 = value5;
        }

        // 输出日志事件消息的参数
        private object?[] ToArray() => new object?[] { _value0, _value1, _value2, _value3, _value4, _value5 };

        // 格式化器根据解析得到的格式化字符串利用传入的参数输出格式化消息
        public override string ToString() => _formatter.FormatWithOverwrite(ToArray());

        public IEnumerator<KeyValuePair<string, object?>> GetEnumerator()
        {
            for (int i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
}
```

## 依赖注入

- LoggingServiceCollectionExtensions  
```C#
// 提供日志核心服务注册的扩展方法
public static class LoggingServiceCollectionExtensions
{
    public static IServiceCollection AddLogging(this IServiceCollection services)
    {
        return AddLogging(services, builder => { });
    }

    public static IServiceCollection AddLogging(this IServiceCollection services, Action<ILoggingBuilder> configure)
    {
        ThrowHelper.ThrowIfNull(services);

        // 注册选项核心服务
        services.AddOptions();

        // 注册日志工厂
        services.TryAdd(ServiceDescriptor.Singleton<ILoggerFactory, LoggerFactory>());
        // 注册 ILogger<>
        services.TryAdd(ServiceDescriptor.Singleton(typeof(ILogger<>), typeof(Logger<>)));

        // 注册默认最低日志等级的选项配置
        // 全局最低日志等级为 LogLevel.Information
        services.TryAddEnumerable(ServiceDescriptor.Singleton<IConfigureOptions<LoggerFilterOptions>>(
            new DefaultLoggerLevelConfigureOptions(LogLevel.Information)));

        // 创建 LoggingBuilder 并调用 Action<ILoggingBuilder> 配置日志
        configure(new LoggingBuilder(services));
        return services;
    }
}
```

- DefaultLoggerLevelConfigureOptions  
```C#
internal sealed class DefaultLoggerLevelConfigureOptions : ConfigureOptions<LoggerFilterOptions>
{
    public DefaultLoggerLevelConfigureOptions(LogLevel level) : base(options => options.MinLevel = level)
    {
    }
}
```

- LoggerFilterConfigureOptions  
```C#
// LoggerFilterOptions 的选项配置
internal sealed class LoggerFilterConfigureOptions : IConfigureOptions<LoggerFilterOptions>
{
    private const string LogLevelKey = "LogLevel";
    private const string DefaultCategory = "Default";
    private readonly IConfiguration _configuration;

    public LoggerFilterConfigureOptions(IConfiguration configuration)
    {
        _configuration = configuration;
    }

    public void Configure(LoggerFilterOptions options)
    {
        LoadDefaultConfigValues(options);
    }

    private void LoadDefaultConfigValues(LoggerFilterOptions options)
    {
        if (_configuration == null)
        {
            return;
        }

        // 解析配置
        // 是否配置捕获活动跟踪
        options.CaptureScopes = GetCaptureScopesValue(options);

        // 遍历子配置节
        foreach (IConfigurationSection configurationSection in _configuration.GetChildren())
        {
            if (configurationSection.Key.Equals(LogLevelKey, StringComparison.OrdinalIgnoreCase))
            {
                // 如果是 'LogLevel' 子配置节
                // 表明是不属于任何 LoggerProvider 类型的默认配置节
                LoadRules(options, configurationSection, null);
            }
            else
            {
                // 否则
                // 属于特定 LoggerProvider 类型的配置节
                // 尝试得到特定配置节下的 'LogLevel' 子配置节
                IConfigurationSection logLevelSection = configurationSection.GetSection(LogLevelKey);
                // 此处判断 null 没有意义，因为调用 IConfiguration.GetSection 方法肯定会返回一个 IConfigurationSection 实例，不管配置节是否存在
                // 应该改为调用 IConfigurationSection.Exists 扩展方法判断
                if (logLevelSection != null)
                {
                    // 将特定 LoggerProvider 类型的配置节名称作为 LoggerFilterRule.ProviderName
                    string logger = configurationSection.Key;
                    LoadRules(options, logLevelSection, logger);
                }
            }
        }

        // 解析 'CaptureScopes' 子配置节
        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode",
            Justification = "IConfiguration.GetValue is safe when T is a bool.")]
        bool GetCaptureScopesValue(LoggerFilterOptions options) => _configuration.GetValue(nameof(options.CaptureScopes), options.CaptureScopes);
    }

    // 加载规则
    private static void LoadRules(LoggerFilterOptions options, IConfigurationSection configurationSection, string? logger)
    {
        // 枚举 'LogLevel' 配置节下的所有配置节（包含子、孙配置节）
        // 配置节路径使用不包含 'LogLevel' 的相对路径
        foreach (System.Collections.Generic.KeyValuePair<string, string?> section in configurationSection.AsEnumerable(true))
        {
            // 尝试将叶配置节的字符串值转换为 LogLevel 类型的值
            if (TryGetSwitch(section.Value, out LogLevel level))
            {
                // 配置节名称作为 LoggerFilterRule.CategoryName
                string? category = section.Key;
                // 如果是 'Default' 配置节，则 LoggerFilterRule.CategoryName 为 null
                if (category.Equals(DefaultCategory, StringComparison.OrdinalIgnoreCase))
                {
                    category = null;
                }
                var newRule = new LoggerFilterRule(logger, category, level, null);
                options.Rules.Add(newRule);
            }
        }
    }

    private static bool TryGetSwitch(string? value, out LogLevel level)
    {
        if (string.IsNullOrEmpty(value))
        {
            level = LogLevel.None;
            return false;
        }
        else if (Enum.TryParse(value, true, out level))
        {
            return true;
        }
        else
        {
            throw new InvalidOperationException(SR.Format(SR.ValueNotSupported, value));
        }
    }
}
```

- LoggingBuilder  
```C#
// 日志构建者
// 本质是对 IServiceCollection 的封装
// 便于利用其它 ILoggingBuilder 扩展方法提供日志相关服务的注册
internal sealed class LoggingBuilder : ILoggingBuilder
{
    public LoggingBuilder(IServiceCollection services)
    {
        Services = services;
    }

    public IServiceCollection Services { get; }
}
```

- LoggingBuilderExtensions  
```C#
// 基于 ILoggingBuilder 的扩展方法
// 提供日志相关服务的注册
// Microsoft.Extensions.Logging.LoggingBuilderExtensions
public static class LoggingBuilderExtensions
{
    // 注册 LoggerFilterOptions 选项配置
    // 用来设置最小日志事件等级
    public static ILoggingBuilder SetMinimumLevel(this ILoggingBuilder builder, LogLevel level)
    {
        builder.Services.Add(ServiceDescriptor.Singleton<IConfigureOptions<LoggerFilterOptions>>(
            new DefaultLoggerLevelConfigureOptions(level)));
        return builder;
    }

    // 注册 ILoggerProvider 实例
    public static ILoggingBuilder AddProvider(this ILoggingBuilder builder, ILoggerProvider provider)
    {
        builder.Services.AddSingleton(provider);
        return builder;
    }

    // 清空所有已注册的 ILoggerProvider 服务
    public static ILoggingBuilder ClearProviders(this ILoggingBuilder builder)
    {
        builder.Services.RemoveAll<ILoggerProvider>();
        return builder;
    }

    // 注册 LoggerFactoryOptions 选项配置
    // 用来设置 ActivityTrackingOptions 活动跟踪枚举
    public static ILoggingBuilder Configure(this ILoggingBuilder builder, Action<LoggerFactoryOptions> action)
    {
        builder.Services.Configure(action);
        return builder;
    }

    // 使用 IConfiguration 注册 LoggerFilterOptions 选项配置
    // 此处 IConfiguration 为 LogLevel 配置节的父配置节
    public static ILoggingBuilder AddConfiguration(this ILoggingBuilder builder, IConfiguration configuration)
    {
        // 注册 ILoggerProviderConfigurationFactory 和 ILoggerProviderConfiguration<> 服务
        builder.AddConfiguration();

        // 注册 LoggerFilterOptions 选项配置
        // 使用基于文件配置的选项配置来设置 LoggerFilterRule 集合
        builder.Services.AddSingleton<IConfigureOptions<LoggerFilterOptions>>(new LoggerFilterConfigureOptions(configuration));
        // 注册 IOptionsChangeTokenSource<LoggerFilterOptions> 服务
        // 通过注入 IOptionsMonitor<LoggerFilterOptions> 来得到选项，所以需要监控配置文件的变动随时更新过滤选项
        builder.Services.AddSingleton<IOptionsChangeTokenSource<LoggerFilterOptions>>(
            new ConfigurationChangeTokenSource<LoggerFilterOptions>(configuration));

        // 注册 LoggingConfiguration
        // 作为 IConfiguration 的封装
        builder.Services.AddSingleton(new LoggingConfiguration(configuration));

        return builder;
    }
}
```

- LoggingBuilderConfigurationExtensions  
```C#
// 注册 ILoggerProviderConfigurationFactory 和 ILoggerProviderConfiguration<> 服务的扩展方法
public static class LoggingBuilderConfigurationExtensions
{
    public static void AddConfiguration(this ILoggingBuilder builder)
    {
        // 注册 ILoggerProviderConfigurationFactory
        builder.Services.TryAddSingleton<ILoggerProviderConfigurationFactory, LoggerProviderConfigurationFactory>();
        // 注册 ILoggerProviderConfiguration<>
        // 在服务消费时，泛型实参对应不同的 ILoggerProvider 类型
        builder.Services.TryAddSingleton(typeof(ILoggerProviderConfiguration<>), typeof(LoggerProviderConfiguration<>));
    }
}
```

- LoggingConfiguration  
```C#
// 针对 IConfiguration 的封装
// 此处 IConfiguration 为 LogLevel 配置节的父配置节
internal sealed class LoggingConfiguration
{
    public IConfiguration Configuration { get; }

    public LoggingConfiguration(IConfiguration configuration)
    {
        Configuration = configuration;
    }
}
```

- ILoggerProviderConfigurationFactory  
```C#
// ILoggerProvider 配置工厂
public interface ILoggerProviderConfigurationFactory
{
    // 根据不同的 ILoggerProvider 类型从 IConfigurationRoot 中得到对应配置节的 IConfigurationSection
    // 然后通过 IConfigurationBuilder.AddConfiguration 方法将 IConfigurationSection 构建为 ChainedConfigurationSource
    // 最终得到一个新的针对具体 ILoggerProvider 类型的 IConfigurationRoot
    IConfiguration GetConfiguration(Type providerType);
}
```

- LoggerProviderConfigurationFactory  
```C#
// ILoggerProviderConfigurationFactory 默认实现
internal sealed class LoggerProviderConfigurationFactory : ILoggerProviderConfigurationFactory
{
    private readonly IEnumerable<LoggingConfiguration> _configurations;

    public LoggerProviderConfigurationFactory(IEnumerable<LoggingConfiguration> configurations)
    {
        _configurations = configurations;
    }

    // 得到针对具体 ILoggerProvider 类型的 IConfigurationRoot
    public IConfiguration GetConfiguration(Type providerType)
    {
        ThrowHelper.ThrowIfNull(providerType);

        string fullName = providerType.FullName!;
        string? alias = ProviderAliasUtilities.GetAlias(providerType);
        // 通过创建 ConfigurationBuilder 来构建 IConfigurationRoot
        var configurationBuilder = new ConfigurationBuilder();
        foreach (LoggingConfiguration configuration in _configurations)
        {
            IConfigurationSection sectionFromFullName = configuration.Configuration.GetSection(fullName);
            // 将 providerType 全名配置节作为链接配置源添加到 ConfigurationBuilder
            configurationBuilder.AddConfiguration(sectionFromFullName);

            // 如果存在 providerType 别名，将 providerType 别名配置节作为链接配置源添加到 ConfigurationBuilder
            // 由于别名配置节后注册，所以别名配置优先级高于全名配置
            if (!string.IsNullOrWhiteSpace(alias))
            {
                IConfigurationSection sectionFromAlias = configuration.Configuration.GetSection(alias);
                configurationBuilder.AddConfiguration(sectionFromAlias);
            }
        }
        return configurationBuilder.Build();
    }
}
```

- ILoggerProviderConfiguration\<\>  
```C#
// ILoggerProvider 配置的抽象表示
public interface ILoggerProviderConfiguration<T>
{
    // 根据 ILoggerProvider 类型得到的 IConfigurationRoot
    IConfiguration Configuration { get; }
}
```

- LoggerProviderConfiguration\<\>  
```C#
// ILoggerProviderConfiguration<> 默认实现
internal sealed class LoggerProviderConfiguration<T> : ILoggerProviderConfiguration<T>
{
    public LoggerProviderConfiguration(ILoggerProviderConfigurationFactory providerConfigurationFactory)
    {
        // 根据 ILoggerProvider 类型得到对应的 IConfigurationRoot
        Configuration = providerConfigurationFactory.GetConfiguration(typeof(T));
    }

    public IConfiguration Configuration { get; }
}
```

- LoggerProviderOptions  
```C#
// ILoggerProvider 选项
// 由于可以通过依赖注入方式得到 ILoggerProviderConfiguration<> 并通过 Configuration 属性所引用的 IConfigurationRoot 访问配置
// 所以可以通过注册选项配置来将对应的配置绑定到选项上
// 此处应该定义为扩展方法
public static class LoggerProviderOptions
{
    public static void RegisterProviderOptions<TOptions, TProvider>(IServiceCollection services) where TOptions : class
    {
        // 根据选项类型和 ILoggerProvider 类型注册选项配置
        services.TryAddEnumerable(ServiceDescriptor.Singleton<IConfigureOptions<TOptions>, LoggerProviderConfigureOptions<TOptions, TProvider>>());
        // 由于配置信息来源于文件，可以使用 IOptionsMonitor<> 作为依赖注入时的服务类型，并通过注册 IOptionsChangeTokenSource<> 来监控文件的变动
        // 并在变动后发出回调更新选项
        services.TryAddEnumerable(ServiceDescriptor.Singleton<IOptionsChangeTokenSource<TOptions>, LoggerProviderOptionsChangeTokenSource<TOptions, TProvider>>());
    }
}
```

- LoggerProviderConfigureOptions\<,\>  
```C#
// LoggerProviderConfigureOptions 选项
// 通过继承 ConfigureFromConfigurationOptions<> 绑定配置
internal sealed class LoggerProviderConfigureOptions<TOptions, TProvider> : ConfigureFromConfigurationOptions<TOptions> where TOptions : class
{
    public LoggerProviderConfigureOptions(ILoggerProviderConfiguration<TProvider> providerConfiguration)
        : base(providerConfiguration.Configuration)
    {
    }
}
```

- LoggerProviderOptionsChangeTokenSource\<,\>  
```C#
// 针对 ILoggerProvider 配置变化的监控
// 通过继承 ConfigurationChangeTokenSource<> 监控变化
public class LoggerProviderOptionsChangeTokenSource<TOptions, TProvider> : ConfigurationChangeTokenSource<TOptions>
{
    public LoggerProviderOptionsChangeTokenSource(ILoggerProviderConfiguration<TProvider> providerConfiguration) : base(providerConfiguration.Configuration)
    {
    }
}
```

- FilterLoggingBuilderExtensions  
```C#
// 注册 LoggerFilterOptions 选项配置的扩展方法
public static class FilterLoggingBuilderExtensions
{
    // ILoggingBuilder 扩展方法
    // 注册选项配置
    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string?, string?, LogLevel, bool> filter) =>
        builder.ConfigureFilter(options => options.AddFilter(filter));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<string?, LogLevel, bool> categoryLevelFilter) =>
        builder.ConfigureFilter(options => options.AddFilter(categoryLevelFilter));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, Func<string?, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(categoryLevelFilter));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, Func<LogLevel, bool> levelFilter) =>
        builder.ConfigureFilter(options => options.AddFilter(levelFilter));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(levelFilter));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string? category, LogLevel level) =>
        builder.ConfigureFilter(options => options.AddFilter(category, level));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string? category, LogLevel level) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(category, level));

    public static ILoggingBuilder AddFilter(this ILoggingBuilder builder, string? category, Func<LogLevel, bool> levelFilter) =>
        builder.ConfigureFilter(options => options.AddFilter(category, levelFilter));

    public static ILoggingBuilder AddFilter<T>(this ILoggingBuilder builder, string? category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        builder.ConfigureFilter(options => options.AddFilter<T>(category, levelFilter));

    // LoggerFilterOptions 扩展方法
    // 以下 AddFilter 方法应该被定义为 private
    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string?, string?, LogLevel, bool> filter) =>
        AddRule(builder, filter: filter);

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<string?, LogLevel, bool> categoryLevelFilter) =>
        AddRule(builder, filter: (type, name, level) => categoryLevelFilter(name, level));

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, Func<string?, LogLevel, bool> categoryLevelFilter) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, filter: (type, name, level) => categoryLevelFilter(name, level));

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, Func<LogLevel, bool> levelFilter) =>
        AddRule(builder, filter: (type, name, level) => levelFilter(level));

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, filter: (type, name, level) => levelFilter(level));

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string? category, LogLevel level) =>
        AddRule(builder, category: category, level: level);

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string? category, LogLevel level) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, category: category, level: level);

    public static LoggerFilterOptions AddFilter(this LoggerFilterOptions builder, string? category, Func<LogLevel, bool> levelFilter) =>
        AddRule(builder, category: category, filter: (type, name, level) => levelFilter(level));

    public static LoggerFilterOptions AddFilter<T>(this LoggerFilterOptions builder, string? category, Func<LogLevel, bool> levelFilter) where T : ILoggerProvider =>
        AddRule(builder, type: typeof(T).FullName, category: category, filter: (type, name, level) => levelFilter(level));

    // 注册选项配置
    private static ILoggingBuilder ConfigureFilter(this ILoggingBuilder builder, Action<LoggerFilterOptions> configureOptions)
    {
        builder.Services.Configure(configureOptions);
        return builder;
    }

    // 根据 LoggerProvider 类型全名或别名和日志类别所表示的 LoggerFilterRule 添加进规则集合
    private static LoggerFilterOptions AddRule(LoggerFilterOptions options,
        string? type = null,
        string? category = null,
        LogLevel? level = null,
        Func<string?, string?, LogLevel, bool>? filter = null)
    {
        options.Rules.Add(new LoggerFilterRule(type, category, level, filter));
        return options;
    }
}
```

- LoggerExtensions  
```C#
// 提供不同日志等级名称的日志记录扩展方法
// 本质是调用 ILogger.Log<FormattedLogValues> 方法（使用 FormattedLogValues 类型作为日志载荷 TState 的泛型实参）
// 并统一利用 MessageFormatter 作为格式化日志消息的委托
public static class LoggerExtensions
{
    private static readonly Func<FormattedLogValues, Exception?, string> _messageFormatter = MessageFormatter;

    public static void LogDebug(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, eventId, exception, message, args);
    }

    public static void LogDebug(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, eventId, message, args);
    }

    public static void LogDebug(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, exception, message, args);
    }

    public static void LogDebug(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Debug, message, args);
    }

    public static void LogTrace(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, eventId, exception, message, args);
    }

    public static void LogTrace(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, eventId, message, args);
    }

    public static void LogTrace(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, exception, message, args);
    }

    public static void LogTrace(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Trace, message, args);
    }

    public static void LogInformation(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, eventId, exception, message, args);
    }

    public static void LogInformation(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, eventId, message, args);
    }

    public static void LogInformation(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, exception, message, args);
    }

    public static void LogInformation(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Information, message, args);
    }

    public static void LogWarning(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, eventId, exception, message, args);
    }

    public static void LogWarning(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, eventId, message, args);
    }

    public static void LogWarning(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, exception, message, args);
    }

    public static void LogWarning(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Warning, message, args);
    }

    public static void LogError(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, eventId, exception, message, args);
    }

    public static void LogError(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, eventId, message, args);
    }

    public static void LogError(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, exception, message, args);
    }

    public static void LogError(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Error, message, args);
    }

    public static void LogCritical(this ILogger logger, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, eventId, exception, message, args);
    }

    public static void LogCritical(this ILogger logger, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, eventId, message, args);
    }

    public static void LogCritical(this ILogger logger, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, exception, message, args);
    }

    public static void LogCritical(this ILogger logger, string? message, params object?[] args)
    {
        logger.Log(LogLevel.Critical, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, string? message, params object?[] args)
    {
        logger.Log(logLevel, 0, null, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, EventId eventId, string? message, params object?[] args)
    {
        logger.Log(logLevel, eventId, null, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, Exception? exception, string? message, params object?[] args)
    {
        logger.Log(logLevel, 0, exception, message, args);
    }

    public static void Log(this ILogger logger, LogLevel logLevel, EventId eventId, Exception? exception, string? message, params object?[] args)
    {
        ThrowHelper.ThrowIfNull(logger);

        // 不直接使用 MessageFormatter 方法作为参数的原因是
        // 避免每次调用方法都要创建 Func<FormattedLogValues, Exception?, string> 实例
        logger.Log(logLevel, eventId, new FormattedLogValues(message, args), exception, _messageFormatter);
    }

    public static IDisposable? BeginScope(
        this ILogger logger,
        string messageFormat,
        params object?[] args)
    {
        ThrowHelper.ThrowIfNull(logger);

        return logger.BeginScope(new FormattedLogValues(messageFormat, args));
    }

    private static string MessageFormatter(FormattedLogValues state, Exception? error)
    {
        return state.ToString();
    }
}
```

## 控制台

- ConsoleLoggerProvider  
```C#
// 针对控制台的 ILoggerProvider 实现
// 别名 "Console"
[UnsupportedOSPlatform("browser")]
[ProviderAlias("Console")]
public class ConsoleLoggerProvider : ILoggerProvider, ISupportExternalScope
{
    // ConsoleLoggerOptions 选项
    // 目前 ConsoleLoggerOptions 类型中的大部分属性已经作废
    // 使用 ConsoleFormatterOptions 类型代替
    private readonly IOptionsMonitor<ConsoleLoggerOptions> _options;
    // 缓存根据不同日志类别创建的 ILogger
    private readonly ConcurrentDictionary<string, ConsoleLogger> _loggers;
    // 缓存格式化器
    // 系统内建的三个格式化器对应的名称：
    // 1. simple
    // 2. json
    // 3. systemd
    private ConcurrentDictionary<string, ConsoleFormatter> _formatters;
    // 日志处理器，本质是利用内部的一个消息队列顺序输出日志消息
    private readonly ConsoleLoggerProcessor _messageQueue;

    // 利用 IOptionsMonitor<>.OnChange 注册回调
    // 可以通过调用 IDisposable.Dispose 取消注册
    private IDisposable? _optionsReloadToken;
    // 通过 SetScopeProvider 方法传入的 IExternalScopeProvider 用来收集日志范围的活动跟踪
    // 默认为 NullExternalScopeProvider 表示不支持收集日志范围
    private IExternalScopeProvider _scopeProvider = NullExternalScopeProvider.Instance;

    public ConsoleLoggerProvider(IOptionsMonitor<ConsoleLoggerOptions> options)
            : this(options, Array.Empty<ConsoleFormatter>()) { }
 
    // 会被依赖注入框架选为最优构造函数
    public ConsoleLoggerProvider(IOptionsMonitor<ConsoleLoggerOptions> options, IEnumerable<ConsoleFormatter>? formatters)
    {
        _options = options;
        _loggers = new ConcurrentDictionary<string, ConsoleLogger>();
        // 设置格式化器
        SetFormatters(formatters);
        // 标准输出
        // 可以通过 Console.SetOut 静态方法设置标准输出使用的 TextWriter 写入器
        IConsole? console;
        // 错误输出
        // 可以通过 Console.SetError 静态方法设置错误输出使用的 TextWriter 写入器
        IConsole? errorConsole;
        // 判断是否支持 ansi 编码
        if (DoesConsoleSupportAnsi())
        {
            console = new AnsiLogConsole();
            errorConsole = new AnsiLogConsole(stdErr: true);
        }
        else
        {
            console = new AnsiParsingLogConsole();
            errorConsole = new AnsiParsingLogConsole(stdErr: true);
        }
        // 创建日志处理器
        _messageQueue = new ConsoleLoggerProcessor(
            console,
            errorConsole,
            options.CurrentValue.QueueFullMode,
            options.CurrentValue.MaxQueueLength);

        // 根据 ConsoleLoggerOptions 选项选择格式化器
        ReloadLoggerOptions(options.CurrentValue);
        // 注册配置源变动后触发的回调
        _optionsReloadToken = _options.OnChange(ReloadLoggerOptions);
    }

    // 设置格式化器
    private void SetFormatters(IEnumerable<ConsoleFormatter>? formatters = null)
    {
        // 名称忽略大小写
        var cd = new ConcurrentDictionary<string, ConsoleFormatter>(StringComparer.OrdinalIgnoreCase);

        bool added = false;
        if (formatters != null)
        {
            // 将注册的格式化器添加到缓存中
            foreach (ConsoleFormatter formatter in formatters)
            {
                cd.TryAdd(formatter.Name, formatter);
                added = true;
            }
        }

        // 如果没有注册任何式化器则添加三个系统内建的格式化器
        if (!added)
        {
            // ConsoleFormatterNames.Simple 常量对应名称 "simple"
            cd.TryAdd(ConsoleFormatterNames.Simple, new SimpleConsoleFormatter(new FormatterOptionsMonitor<SimpleConsoleFormatterOptions>(new SimpleConsoleFormatterOptions())));
            // ConsoleFormatterNames.Systemd 常量对应名称 "systemd"
            cd.TryAdd(ConsoleFormatterNames.Systemd, new SystemdConsoleFormatter(new FormatterOptionsMonitor<ConsoleFormatterOptions>(new ConsoleFormatterOptions())));
            // ConsoleFormatterNames.Json 常量对应名称 "json"
            cd.TryAdd(ConsoleFormatterNames.Json, new JsonConsoleFormatter(new FormatterOptionsMonitor<JsonConsoleFormatterOptions>(new JsonConsoleFormatterOptions())));
        }

        _formatters = cd;
    }

    // 重新加载新的 ConsoleLoggerOptions 选项
    // 并根据选项选择应用新的格式化器
    private void ReloadLoggerOptions(ConsoleLoggerOptions options)
    {
        // ConsoleLoggerOptions.FormatterName 为 null 或缓存中没有对应名称的格式化器
        // 则根据 ConsoleLoggerOptions.Format 属性的枚举值选择 systemd 或 simple 的内建格式化器
        if (options.FormatterName == null || !_formatters.TryGetValue(options.FormatterName, out ConsoleFormatter? logFormatter))
        {
#pragma warning disable CS0618
            logFormatter = options.Format switch
            {
                ConsoleLoggerFormat.Systemd => _formatters[ConsoleFormatterNames.Systemd],
                // 只要 ConsoleLoggerOptions.Format != ConsoleLoggerFormat.Systemd，则使用名称为 "simple" 的格式化器
                _ => _formatters[ConsoleFormatterNames.Simple],
            };
            if (options.FormatterName == null)
            {
                // 如果不是通过配置的 ConsoleLoggerOptions.FormatterName 从缓存中获取的格式化器
                // 则会使用 ConsoleLoggerOptions 选项更新名称为 "systemd" 或 "simple" 的系统内建格式化器的 FormatterOptions 属性
                // 因为这时候名称为 "systemd" 或 "simple" 的系统内建格式化器可能不是通过依赖注入框架创建的
                // 那么 FormatterOptions 属性就可能是没有通过选项配置的 ConsoleFormatterOptions
                // 所以需要在这里依靠 ConsoleLoggerOptions 额外配置
                UpdateFormatterOptions(logFormatter, options);
            }
#pragma warning restore CS0618
        }

        _messageQueue.FullMode = options.QueueFullMode;
        _messageQueue.MaxQueueLength = options.MaxQueueLength;

        // 用重新选择的格式化器和更新后的 ConsoleLoggerOptions 选项修改每个创建的 ConsoleLogger 
        foreach (KeyValuePair<string, ConsoleLogger> logger in _loggers)
        {
            logger.Value.Options = options;
            logger.Value.Formatter = logFormatter;
        }
    }

    #pragma warning disable CS0618
    // 更新格式化器的 FormatterOptions 属性
    private static void UpdateFormatterOptions(ConsoleFormatter formatter, ConsoleLoggerOptions deprecatedFromOptions)
    {
        if (formatter is SimpleConsoleFormatter defaultFormatter)
        {
            defaultFormatter.FormatterOptions = new SimpleConsoleFormatterOptions()
            {
                // SimpleConsoleFormatterOptions 可以用来控制颜色行为和单行显示行为
                ColorBehavior = deprecatedFromOptions.DisableColors ? LoggerColorBehavior.Disabled : LoggerColorBehavior.Default,
                IncludeScopes = deprecatedFromOptions.IncludeScopes,
                TimestampFormat = deprecatedFromOptions.TimestampFormat,
                UseUtcTimestamp = deprecatedFromOptions.UseUtcTimestamp,
            };
        }
        else if (formatter is SystemdConsoleFormatter systemdFormatter)
        {
            systemdFormatter.FormatterOptions = new ConsoleFormatterOptions()
            {
                IncludeScopes = deprecatedFromOptions.IncludeScopes,
                TimestampFormat = deprecatedFromOptions.TimestampFormat,
                UseUtcTimestamp = deprecatedFromOptions.UseUtcTimestamp,
            };
        }
    }
#pragma warning restore CS0618

    // 实现 IDisposable
    public void Dispose()
    {
        // 取消 IOptionsMonitor<>.OnChange 注册的回调
        _optionsReloadToken?.Dispose();
        // 释放消息队列
        _messageQueue.Dispose();
    }

    // 设置 IExternalScopeProvider
    // 实现日志范围的活动跟踪
    // LoggerFactory 会根据注入的 ILoggerProvider 是否实现了 ISupportExternalScope 接口来决定是否
    // 调用 ISupportExternalScope.SetScopeProvider 方法将 IExternalScopeProvider 传入
    public void SetScopeProvider(IExternalScopeProvider scopeProvider)
    {
        _scopeProvider = scopeProvider;

        // 将 IExternalScopeProvider 传递给每个创建的 ILogger
        foreach (System.Collections.Generic.KeyValuePair<string, ConsoleLogger> logger in _loggers)
        {
            logger.Value.ScopeProvider = _scopeProvider;
        }
    }

    // 根据日志类别创建 ILogger
    public ILogger CreateLogger(string name)
    {
        if (_options.CurrentValue.FormatterName == null || !_formatters.TryGetValue(_options.CurrentValue.FormatterName, out ConsoleFormatter? logFormatter))
        {
#pragma warning disable CS0618
            logFormatter = _options.CurrentValue.Format switch
            {
                ConsoleLoggerFormat.Systemd => _formatters[ConsoleFormatterNames.Systemd],
                _ => _formatters[ConsoleFormatterNames.Simple],
            };
#pragma warning restore CS0618

            if (_options.CurrentValue.FormatterName == null)
            {
                UpdateFormatterOptions(logFormatter, _options.CurrentValue);
            }
        }

        return _loggers.TryGetValue(name, out ConsoleLogger? logger) 
            ? logger 
            : _loggers.GetOrAdd(name, new ConsoleLogger(name, _messageQueue, logFormatter, _scopeProvider, _options.CurrentValue));
    }
}
```

- ConsoleLogger  
```C#
// 由 ConsoleLoggerProvider 创建的 ILogger
internal sealed class ConsoleLogger : ILogger
{
    // 日志类别
    private readonly string _name;
    // 用来实现日志消息的有序输出
    // 由 ConsoleLoggerProvider 提供
    private readonly ConsoleLoggerProcessor _queueProcessor;

    internal ConsoleLogger(
        string name,
        ConsoleLoggerProcessor loggerProcessor,
        ConsoleFormatter formatter,
        IExternalScopeProvider? scopeProvider,
        ConsoleLoggerOptions options)
    {
        ThrowHelper.ThrowIfNull(name);

        _name = name;
        _queueProcessor = loggerProcessor;
        Formatter = formatter;
        ScopeProvider = scopeProvider;
        Options = options;
    }

    // 格式化器
    internal ConsoleFormatter Formatter { get; set; }
    // 调用 ConsoleLoggerProvider.SetScopeProvider 方法传入
    // 实现日志范围的活动跟踪
    internal IExternalScopeProvider? ScopeProvider { get; set; }
    // ConsoleLoggerOptions 选项
    internal ConsoleLoggerOptions Options { get; set; }

    [ThreadStatic]
    private static StringWriter? t_stringWriter;

    // 日志输出方法
    public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        // 检查日志事件等级
        if (!IsEnabled(logLevel))
        {
            return;
        }

        ThrowHelper.ThrowIfNull(formatter);

        // 使用 StringWriter 作为写入器
        t_stringWriter ??= new StringWriter();
        // 构建日志荷载
        // ConsoleFormatter.Write 方法的处理目标
        LogEntry<TState> logEntry = new LogEntry<TState>(logLevel, _name, eventId, state, exception, formatter);
        // 利用格式化器对日志荷载进行格式化并写入 StringWriter 缓冲区
        Formatter.Write(in logEntry, ScopeProvider, t_stringWriter);

        // 获取格式化日志消息
        // 冲洗 StringWriter 缓冲区
        var sb = t_stringWriter.GetStringBuilder();
        if (sb.Length == 0)
        {
            return;
        }
        string computedAnsiString = sb.ToString();
        sb.Clear();
        if (sb.Capacity > 1024)
        {
            sb.Capacity = 1024;
        }
        // 将格式化日志消息送入队列
        // 大于 ConsoleLoggerOptions.LogToStandardErrorThreshold 设置的日志事件等级的使用错误输出
        _queueProcessor.EnqueueMessage(new LogMessageEntry(computedAnsiString, logAsError: logLevel >= Options.LogToStandardErrorThreshold));
    }

    // 日志事件等级过滤方法
    public bool IsEnabled(LogLevel logLevel)
    {
        // 日志事件等级只要不为 LogLevel.None 皆为 true
        return logLevel != LogLevel.None;
    }

    // 如果设置了 IExternalScopeProvider，则调用 IExternalScopeProvider.Push 方法开始日志范围的活动跟踪（压栈）
    // 否则返回 NullScope，不能使用日志范围
    public IDisposable BeginScope<TState>(TState state) where TState : notnull => ScopeProvider?.Push(state) ?? NullScope.Instance;
}
```

- LogEntry\<\>  
```C#
// ConsoleFormatter 的处理目标
public readonly struct LogEntry<TState>
{
    public LogEntry(LogLevel logLevel, string category, EventId eventId, TState state, Exception? exception, Func<TState, Exception?, string> formatter)
    {
        LogLevel = logLevel;
        Category = category;
        EventId = eventId;
        State = state;
        Exception = exception;
        Formatter = formatter;
    }

    // 日志事件等级
    public LogLevel LogLevel { get; }

    // 日志类别
    public string Category { get; }

    // 日志事件 ID
    public EventId EventId { get; }

    // 日志荷载
    public TState State { get; }

    // 异常
    public Exception? Exception { get; }

    // 日志格式化委托
    public Func<TState, Exception?, string> Formatter { get; }
}
```

- ConsoleLoggerOptions  
```C#
// ConsoleLoggerOptions 选项
public class ConsoleLoggerOptions
{
    // 格式化器名称
    public string? FormatterName { get; set; }

    // 高于此日志事件等级的使用错误输出
    // 默认不使用错误输出
    public LogLevel LogToStandardErrorThreshold { get; set; } = LogLevel.None;

    private ConsoleLoggerQueueFullMode _queueFullMode = ConsoleLoggerQueueFullMode.Wait;
    // 队列满时的行为
    // 默认为 ConsoleLoggerQueueFullMode.Wait 等待
    // 可以使用 ConsoleLoggerQueueFullMode.DropWrite 丢弃日志写入
    public ConsoleLoggerQueueFullMode QueueFullMode
    {
        get => _queueFullMode;
        set
        {
            if (value != ConsoleLoggerQueueFullMode.Wait && value != ConsoleLoggerQueueFullMode.DropWrite)
            {
                throw new ArgumentOutOfRangeException(SR.Format(SR.QueueModeNotSupported, nameof(value)));
            }
            _queueFullMode = value;
        }
    }

    internal const int DefaultMaxQueueLengthValue = 2500;
    private int _maxQueuedMessages = DefaultMaxQueueLengthValue;

    // 日志处理器的最大队列容量
    public int MaxQueueLength
    {
        get => _maxQueuedMessages;
        set
        {
            if (value <= 0)
            {
                throw new ArgumentOutOfRangeException(SR.Format(SR.MaxQueueLengthBadValue, nameof(value)));
            }

            _maxQueuedMessages = value;
        }
    }

#pragma warning disable CS0618
    private ConsoleLoggerFormat _format = ConsoleLoggerFormat.Default;
    // 格式化器类别
    // 已废弃
    // 用 ConsoleLoggerOptions.FormatterName 替代
    [System.ObsoleteAttribute("ConsoleLoggerOptions.Format has been deprecated. Use ConsoleLoggerOptions.FormatterName instead.")]
    public ConsoleLoggerFormat Format
    {
        get => _format;
        set
        {
            if (value < ConsoleLoggerFormat.Default || value > ConsoleLoggerFormat.Systemd)
            {
                throw new ArgumentOutOfRangeException(nameof(value));
            }
            _format = value;
        }
#pragma warning restore CS0618
    }

    // 是否启用颜色行为
    // 已废弃
    // 用 SimpleConsoleFormatterOptions.ColorBehavior 替代
    [System.ObsoleteAttribute("ConsoleLoggerOptions.DisableColors has been deprecated. Use SimpleConsoleFormatterOptions.ColorBehavior instead.")]
    public bool DisableColors { get; set; }

    // 是否输出包含日志范围的信息
    // 已废弃
    // 用 ConsoleFormatterOptions.IncludeScopes 替代
    [System.ObsoleteAttribute("ConsoleLoggerOptions.IncludeScopes has been deprecated. Use ConsoleFormatterOptions.IncludeScopes instead.")]
    public bool IncludeScopes { get; set; }

    // 时间戳格式化
    // 已废弃
    // 用 ConsoleFormatterOptions.TimestampFormat 替代
    [System.ObsoleteAttribute("ConsoleLoggerOptions.TimestampFormat has been deprecated. Use ConsoleFormatterOptions.TimestampFormat instead.")]
    public string? TimestampFormat { get; set; }

    // 是否使用 Utc 时间戳
    // 已废弃
    // 使用 ConsoleFormatterOptions.UseUtcTimestamp 替代
    [System.ObsoleteAttribute("ConsoleLoggerOptions.UseUtcTimestamp has been deprecated. Use ConsoleFormatterOptions.UseUtcTimestamp instead.")]
    public bool UseUtcTimestamp { get; set; }
}
```

- ConsoleFormatterOptions  
```C#
// 格式化器选项
public class ConsoleFormatterOptions
{
    public ConsoleFormatterOptions() { }

    // 日志消息输出中是否包含日志范围的活动跟踪信息
    public bool IncludeScopes { get; set; }

    // 时间戳格式
    [StringSyntax(StringSyntaxAttribute.DateTimeFormat)]
    public string? TimestampFormat { get; set; }

    // 是否使用 UTC 时间
    public bool UseUtcTimestamp { get; set; }
}
```

- SimpleConsoleFormatterOptions  
```C#
// 名称为 "simple" 的格式化器
public class SimpleConsoleFormatterOptions : ConsoleFormatterOptions
{
    public SimpleConsoleFormatterOptions() { }

    // 是否启用颜色
    // LoggerColorBehavior 枚举
    public LoggerColorBehavior ColorBehavior { get; set; }

    // 是否单行显示
    public bool SingleLine { get; set; }
}
```

- ConsoleFormatter  
```C#
// 格式化器抽象表示
// 内建的三个实现类型：
// 1. SimpleConsoleFormatter
// 2. SystemdConsoleFormatter
// 3. JsonConsoleFormatter
public abstract class ConsoleFormatter
{
    // 实现类必须为格式化器指定一个名称
    protected ConsoleFormatter(string name)
    {
        ThrowHelper.ThrowIfNull(name);

        Name = name;
    }

    // 格式化器名称
    public string Name { get; }

    // 具体实现通过重写此方法，将日志消息格式化后写入 TextWriter 缓冲区
    // 大致的具体步骤如下：
    // 1. 利用 LogEntry<>.State、LogEntry<>.Exception 通过 LogEntry<>.Formatter 委托格式化日志消息
    // 2. 根据 ConsoleFormatterOptions.IncludeScopes 判断是否需要在输出中包含范围信息
    // 3. 利用 Scope.State（或者 Activity 的 W3C 格式的范围消息，根据 ActivityTrackingOptions 枚举值创建 ActivityLogScope）作为消息荷载
    //    通过消息荷载对象调用 ToString 方法得到范围消息
    //    最终利用 IExternalScopeProvider.ForEachScope<> 方法将范围消息写入 TextWriter 缓冲区  
    // 输出消息的顺序：
    // 1. 范围消息
    // 2. 日志消息
    // 3. 异常消息
    public abstract void Write<TState>(in LogEntry<TState> logEntry, IExternalScopeProvider? scopeProvider, TextWriter textWriter);
}
```

## 依赖注入

- ConsoleLoggerExtensions  
```C#
public static class ConsoleLoggerExtensions
{
    // 注册控制台日志核心服务
    // 注册基于文件配置源的 ConsoleLoggerOptions 选项配置
    public static ILoggingBuilder AddConsole(this ILoggingBuilder builder)
    {
        // 需要确保注册 ILoggerProviderConfigurationFactory 和 ILoggerProviderConfiguration<> 服务
        // 因为注册的 ConsoleLoggerOptions 选项配置依赖这两个服务注册
        builder.AddConfiguration();

        // 注册三个内建的格式化器和它们所对应的 ConsoleFormatterOptions 选项配置
        builder.AddConsoleFormatter<JsonConsoleFormatter, JsonConsoleFormatterOptions>();
        builder.AddConsoleFormatter<SystemdConsoleFormatter, ConsoleFormatterOptions>();
        builder.AddConsoleFormatter<SimpleConsoleFormatter, SimpleConsoleFormatterOptions>();

        // 注册 ILoggerProvider
        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<ILoggerProvider, ConsoleLoggerProvider>());
        // 注册 ConsoleLoggerOptions 选项配置
        // 将 ConsoleLoggerProvider 所对应的 IConfigurationSection 配置节的配置绑定到 ConsoleLoggerOptions 选项上
        LoggerProviderOptions.RegisterProviderOptions<ConsoleLoggerOptions, ConsoleLoggerProvider>(builder.Services);

        return builder;
    }

    // 通过 Action<ConsoleLoggerOptions> 注册 ConsoleLoggerOptions 选项配置
    public static ILoggingBuilder AddConsole(this ILoggingBuilder builder, Action<ConsoleLoggerOptions> configure)
    {
        ThrowHelper.ThrowIfNull(configure);

        builder.AddConsole();
        builder.Services.Configure(configure);

        return builder;
    }

    // 注册 ConsoleLoggerOptions 选项配置
    // 配置 ConsoleLoggerOptions.FormatterName 为 ConsoleFormatterNames.Simple
    // AddJsonConsole 和 AddSystemdConsole 具有相似的实现
    public static ILoggingBuilder AddSimpleConsole(this ILoggingBuilder builder) =>
            builder.AddFormatterWithName(ConsoleFormatterNames.Simple);
    
    // 注册 SimpleConsoleFormatterOptions 选项配置
    // AddJsonConsole 和 AddSystemdConsole 具有相的实现
    public static ILoggingBuilder AddSimpleConsole(this ILoggingBuilder builder, Action<SimpleConsoleFormatterOptions> configure)
    {
        return builder.AddConsoleWithFormatter<SimpleConsoleFormatterOptions>(ConsoleFormatterNames.Simple, configure);
    }

    // 注册 ConsoleLoggerOptions 选项配置
    private static ILoggingBuilder AddFormatterWithName(this ILoggingBuilder builder, string name) =>
        builder.AddConsole((ConsoleLoggerOptions options) => options.FormatterName = name);

    // 注册 ConsoleFormatterOptions 选项配置
    internal static ILoggingBuilder AddConsoleWithFormatter<TOptions>(this ILoggingBuilder builder, string name, Action<TOptions> configure)
        where TOptions : ConsoleFormatterOptions
    {
        ThrowHelper.ThrowIfNull(configure);

        builder.AddFormatterWithName(name);
        builder.Services.Configure(configure);

        return builder;
    }

    // 注册格式化器和对应的 ConsoleFormatterOptions 选项配置
    public static ILoggingBuilder AddConsoleFormatter<TFormatter, TOptions>(this ILoggingBuilder builder)
        where TOptions : ConsoleFormatterOptions
        where TFormatter : ConsoleFormatter
    {
        builder.AddConfiguration();

        // 注册格式化器
        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<ConsoleFormatter, TFormatter>());
        // 注册 ConsoleFormatterOptions 选项配置
        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<IConfigureOptions<TOptions>, ConsoleLoggerFormatterConfigureOptions<TFormatter, TOptions>>());
        // 由于配置来源最终可以追溯到 LoggingConfiguration 封装的 IConfiguration
        // 所以可以通过 IOptionsMonitor<> 得到配置，并在配置改变后发出回调更新选项
        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton<IOptionsChangeTokenSource<TOptions>, ConsoleLoggerFormatterOptionsChangeTokenSource<TFormatter, TOptions>>());

        return builder;
    }

    // 通过 Action<TOptions> 注册 ConsoleFormatterOptions 选项配置
    public static ILoggingBuilder AddConsoleFormatter<TFormatter, TOptions>(this ILoggingBuilder builder, Action<TOptions> configure)
        where TOptions : ConsoleFormatterOptions
        where TFormatter : ConsoleFormatter
    {
        ThrowHelper.ThrowIfNull(configure);

        builder.AddConsoleFormatter<TFormatter, TOptions>();
        builder.Services.Configure(configure);
        return builder;
    }
}
```

- ConsoleLoggerFormatterConfigureOptions\<,\>  
```C#
// ConsoleLoggerFormatter 选项配置
internal sealed class ConsoleLoggerFormatterConfigureOptions<TFormatter, TOptions> : ConfigureFromConfigurationOptions<TOptions>
    where TOptions : ConsoleFormatterOptions
    where TFormatter : ConsoleFormatter
{
    // 利用 ConsoleLoggerProvider 对应配置节下的子配置节 "FormatterOptions" 绑定选项
    public ConsoleLoggerFormatterConfigureOptions(ILoggerProviderConfiguration<ConsoleLoggerProvider> providerConfiguration) :
        base(providerConfiguration.Configuration.GetSection("FormatterOptions"))
    {
    }
}
```

- ConsoleLoggerFormatterOptionsChangeTokenSource\<,\>  
```C#
// ConsoleLoggerFormatter 选项配置改变源
// 用于在配置发送改变时发出回调
internal sealed class ConsoleLoggerFormatterOptionsChangeTokenSource<TFormatter, TOptions> : ConfigurationChangeTokenSource<TOptions>
    where TOptions : ConsoleFormatterOptions
    where TFormatter : ConsoleFormatter
{
    // 利用 ConsoleLoggerProvider 对应配置节下的子配置节 "FormatterOptions" 绑定选项
    public ConsoleLoggerFormatterOptionsChangeTokenSource(ILoggerProviderConfiguration<ConsoleLoggerProvider> providerConfiguration)
        : base(providerConfiguration.Configuration.GetSection("FormatterOptions"))
    {
    }
}
```