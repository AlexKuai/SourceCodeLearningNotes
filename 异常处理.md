# 异常处理

## 源码涉及的核心类型

- ErrorContext  
- IDeveloperPageExceptionFilter  
- DeveloperExceptionPageOptions  
- DeveloperExceptionPageMiddlewareImpl  
- DeveloperExceptionPageExtensions  
- IExceptionHandler  
- ExceptionHandlerOptions  
- ExceptionHandlerMiddlewareImpl  
- ExceptionHandlerExtensions  
- RerouteHelper  
- StatusCodeContext  
- StatusCodePageOptions  
- StatusCodePagesMiddleware  
- StatusCodePagesExtensions  

## 开发者异常页

- ErrorContext

```C#
// 错误上下文
// 对 HttpContext 和 Exception 的封装
public class ErrorContext
{
    public ErrorContext(HttpContext httpContext, Exception exception)
    {
        HttpContext = httpContext ?? throw new ArgumentNullException(nameof(httpContext));
        Exception = exception ?? throw new ArgumentNullException(nameof(exception));
    }

    public HttpContext HttpContext { get; }
 
    public Exception Exception { get; }
}
```

- IDeveloperPageExceptionFilter

```C#
// 开发者异常页过滤器接口
// 用于在渲染错误页之前对异常做一些额外的处理
public interface IDeveloperPageExceptionFilter
{
    // 处理异常并可以将 ErrorContext 传递给异常处理器委托链
    Task HandleExceptionAsync(ErrorContext errorContext, Func<ErrorContext, Task> next);
}
```

- DeveloperExceptionPageOptions

```C#
// 开发者异常页选项
public class DeveloperExceptionPageOptions
{
    public DeveloperExceptionPageOptions()
    {
        // 默认包含异常发生位置的前后源码各 6 行
        SourceCodeLineCount = 6;
    }
 
    // 显示异常发生位置的前后源代码行数
    public int SourceCodeLineCount { get; set; }
 
    // 文件提供器
    // 用于提供源代码文件所在的目录
    public IFileProvider? FileProvider { get; set; }
}
```

- DeveloperExceptionPageMiddlewareImpl

```C#
// 开发者异常页中间件
internal class DeveloperExceptionPageMiddlewareImpl
{
    private readonly RequestDelegate _next;
    private readonly DeveloperExceptionPageOptions _options;
    private readonly ILogger _logger;
    private readonly IFileProvider _fileProvider;
    private readonly DiagnosticSource _diagnosticSource;
    private readonly DiagnosticsMetrics _metrics;
    private readonly ExceptionDetailsProvider _exceptionDetailsProvider;
    // 异常处理器委托链的入口
    private readonly Func<ErrorContext, Task> _exceptionHandler;
    // 开发者异常页响应的媒体类型为 text/html
    private static readonly MediaTypeHeaderValue _textHtmlMediaType = new MediaTypeHeaderValue("text/html");
    private readonly ExtensionsExceptionJsonContext _serializationContext;
    private readonly IProblemDetailsService? _problemDetailsService;
 
    public DeveloperExceptionPageMiddlewareImpl(
        RequestDelegate next,
        IOptions<DeveloperExceptionPageOptions> options,
        ILoggerFactory loggerFactory,
        IWebHostEnvironment hostingEnvironment,
        DiagnosticSource diagnosticSource,
        IEnumerable<IDeveloperPageExceptionFilter> filters,
        IMeterFactory meterFactory,
        IOptions<JsonOptions>? jsonOptions = null,
        IProblemDetailsService? problemDetailsService = null)
    {
        ArgumentNullException.ThrowIfNull(next);
        ArgumentNullException.ThrowIfNull(options);
        ArgumentNullException.ThrowIfNull(filters);
 
        _next = next;
        _options = options.Value;
        _logger = loggerFactory.CreateLogger<DeveloperExceptionPageMiddleware>();
        // 如果 DeveloperExceptionPageOptions.FileProvider 为 null，则使用 IWebHostEnvironment.ContentRootFileProvider
        _fileProvider = _options.FileProvider ?? hostingEnvironment.ContentRootFileProvider;
        _diagnosticSource = diagnosticSource;
        _metrics = new DiagnosticsMetrics(meterFactory);
        _exceptionDetailsProvider = new ExceptionDetailsProvider(_fileProvider, _logger, _options.SourceCodeLineCount);
        // 封装末端异常处理方法
        _exceptionHandler = DisplayException;
        _serializationContext = CreateSerializationContext(jsonOptions?.Value);
        _problemDetailsService = problemDetailsService;
        // 反转 IDeveloperPageExceptionFilter 集合构建异常处理委托链
        foreach (var filter in filters.Reverse())
        {
            var nextFilter = _exceptionHandler;
            _exceptionHandler = errorContext => filter.HandleExceptionAsync(errorContext, nextFilter);
        }
    }

    public async Task Invoke(HttpContext context)
    {
        // 尝试捕获后续请求处理器管道中发生的所有未处理异常
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            var exceptionName = ex.GetType().FullName!;

            // 如果异常是客户端主动发起的取消请求
            if ((ex is OperationCanceledException || ex is IOException) && context.RequestAborted.IsCancellationRequested)
            {
                _logger.RequestAbortedException();
                _metrics.RequestException(exceptionName, ExceptionResult.Aborted, handler: null);
 
                // 如果 HTTP 响应尚未开始
                if (!context.Response.HasStarted)
                {
                    // 设置 HTTP 响应状态码为 499
                    // 表示客户端主动发起的取消请求
                    context.Response.StatusCode = StatusCodes.Status499ClientClosedRequest;
                }

                // 直接返回，结束异常处理
                return;
            }

            // 记录日志类别为 "Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware" 的日志
            DiagnosticsTelemetry.ReportUnhandledException(_logger, context, ex);

            // 如果 HTTP 响应已经开始则重新抛出异常，中断后续处理
            if (context.Response.HasStarted)
            {
                _logger.ResponseStartedErrorPageMiddleware();
                _metrics.RequestException(exceptionName, ExceptionResult.Skipped, handler: null);
                throw;
            }
 
            try
            {
                // 清空 HTTP 响应缓冲区
                context.Response.Clear();
 
                // 如果是客户端异常
                if (ex is BadHttpRequestException badHttpRequestException)
                {
                    // 设置 HTTP 响应状态码 4xx
                    context.Response.StatusCode = badHttpRequestException.StatusCode;
                }
                else
                {
                    // 其他异常统一设置 HTTP 响应状态码为 500
                    context.Response.StatusCode = 500;
                }

                // 创建 ErrorContext 开始执行异常处理管道
                await _exceptionHandler(new ErrorContext(context, ex));
 
                const string eventName = "Microsoft.AspNetCore.Diagnostics.UnhandledException";
                if (_diagnosticSource.IsEnabled(eventName))
                {
                    WriteDiagnosticEvent(_diagnosticSource, eventName, new { httpContext = context, exception = ex });
                }
 
                _metrics.RequestException(exceptionName, ExceptionResult.Unhandled, handler: null);
                // 异常处理完成，结束异常处理
                return;
            }
            catch (Exception ex2)
            {
                // 在异常处理阶段如果再次发生异常则不再处理
                _logger.DisplayErrorPageException(ex2);
            }
 
            _metrics.RequestException(exceptionName, ExceptionResult.Unhandled, handler: null);
            // 对于在异常处理阶段发生的异常不做处理，重新抛出异常
            throw;
        }
 
        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026",
            Justification = "The values being passed into Write have the commonly used properties being preserved with DynamicDependency.")]
        static void WriteDiagnosticEvent<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] TValue>(DiagnosticSource diagnosticSource, string name, TValue value)
            => diagnosticSource.Write(name, value);
    }

    // 末端异常处理方法
    private Task DisplayException(ErrorContext errorContext)
    {
        var httpContext = errorContext.HttpContext;
        var headers = httpContext.Request.GetTypedHeaders();
        var acceptHeader = headers.Accept;
 
        // 如果 HTTP 请求头的 Accept 不包含 text/html 媒体类型，则以纯文本内容返回异常信息
        if (acceptHeader == null || !acceptHeader.Any(h => h.IsSubsetOf(_textHtmlMediaType)))
        {
            // 设置 HTTP 响应的媒体类型为 text/plain
            return DisplayExceptionContent(errorContext);
        }

        // 如果 HTTP 请求头的 Accept 包含 text/html 媒体类型
        // 设置 HTTP 响应的媒体类型为 text/html，然后渲染包含详细异常信息的 HTML 页面

        // 如果是编译异常，比如 Razor 页面编译时发生的异常
        // 注意：
        // 被访问的 Razor 页面会先将 .cshtml 模板文件转成某种 C# 代码，然后再使用编译器编译成 IL 指令
        // 这个过程是在运行时动态发生的，可能会发生编译错误
        if (errorContext.Exception is ICompilationException compilationException)
        {
            // 渲染 HTML 页面，显示编译错误信息
            return DisplayCompilationException(httpContext, compilationException);
        }

        // 渲染 HTML 页面，显示其他运行时发生的异常信息
        return DisplayRuntimeException(httpContext, errorContext.Exception);
    }
}
```

## 注册开发者异常页中间件

- DeveloperExceptionPageExtensions

```C#
// 用于提供注册开发者异常页中间件的扩展方法
public static class DeveloperExceptionPageExtensions
{
    // 注册开发者异常页中间件
    public static IApplicationBuilder UseDeveloperExceptionPage(this IApplicationBuilder app)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        app.Properties["analysis.NextMiddlewareName"] = "Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware";
        return app.UseMiddleware<DeveloperExceptionPageMiddlewareImpl>();
    }
    
    // 注册开发者异常页中间件
    // 提供 DeveloperExceptionPageOptions 选项
    public static IApplicationBuilder UseDeveloperExceptionPage(
        this IApplicationBuilder app,
        DeveloperExceptionPageOptions options)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(options);
 
        // 利用 Options.Create<> 静态方法得到 OptionsWrapper<>（实现 IOptions<>）
        app.Properties["analysis.NextMiddlewareName"] = "Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware";
        return app.UseMiddleware<DeveloperExceptionPageMiddlewareImpl>(Options.Create(options));
    }
}
```

## 异常处理器

- IExceptionHandler

```C#
// 异常处理器接口
public interface IExceptionHandler
{
    // 尝试处理异常，可以使用 CancellationToken 来取消异常处理
    // 返回的布尔值代表是否中断后续异常处理
    ValueTask<bool> TryHandleAsync(HttpContext httpContext, Exception exception, CancellationToken cancellationToken);
}
```

- ExceptionHandlerOptions

```C#
// 异常处理器选项
public class ExceptionHandlerOptions
{
    // 异常处理路径
    // 可以使用这个路径重新进入请求处理管道通过 EndpointRoutingMiddleware 中间件匹配 Endpoint 来处理异常
    public PathString ExceptionHandlingPath { get; set; }
 
    // 是否需要利用 IServiceScopeFactory 创建一个新的服务范围来处理异常
    public bool CreateScopeForErrors { get; set; }
 
    // 表示异常处理器
    public RequestDelegate? ExceptionHandler { get; set; }
 
    // 是否允许返回 HTTP 响应状态码为 404
    public bool AllowStatusCode404Response { get; set; }
}
```

- ExceptionHandlerMiddlewareImpl

```C#
// 异常处理器中间件
internal sealed class ExceptionHandlerMiddlewareImpl
{
    // 默认 HTTP 响应状态码为 500
    private const int DefaultStatusCode = StatusCodes.Status500InternalServerError;
 
    private readonly RequestDelegate _next;
    private readonly ExceptionHandlerOptions _options;
    private readonly ILogger _logger;
    private readonly Func<object, Task> _clearCacheHeadersDelegate;
    private readonly DiagnosticListener _diagnosticListener;
    private readonly IExceptionHandler[] _exceptionHandlers;
    private readonly DiagnosticsMetrics _metrics;
    private readonly IProblemDetailsService? _problemDetailsService;
 
    public ExceptionHandlerMiddlewareImpl(
        RequestDelegate next,
        ILoggerFactory loggerFactory,
        IOptions<ExceptionHandlerOptions> options,
        DiagnosticListener diagnosticListener,
        IEnumerable<IExceptionHandler> exceptionHandlers,
        IMeterFactory meterFactory,
        IProblemDetailsService? problemDetailsService = null)
    {
        _next = next;
        _options = options.Value;
        _logger = loggerFactory.CreateLogger<ExceptionHandlerMiddleware>();
        _clearCacheHeadersDelegate = ClearCacheHeaders;
        _diagnosticListener = diagnosticListener;
        _exceptionHandlers = exceptionHandlers as IExceptionHandler[] ?? new List<IExceptionHandler>(exceptionHandlers).ToArray();
        _metrics = new DiagnosticsMetrics(meterFactory);
        _problemDetailsService = problemDetailsService;
 
        // 如果没有通过 ExceptionHandlerOptions.ExceptionHandler 属性配置自定义的异常处理器
        if (_options.ExceptionHandler == null)
        {
            // 如果也没有通过 ExceptionHandlerOptions.ExceptionHandlingPath 属性配置异常处理路径
            if (_options.ExceptionHandlingPath == null)
            {
                // 则必须确保 IProblemDetailsService 服务已注册
                if (problemDetailsService == null)
                {
                    // 没有异常处理逻辑，抛出异常
                    throw new InvalidOperationException(Resources.ExceptionHandlerOptions_NotConfiguredCorrectly);
                }
            }
            else
            {
                // 如果配置了异常处理路径则使用后续请求处理器作为异常处理器
                // 注意：
                // 这里有个前提就是后续请求处理管道中存在 EndpointRoutingMiddleware 中间件
                // 这样才能基于异常处理路径重新匹配新的 Endpoint 来处理异常
                _options.ExceptionHandler = _next;
            }
        }
    }

    public Task Invoke(HttpContext context)
    {
        ExceptionDispatchInfo edi;
 
        // 尝试捕获后续管道中发生的未处理异常
        try
        {
            var task = _next(context);
            // 后续管道的执行没有同步完成
            if (!task.IsCompletedSuccessfully)
            {
                // 转为异步执行
                // 返回一个 Task，用于等待后续请求处理管道的执行结果
                return Awaited(this, context, task);
            }
 
            return Task.CompletedTask;
        }
        catch (Exception exception)
        {
            // 利用 ExceptionDispatchInfo 捕获同步发生的异常并保留堆栈信息
            edi = ExceptionDispatchInfo.Capture(exception);
        }

        // 同步方式开始处理异常
        return HandleException(context, edi);
 
        static async Task Awaited(ExceptionHandlerMiddlewareImpl middleware, HttpContext context, Task task)
        {
            ExceptionDispatchInfo? edi = null;
            try
            {
                await task;
            }
            catch (Exception exception)
            {
                // 利用 ExceptionDispatchInfo 捕获异步发生的异常并保留堆栈信息
                edi = ExceptionDispatchInfo.Capture(exception);
            }

            // 如果发生异常
            if (edi != null)
            {
                // 异步方式处理异常
                await middleware.HandleException(context, edi);
            }
        }
    }

    // 异常处理方法
    private async Task HandleException(HttpContext context, ExceptionDispatchInfo edi)
    {
        // 得到原始异常的类型全名
        var exceptionName = edi.SourceException.GetType().FullName!;

        // 如果异常是客户端主动发起的取消请求
        if ((edi.SourceException is OperationCanceledException || edi.SourceException is IOException) && context.RequestAborted.IsCancellationRequested)
        {
            _logger.RequestAbortedException();
            
            // 如果 HTTP 响应尚未开始则设置响应状态码为 499
            if (!context.Response.HasStarted)
            {
                context.Response.StatusCode = StatusCodes.Status499ClientClosedRequest;
            }
 
            _metrics.RequestException(exceptionName, ExceptionResult.Aborted, handler: null);
            // 直接返回，退出异常处理
            return;
        }

        // 记录日志类别为 "Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware" 的日志
        DiagnosticsTelemetry.ReportUnhandledException(_logger, context, edi.SourceException);
 
        // 如果 HTTP 响应已经开始则重新抛出异常，终止后续处理
        if (context.Response.HasStarted)
        {
            _logger.ResponseStartedErrorHandler();
 
            _metrics.RequestException(exceptionName, ExceptionResult.Skipped, handler: null);
            // 重新抛出异常
            edi.Throw();
        }

        // 保存原始请求路径
        var originalPath = context.Request.Path;
        // 如果配置了异常处理路径，则将请求路径改为异常处理路径，以便后续使用 EndpointRoutingMiddleware 中间件重新匹配 Endpoint 处理异常
        if (_options.ExceptionHandlingPath.HasValue)
        {
            context.Request.Path = _options.ExceptionHandlingPath;
        }
        // 保存原始的 IServiceProvider
        var oldScope = _options.CreateScopeForErrors ? context.RequestServices : null;
        // 确定是否需要利用 IServiceScopeFactory 创建一个新的服务范围
        using var scope = _options.CreateScopeForErrors ? context.RequestServices.GetRequiredService<IServiceScopeFactory>().CreateScope() : null;
 
        try
        {
            if (scope != null)
            {
                // 使用服务范围创建新的 IServiceProvider 并替换 HttpContext 中的原始的 IServiceProvider
                context.RequestServices = scope.ServiceProvider;
            }

            // 创建 ExceptionHandlerFeature 用于保存原始异常、原始请求路径、原始匹配到的 Endpoint 和原始路由值字典
            // 注意：
            // 只有通过 EndpointRoutingMiddleware 中间件才会在此处得到匹配的 Endpoint
            var exceptionHandlerFeature = new ExceptionHandlerFeature()
            {
                Error = edi.SourceException,
                Path = originalPath.Value!,
                Endpoint = context.GetEndpoint(),
                RouteValues = context.Features.Get<IRouteValuesFeature>()?.RouteValues
            };

            // 清空 HTTP 响应缓冲区和匹配到的 Endpoint
            ClearHttpContext(context);

            // 使用特性集合保存 ExceptionHandlerFeature，以便给后续异常处理管道的中间件
            context.Features.Set<IExceptionHandlerFeature>(exceptionHandlerFeature);
            context.Features.Set<IExceptionHandlerPathFeature>(exceptionHandlerFeature);
            // 设置 HTTP 响应状态码为 500
            context.Response.StatusCode = DefaultStatusCode;
            // 只要发生异常就清除 HTTP 响应中的缓存报头，表示无需缓存并使缓存失效
            context.Response.OnStarting(_clearCacheHeadersDelegate, context.Response);
 
            // 用于记录异常处理器的类型全名
            string? handler = null;
            // 用于标记异常已处理
            var handled = false;
            // 遍历 IExceptionHandler 集合中的异常处理器处理异常
            foreach (var exceptionHandler in _exceptionHandlers)
            {
                // 支持客户端主动取消请求中断异常处理
                handled = await exceptionHandler.TryHandleAsync(context, edi.SourceException, context.RequestAborted);
                // 只要当前 IExceptionHandler 异常处理器表示处理了异常，则停止遍历
                if (handled)
                {
                    // 记录当前异常处理器的类型全名
                    handler = exceptionHandler.GetType().FullName;
                    break;
                }
            }
 
            // 如果异常未被任何 IExceptionHandler 异常处理器处理
            if (!handled)
            {
                // 如果 ExceptionHandlerOptions.ExceptionHandler 属性表示的异常处理器存在
                if (_options.ExceptionHandler is not null)
                {
                    // 利用 ExceptionHandlerOptions.ExceptionHandler 属性表示的异常处理器处理异常
                    await _options.ExceptionHandler!(context);
                }
                else
                {
                    // 否则利用 IProblemDetailsService 服务作为异常处理器处理异常
                    handled = await _problemDetailsService!.TryWriteAsync(new()
                    {
                        HttpContext = context,
                        AdditionalMetadata = exceptionHandlerFeature.Endpoint?.Metadata,
                        ProblemDetails = { Status = DefaultStatusCode },
                        Exception = edi.SourceException,
                    });
                    if (handled)
                    {
                        handler = _problemDetailsService.GetType().FullName;
                    }
                }
            }
            // 如果在异常处理阶段没有发生异常，则以下任何情况都可以正常退出异常处理器中间件
            // 1. HTTP 响应已经正常开始
            // 2. 标记异常已处理
            // 3. HTTP 响应状态码不是 404
            // 4. 允许返回 404 状态码的响应
            if (context.Response.HasStarted || handled || context.Response.StatusCode != StatusCodes.Status404NotFound || _options.AllowStatusCode404Response)
            {
                const string eventName = "Microsoft.AspNetCore.Diagnostics.HandledException";
                if (_diagnosticListener.IsEnabled() && _diagnosticListener.IsEnabled(eventName))
                {
                    WriteDiagnosticEvent(_diagnosticListener, eventName, new { httpContext = context, exception = edi.SourceException });
                }
 
                _metrics.RequestException(exceptionName, ExceptionResult.Handled, handler);
                // 直接返回，结束异常处理
                return;
            }
 
            // 在异常处理阶段返回了 404 状态码的响应，表明异常处理器配置错误
            edi = ExceptionDispatchInfo.Capture(new InvalidOperationException($"The exception handler configured on {nameof(ExceptionHandlerOptions)} produced a 404 status response. " +
                $"This {nameof(InvalidOperationException)} containing the original exception was thrown since this is often due to a misconfigured {nameof(ExceptionHandlerOptions.ExceptionHandlingPath)}. " +
                $"If the exception handler is expected to return 404 status responses then set {nameof(ExceptionHandlerOptions.AllowStatusCode404Response)} to true.", edi.SourceException));
        }
        catch (Exception ex2)
        {
            // 通过日志记录在异常处理阶段发生异常，不再做任何处理
            _logger.ErrorHandlerException(ex2);
        }
        finally
        {
            // 恢复原始请求路径
            context.Request.Path = originalPath;
            // 恢复原始的 IServiceProvider
            if (oldScope != null)
            {
                context.RequestServices = oldScope;
            }
        }
 
        _metrics.RequestException(exceptionName, ExceptionResult.Unhandled, handler: null);
        // 利用 ExceptionDispatchInfo 重新抛出原始异常
        edi.Throw();
 
        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026",
            Justification = "The values being passed into Write have the commonly used properties being preserved with DynamicDependency.")]
        static void WriteDiagnosticEvent<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] TValue>(DiagnosticSource diagnosticSource, string name, TValue value)
            => diagnosticSource.Write(name, value);
    }

    // 清除 HTTP 响应缓冲区、匹配到的 Endpoint、路由值字典
    private static void ClearHttpContext(HttpContext context)
    {
        context.Response.Clear();
 
        HttpExtensions.ClearEndpoint(context);
    }
    
    // 设置 HTTP 响应禁用缓存和缓存失效报头
    private static Task ClearCacheHeaders(object state)
    {
        var headers = ((HttpResponse)state).Headers;
        headers.CacheControl = "no-cache,no-store";
        headers.Pragma = "no-cache";
        headers.Expires = "-1";
        headers.ETag = default;
        return Task.CompletedTask;
    }
}
```

## 注册异常处理器中间件

- ExceptionHandlerExtensions

```C#
// 用于提供注册异常处理器中间件的扩展方法
public static class ExceptionHandlerExtensions
{
    // 注册异常处理器中间件
    public static IApplicationBuilder UseExceptionHandler(this IApplicationBuilder app)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        return SetExceptionHandlerMiddleware(app, options: null);
    }
    
    // 注册异常处理器中间件
    // 提供异常处理路径
    public static IApplicationBuilder UseExceptionHandler(this IApplicationBuilder app, string errorHandlingPath)
    {
        ArgumentNullException.ThrowIfNull(app);

        // 提供 ExceptionHandlerOptions 选项
        return app.UseExceptionHandler(new ExceptionHandlerOptions
        {
            ExceptionHandlingPath = new PathString(errorHandlingPath)
        });
    }
    
    // 注册异常处理器中间件
    // 提供异常处理路径和是否需要利用 IServiceScopeFactory 创建一个新的服务范围处理异常
    public static IApplicationBuilder UseExceptionHandler(this IApplicationBuilder app, string errorHandlingPath, bool createScopeForErrors)
    {
        ArgumentNullException.ThrowIfNull(app);

        // 提供 ExceptionHandlerOptions 选项
        return app.UseExceptionHandler(new ExceptionHandlerOptions
        {
            ExceptionHandlingPath = new PathString(errorHandlingPath),
            CreateScopeForErrors = createScopeForErrors
        });
    }
    
    // 注册异常处理器中间件
    // 提供 Action<IApplicationBuilder> 配置注册中间件
    public static IApplicationBuilder UseExceptionHandler(this IApplicationBuilder app, Action<IApplicationBuilder> configure)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(configure);
 
        // 利用 IApplicationBuilder.New 方法创建一个新的 IApplicationBuilder
        var subAppBuilder = app.New();
        // 利用 Action<IApplicationBuilder> 配置注册中间件
        configure(subAppBuilder);
        // 构建 RequestDelegate 请求处理委托链作为异常处理管道
        var exceptionHandlerPipeline = subAppBuilder.Build();
 
        // 提供 ExceptionHandlerOptions 选项
        return app.UseExceptionHandler(new ExceptionHandlerOptions
        {
            ExceptionHandler = exceptionHandlerPipeline
        });
    }
    
    // 注册异常处理器中间件
    // 提供 ExceptionHandlerOptions 选项
    public static IApplicationBuilder UseExceptionHandler(this IApplicationBuilder app, ExceptionHandlerOptions options)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(options);

        // 利用 Options.Create<> 静态方法得到 OptionsWrapper<>（实现 IOptions<>）
        var iOptions = Options.Create(options);
        return SetExceptionHandlerMiddleware(app, iOptions);
    }
    
    // 注册异常处理器中间件核心方法
    private static IApplicationBuilder SetExceptionHandlerMiddleware(IApplicationBuilder app, IOptions<ExceptionHandlerOptions>? options)
    {
        var problemDetailsService = app.ApplicationServices.GetService<IProblemDetailsService>();
 
        app.Properties["analysis.NextMiddlewareName"] = "Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware";
 
        // 如果使用的是 WebApplication 编程模型，此处的 IApplicationBuilder 就是 WebApplication
        if (app.Properties.TryGetValue(RerouteHelper.GlobalRouteBuilderKey, out var routeBuilder) && routeBuilder is not null)
        {
            // 注册 Func<RequestDelegate, RequestDelegate> 形式的原始中间件
            return app.Use(next =>
            {
                var loggerFactory = app.ApplicationServices.GetRequiredService<ILoggerFactory>();
                var diagnosticListener = app.ApplicationServices.GetRequiredService<DiagnosticListener>();
                var exceptionHandlers = app.ApplicationServices.GetRequiredService<IEnumerable<IExceptionHandler>>();
                var meterFactory = app.ApplicationServices.GetRequiredService<IMeterFactory>();
 
                if (options is null)
                {
                    // 尝试利用根容器得到 IOptions<ExceptionHandlerOptions>
                    options = app.ApplicationServices.GetRequiredService<IOptions<ExceptionHandlerOptions>>();
                }

                // 如果配置了异常处理路径但没有配置异常处理器，则需要利用 EndpointRoutingMiddleware 中间件匹配新的 Endpoint 来处理异常
                // 在 WebApplication 编程模型中，EndpointRoutingMiddleware 中间件的注册很可能早于 ExceptionHandlerMiddleware 中间件，所以需要重新构建一条以 EndpointRoutingMiddleware 中间件作为管道头部处理器并连接后续中间件的请求处理管道用于处理异常
                if (!string.IsNullOrEmpty(options.Value.ExceptionHandlingPath) && options.Value.ExceptionHandler is null)
                {
                    // 重新构建一条用于异常处理的管道
                    var newNext = RerouteHelper.Reroute(app, routeBuilder, next);
                    // 将新的请求处理管道用于异常处理
                    options.Value.ExceptionHandler = newNext;
                }
 
                return new ExceptionHandlerMiddlewareImpl(next, loggerFactory, options, diagnosticListener, exceptionHandlers, meterFactory, problemDetailsService).Invoke;
            });
        }

        // IHostBuilder 编程模型下直接注册中间件

        if (options is null)
        {
            return app.UseMiddleware<ExceptionHandlerMiddlewareImpl>();
        }
 
        return app.UseMiddleware<ExceptionHandlerMiddlewareImpl>(options);
    }
}
```

- RerouteHelper

```C#
// 重建路由管道帮助类
internal static class RerouteHelper
{
    internal const string GlobalRouteBuilderKey = "__GlobalEndpointRouteBuilder";
    internal const string UseRoutingKey = "__UseRouting";
    
    // 重新构建以 EndpointRoutingMiddleware 中间件作为管道头部处理器的请求处理管道
    // 此处的 IApplicationBuilder 就是 WebApplication
    internal static RequestDelegate Reroute(IApplicationBuilder app, object routeBuilder, RequestDelegate next)
    {
        if (app.Properties.TryGetValue(UseRoutingKey, out var useRouting) && useRouting is Func<IApplicationBuilder, IApplicationBuilder> useRoutingFunc)
        {
            // 创建一个新的 IApplicationBuilder
            var builder = app.New();
            // 需要以 "__GlobalEndpointRouteBuilder" 为键填充新建的 IApplicationBuilder 中的共享字典，以便在后续调用 UseEndpoints 注册 EndpointMiddleware 中间件时从 IApplicationBuilder.Properties 字典中获取 IEndpointRouteBuilder
            // 注意：
            // // 此处的 IEndpointRouteBuilder 就是 WebApplication
            builder.Properties[GlobalRouteBuilderKey] = routeBuilder;
 
            // 调用 IApplicationBuilder.UseRouting 扩展方法注册 EndpointRoutingMiddleware 中间件
            useRoutingFunc(builder);
 
            // 使用 IApplicationBuilder.Run 扩展方法以短路方式注册后续中间件，因为新建的请求处理管道不需要 404 请求处理器中间件
            builder.Run(next);

            // 构建请求处理管道并返回
            return builder.Build();
        }
 
        return next;
    }
}
```

## 响应状态码页

- StatusCodeContext

```C#
// 响应状态码上下文
public class StatusCodeContext
{
    public StatusCodeContext(HttpContext context, StatusCodePagesOptions options, RequestDelegate next)
    {
        HttpContext = context;
        Options = options;
        Next = next;
    }
 
    public HttpContext HttpContext { get; private set; }

    public StatusCodePagesOptions Options { get; private set; }

    public RequestDelegate Next { get; private set; }
}
```

- StatusCodePageOptions

```C#
// 响应状态码页选项
// 主要用于配置响应状态码页处理器
public class StatusCodePagesOptions
{
    public StatusCodePagesOptions()
    {
        // 配置默认的状态码页处理器
        HandleAsync = async context =>
        {
            var statusCode = context.HttpContext.Response.StatusCode;
            var problemDetailsService = context.HttpContext.RequestServices.GetService<IProblemDetailsService>();

            // 如果没有注册 IProblemDetailsService 服务
            if (problemDetailsService == null ||
                !await problemDetailsService.TryWriteAsync(new() { HttpContext = context.HttpContext, ProblemDetails = { Status = statusCode } }))
            {
                // 以纯文本形式渲染 HTTP 响应的主体内容
                var body = BuildResponseBody(statusCode);
 
                // 设置 HTTP 响应的媒体类型为 text/plain
                context.HttpContext.Response.ContentType = "text/plain";
                // 写入响应内容
                await context.HttpContext.Response.WriteAsync(body);
            }
        };
    }
 
    private static string BuildResponseBody(int httpStatusCode)
    {
        var internetExplorerWorkaround = new string(' ', 500);

        // 得到响应状态码原因短语
        var reasonPhrase = ReasonPhrases.GetReasonPhrase(httpStatusCode);

        // 返回格式化字符串
        return string.Format(CultureInfo.InvariantCulture, "Status Code: {0}{1}{2}{3}",
                                                                httpStatusCode,
                                                                string.IsNullOrWhiteSpace(reasonPhrase) ? "" : "; ",
                                                                reasonPhrase,
                                                                internetExplorerWorkaround);
    }
 
    // 状态码页处理器
    // 因为 StatusCodeContext 是对 HttpContext 的封装，所以状态码页处理器和请求处理器在本质上没有区别
    public Func<StatusCodeContext, Task> HandleAsync { get; set; }
}
```

- StatusCodePagesMiddleware

```C#
// 响应状态码页中间件
public class StatusCodePagesMiddleware
{
    private readonly RequestDelegate _next;
    private readonly StatusCodePagesOptions _options;
 
    public StatusCodePagesMiddleware(RequestDelegate next, IOptions<StatusCodePagesOptions> options)
    {
        _next = next;
        _options = options.Value;
        // 必须存在 StatusCodePagesOptions.HandleAsync 表示的状态码页处理器
        if (_options.HandleAsync == null)
        {
            throw new ArgumentException("Missing options.HandleAsync implementation.");
        }
    }
 
    public async Task Invoke(HttpContext context)
    {
        // 创建 StatusCodePagesFeature 以 IStatusCodePagesFeature 接口的形式保存到 HttpContext 的特性集合中
        var statusCodeFeature = new StatusCodePagesFeature();
        context.Features.Set<IStatusCodePagesFeature>(statusCodeFeature);
        // 尝试得到 Endpoint
        var endpoint = context.GetEndpoint();
        // 如果当前 HttpContext 中没有匹配到的 Endpoint
        // 可能还没有执行 EndpointRoutingMiddleware 中间件，需要设置重新检查标志
        var shouldCheckEndpointAgain = endpoint is null;

        // 检查 Endpoint 的元数据集合中是否包含 ISkipStatusCodePagesMetadata 元数据
        if (HasSkipStatusCodePagesMetadata(endpoint))
        {
            // 将 IStatusCodePagesFeature.Enabled 属性设置为 false，表示不需要执行响应状态码页中间件
            statusCodeFeature.Enabled = false;
        }

        // 执行后续请求处理管道
        // 后续中间件也可以通过设置 IStatusCodePagesFeature.Enabled 属性来标记是否需要执行响应状态码页中间件 
        await _next(context);

        // 检查 IStatusCodePagesFeature.Enabled 决定是否跳过响应状态码页中间件
        if (!statusCodeFeature.Enabled)
        {
            return;
        }

        // 重新检查 Endpoint 的元数据集合中是否包含 ISkipStatusCodePagesMetadata 元数据
        if (shouldCheckEndpointAgain && HasSkipStatusCodePagesMetadata(context.GetEndpoint()))
        {
            return;
        }
 
        // 以下情况也不执行响应状态码页处理器
        // 1. HTTP 响应已经开始
        // 2. 不在 400 - 599 响应状态码范围内
        // 3. 已经设置了 HTTP 响应内容长度
        // 4. 已经设置了 HTTP 响应的媒体类型
        if (context.Response.HasStarted
            || context.Response.StatusCode < 400
            || context.Response.StatusCode >= 600
            || context.Response.ContentLength.HasValue
            || !string.IsNullOrEmpty(context.Response.ContentType))
        {
            return;
        }

        // 创建 StatusCodeContext
        var statusCodeContext = new StatusCodeContext(context, _options, _next);
        // 执行响应状态码页处理器
        await _options.HandleAsync(statusCodeContext);
    }
    
    // 检查 Endpoint 的终结点元数据集合中是否包含了 ISkipStatusCodePagesMetadata 类型的元数据
    private static bool HasSkipStatusCodePagesMetadata(Endpoint? endpoint)
    {
        var skipStatusCodePageMetadata = endpoint?.Metadata.GetMetadata<ISkipStatusCodePagesMetadata>();
 
        return skipStatusCodePageMetadata is not null;
    }
}
```

## 注册响应状态码页中间件

- StatusCodePagesExtensions

```C#
// 用于提供注册响应状态码页中间件的扩展方法
public static class StatusCodePagesExtensions
{
    // 注册响应状态码页中间件
    public static IApplicationBuilder UseStatusCodePages(this IApplicationBuilder app)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        return app.UseMiddleware<StatusCodePagesMiddleware>();
    }

    // 注册响应状态码页中间件
    // 提供 StatusCodePagesOptions 选项
    public static IApplicationBuilder UseStatusCodePages(this IApplicationBuilder app, StatusCodePagesOptions options)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(options);
 
        return app.UseMiddleware<StatusCodePagesMiddleware>(Options.Create(options));
    }
 
    // 注册响应状态码页中间件
    // 提供 Func<StatusCodeContext, Task> 响应状态码页处理器
    public static IApplicationBuilder UseStatusCodePages(this IApplicationBuilder app, Func<StatusCodeContext, Task> handler)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(handler);
 
        return app.UseStatusCodePages(new StatusCodePagesOptions
        {
            HandleAsync = handler
        });
    }
 
    // 注册响应状态码页中间件
    // 提供用于格式化响应内容的字符串，可以包含一个 "{0}" 占位符，用于格式化字符串时替换为具体的 HTTP 响应状态码，以及一个媒体类型字符串
    public static IApplicationBuilder UseStatusCodePages(this IApplicationBuilder app, string contentType, string bodyFormat)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        return app.UseStatusCodePages(context =>
        {
            var body = string.Format(CultureInfo.InvariantCulture, bodyFormat, context.HttpContext.Response.StatusCode);
            context.HttpContext.Response.ContentType = contentType;
            return context.HttpContext.Response.WriteAsync(body);
        });
    }

    // 注册响应状态码页中间件
    // 提供 Action<IApplicationBuilder> 配置，用于注册中间件并构建状态码页处理器管道
    public static IApplicationBuilder UseStatusCodePages(this IApplicationBuilder app, Action<IApplicationBuilder> configuration)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        var builder = app.New();
        configuration(builder);
        var tangent = builder.Build();
        // 在状态码页处理器内部调用构建的请求处理管道处理状态码页
        return app.UseStatusCodePages(context => tangent(context.HttpContext));
    }
 
    // 注册响应状态码页中间件
    // 提供用于客户端重定向路径的格式化字符串，可以包含一个 "{0}" 占位符，用于格式化字符串时替换为具体的 HTTP 响应状态码
    public static IApplicationBuilder UseStatusCodePagesWithRedirects(this IApplicationBuilder app, string locationFormat)
    {
        ArgumentNullException.ThrowIfNull(app);

        // 使用 "~" 开头的重定向路径格式化字符串（相对路径）
        // 最终会使用当前 HTTP 请求的 HttpContext.Request.PathBase 作为基础路径拼接成完整的重定向路径
        if (locationFormat.StartsWith('~'))
        {
            // 需要去掉路径中的 "~" 字符
            locationFormat = locationFormat.Substring(1);
            return app.UseStatusCodePages(context =>
            {
                var location = string.Format(CultureInfo.InvariantCulture, locationFormat, context.HttpContext.Response.StatusCode);
                // 响应状态码为 302 的临时重定向
                context.HttpContext.Response.Redirect(context.HttpContext.Request.PathBase + location);
                return Task.CompletedTask;
            });
        }
        else
        {
            return app.UseStatusCodePages(context =>
            {
                var location = string.Format(CultureInfo.InvariantCulture, locationFormat, context.HttpContext.Response.StatusCode);
                // 响应状态码为 302 的临时重定向
                context.HttpContext.Response.Redirect(location);
                return Task.CompletedTask;
            });
        }
    }
 
    // 注册响应状态码页中间件
    // 提供用于服务端重定向路径的格式化字符串，可以包含一个 "{0}" 占位符，用于替换为具体的 HTTP 响应状态码，并且可以额外提供一个查询字符串，可以包含一个 "{0}" 占位符，用于替换为具体的 HTTP 响应状态码
    public static IApplicationBuilder UseStatusCodePagesWithReExecute(
        this IApplicationBuilder app,
        string pathFormat,
        string? queryFormat = null)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        // 如果使用的是 WebApplication 编程模型，此处的 IApplicationBuilder 就是 WebApplication
        if (app.Properties.TryGetValue(RerouteHelper.GlobalRouteBuilderKey, out var routeBuilder) && routeBuilder is not null)
        {
            // 注册 Func<RequestDelegate, RequestDelegate> 形式的原始中间件
            return app.Use(next =>
            {
                // 在 WebApplication 编程模型中，EndpointRoutingMiddleware 中间件的注册很可能早于 StatusCodePagesMiddleware 中间件，所以需要重新构建一条以 EndpointRoutingMiddleware 中间件作为管道头部处理器并连接后续中间件的请求处理管道用于处理状态码页
                var newNext = RerouteHelper.Reroute(app, routeBuilder, next);
                return new StatusCodePagesMiddleware(next,
                    Options.Create(new StatusCodePagesOptions() { HandleAsync = CreateHandler(pathFormat, queryFormat, newNext) })).Invoke;
            });
        }

        // IHostBuilder 编程模型下直接注册中间件
 
        return app.UseStatusCodePages(CreateHandler(pathFormat, queryFormat));
    }
 
    // 创建响应状态码页处理器
    private static Func<StatusCodeContext, Task> CreateHandler(string pathFormat, string? queryFormat, RequestDelegate? next = null)
    {
        var handler = async (StatusCodeContext context) =>
        {
            var originalStatusCode = context.HttpContext.Response.StatusCode;

            // 利用格式化字符串和具体的 HTTP 响应状态码构建新的请求路径和查询字符串
            var newPath = new PathString(
                string.Format(CultureInfo.InvariantCulture, pathFormat, originalStatusCode));
            var formatedQueryString = queryFormat == null ? null :
                string.Format(CultureInfo.InvariantCulture, queryFormat, originalStatusCode);
            var newQueryString = queryFormat == null ? QueryString.Empty : new QueryString(formatedQueryString);

            // 保存原始的请求路径和查询字符串
            var originalPath = context.HttpContext.Request.Path;
            var originalQueryString = context.HttpContext.Request.QueryString;
 
            // 保存原始的路由值字典
            var routeValuesFeature = context.HttpContext.Features.Get<IRouteValuesFeature>();
 
            // 创建 StatusCodeReExecuteFeature 以 IStatusCodeReExecuteFeature 接口的形式保存到 HttpContext 的特性集合中
            // 保存的内容包括原始的请求路径、原始的查询字符串、原始的 HTTP 响应状态码、原始匹配到的 Endpoint 和原始路由值字典
            context.HttpContext.Features.Set<IStatusCodeReExecuteFeature>(new StatusCodeReExecuteFeature()
            {
                OriginalPathBase = context.HttpContext.Request.PathBase.Value!,
                OriginalPath = originalPath.Value!,
                OriginalQueryString = originalQueryString.HasValue ? originalQueryString.Value : null,
                OriginalStatusCode = originalStatusCode,
                Endpoint = context.HttpContext.GetEndpoint(),
                RouteValues = routeValuesFeature?.RouteValues
            });
 
            // 清除 HTTP 响应缓冲区、匹配到的 Endpoint、路由值字典
            HttpExtensions.ClearEndpoint(context.HttpContext);

            // 设置新的请求路径和查询字符串
            context.HttpContext.Request.Path = newPath;
            context.HttpContext.Request.QueryString = newQueryString;
            try
            {
                if (next is not null)
                {
                    // 执行请求处理管道处理状态码页
                    await next(context.HttpContext);
                }
                else
                {
                    await context.Next(context.HttpContext);
                }
            }
            finally
            {
                // 恢复原始的请求路径、原始的查询字符串
                context.HttpContext.Request.QueryString = originalQueryString;
                context.HttpContext.Request.Path = originalPath;
                // 从 HttpContext 的特性集合中移除 IStatusCodeReExecuteFeature 特性
                context.HttpContext.Features.Set<IStatusCodeReExecuteFeature?>(null);
            }
        };
 
        return handler;
    }
}
```
