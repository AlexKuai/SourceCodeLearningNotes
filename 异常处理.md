# 异常处理

## 源码涉及的核心类型

- ErrorContext  
- DeveloperExceptionPageOptions  
- IDeveloperPageExceptionFilter  
- DeveloperExceptionPageMiddlewareImpl  
- DeveloperExceptionPageExtensions  
- IExceptionHandler  
- ExceptionHandlerOptions  
- ExceptionHandlerMiddlewareImpl  
- ExceptionHandlerExtensions  
- RerouteHelper  
- StatusCodeContext  
- StatusCodePageOptions  
- StatusCodePagesMiddlewareImpl  
- StatusCodePagesExtensions  

## 开发者异常页

- ErrorContext

```C#
// 错误上下文
// 本质是对 HttpContext 和 Exception 的封装
public class ErrorContext
{
    public ErrorContext(HttpContext httpContext, Exception exception)
    {
        HttpContext = httpContext ?? throw new ArgumentNullException(nameof(httpContext));
        Exception = exception ?? throw new ArgumentNullException(nameof(exception));
    }

    public HttpContext HttpContext { get; }
 
    public Exception Exception { get; }
}
```

- DeveloperExceptionPageOptions

```C#
// 开发者异常页选项
public class DeveloperExceptionPageOptions
{
    public DeveloperExceptionPageOptions()
    {
        // 默认显示异常发生位置的前后相邻源代码行数为 6
        // 即包含异常发生位置的源码前 6 行和后 6 行代码
        SourceCodeLineCount = 6;
    }
 
    // 显示异常发生位置的前后源代码行数
    public int SourceCodeLineCount { get; set; }
 
    // 文件提供器
    // 用于提供源代码文件所在的目录
    public IFileProvider? FileProvider { get; set; }
}
```

- IDeveloperPageExceptionFilter

```C#
// 开发者异常页过滤器
// 在渲染错误页之前，可以对异常做一些额外的处理
public interface IDeveloperPageExceptionFilter
{
    // 处理异常
    Task HandleExceptionAsync(ErrorContext errorContext, Func<ErrorContext, Task> next);
}
```

- DeveloperExceptionPageMiddlewareImpl

```C#
// 开发者异常页中间件
internal class DeveloperExceptionPageMiddlewareImpl
{
    private readonly RequestDelegate _next;
    private readonly DeveloperExceptionPageOptions _options;
    private readonly ILogger _logger;
    private readonly IFileProvider _fileProvider;
    private readonly DiagnosticSource _diagnosticSource;
    private readonly DiagnosticsMetrics _metrics;
    private readonly ExceptionDetailsProvider _exceptionDetailsProvider;
    private readonly Func<ErrorContext, Task> _exceptionHandler;
    // 开发者异常页的响应内容媒体类型为 text/html
    private static readonly MediaTypeHeaderValue _textHtmlMediaType = new MediaTypeHeaderValue("text/html");
    private readonly ExtensionsExceptionJsonContext _serializationContext;
    private readonly IProblemDetailsService? _problemDetailsService;
 
    public DeveloperExceptionPageMiddlewareImpl(
        RequestDelegate next,
        IOptions<DeveloperExceptionPageOptions> options,
        ILoggerFactory loggerFactory,
        IWebHostEnvironment hostingEnvironment,
        DiagnosticSource diagnosticSource,
        IEnumerable<IDeveloperPageExceptionFilter> filters,
        IMeterFactory meterFactory,
        IOptions<JsonOptions>? jsonOptions = null,
        IProblemDetailsService? problemDetailsService = null)
    {
        ArgumentNullException.ThrowIfNull(next);
        ArgumentNullException.ThrowIfNull(options);
        ArgumentNullException.ThrowIfNull(filters);
 
        _next = next;
        _options = options.Value;
        _logger = loggerFactory.CreateLogger<DeveloperExceptionPageMiddleware>();
        // 如果 DeveloperExceptionPageOptions.FileProvider 为 null，则使用 IWebHostEnvironment.ContentRootFileProvider
        _fileProvider = _options.FileProvider ?? hostingEnvironment.ContentRootFileProvider;
        _diagnosticSource = diagnosticSource;
        _metrics = new DiagnosticsMetrics(meterFactory);
        _exceptionDetailsProvider = new ExceptionDetailsProvider(_fileProvider, _logger, _options.SourceCodeLineCount);
        // 配置默认的 Func<ErrorContext, Task> 异常处理器
        _exceptionHandler = DisplayException;
        _serializationContext = CreateSerializationContext(jsonOptions?.Value);
        _problemDetailsService = problemDetailsService;
        // 反转 IDeveloperPageExceptionFilter 集合
        // 将默认的 Func<ErrorContext, Task> 异常处理器作为管道的末端处理器，构建 Func<ErrorContext, Task> 异常处理委托链
        // 由于末端处理器才会真正渲染开发者异常页的 HTML 页面，所有可以通过自定义的 IDeveloperPageExceptionFilter 进行自定义处理并跳过末端处理器
        foreach (var filter in filters.Reverse())
        {
            var nextFilter = _exceptionHandler;
            _exceptionHandler = errorContext => filter.HandleExceptionAsync(errorContext, nextFilter);
        }
    }

    public async Task Invoke(HttpContext context)
    {
        // 尝试捕获后续请求处理器管道中发生的所有未处理异常
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            var exceptionName = ex.GetType().FullName!;

            // 如果异常是客户端主动发起的取消请求
            if ((ex is OperationCanceledException || ex is IOException) && context.RequestAborted.IsCancellationRequested)
            {
                _logger.RequestAbortedException();
                _metrics.RequestException(exceptionName, ExceptionResult.Aborted, handler: null);
 
                // 如果 HTTP 响应尚未开始
                if (!context.Response.HasStarted)
                {
                    // 设置 HTTP 响应状态码为 499
                    context.Response.StatusCode = StatusCodes.Status499ClientClosedRequest;
                }

                // 直接返回，中断后续异常处理
                return;
            }

            // 记录日志类别为 "Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware" 的日志
            DiagnosticsTelemetry.ReportUnhandledException(_logger, context, ex);

            // 如果 HTTP 响应已经开始则重新抛出异常，中断后续处理
            if (context.Response.HasStarted)
            {
                _logger.ResponseStartedErrorPageMiddleware();
                _metrics.RequestException(exceptionName, ExceptionResult.Skipped, handler: null);
                throw;
            }
 
            try
            {
                // 清除响应缓冲区
                context.Response.Clear();
 
                // 如果是 BadHttpRequestException 异常（表示 400 - 499 状态码）
                if (ex is BadHttpRequestException badHttpRequestException)
                {
                    // 利用 BadHttpRequestException.StatusCode 设置 HTTP 响应状态码
                    context.Response.StatusCode = badHttpRequestException.StatusCode;
                }
                else
                {
                    // 所有其他异常统一设置 HTTP 响应状态码为 500
                    context.Response.StatusCode = 500;
                }

                // 开始执行异常处理管道
                await _exceptionHandler(new ErrorContext(context, ex));
 
                const string eventName = "Microsoft.AspNetCore.Diagnostics.UnhandledException";
                if (_diagnosticSource.IsEnabled(eventName))
                {
                    WriteDiagnosticEvent(_diagnosticSource, eventName, new { httpContext = context, exception = ex });
                }
 
                _metrics.RequestException(exceptionName, ExceptionResult.Unhandled, handler: null);
                // 异常处理完成，正常返回
                return;
            }
            catch (Exception ex2)
            {
                // 在异常处理阶段发生异常则不再处理
                // 记录日志后重新抛出异常
                _logger.DisplayErrorPageException(ex2);
            }
 
            _metrics.RequestException(exceptionName, ExceptionResult.Unhandled, handler: null);
            throw;
        }
 
        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026",
            Justification = "The values being passed into Write have the commonly used properties being preserved with DynamicDependency.")]
        static void WriteDiagnosticEvent<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] TValue>(DiagnosticSource diagnosticSource, string name, TValue value)
            => diagnosticSource.Write(name, value);
    }

    // 异常处理方法
    // 用于创建管道末端的 Func<ErrorContext, Task> 异常处理器
    private Task DisplayException(ErrorContext errorContext)
    {
        var httpContext = errorContext.HttpContext;
        var headers = httpContext.Request.GetTypedHeaders();
        var acceptHeader = headers.Accept;
 
        // 如果 HTTP 请求的 Accept 头不包含 text/html 媒体类型，则直接以纯文本内容返回异常信息
        if (acceptHeader == null || !acceptHeader.Any(h => h.IsSubsetOf(_textHtmlMediaType)))
        {
            // 设置 HTTP 响应内容媒体类型为 text/plain
            return DisplayExceptionContent(errorContext);
        }

        // 如果 HTTP 请求的 Accept 头包含 text/html 媒体类型
        // 设置 HTTP 响应内容媒体类型为 text/html，然后渲染开发者异常页的 HTML 页面

        // 如果是编译异常，比如 Razor 页面编译时发生的异常
        // 注意：
        // 被访问的 Razor 页面对应的 .cshtml 模板文件会被先转换为某种 C# 代码，然后再利用编译器编译成 IL 指令
        // 这个过程是在运行时动态发生的，所以可能会发生编译错误
        if (errorContext.Exception is ICompilationException compilationException)
        {
            // 显示编译错误信息（渲染 HTML 页面）
            return DisplayCompilationException(httpContext, compilationException);
        }

        // 显示其他运行时发生的异常信息（渲染 HTML 页面）
        return DisplayRuntimeException(httpContext, errorContext.Exception);
    }
}
```

## 注册开发者异常页中间件

- DeveloperExceptionPageExtensions

```C#
// 用于提供注册开发者异常页中间件的扩展方法
public static class DeveloperExceptionPageExtensions
{
    // 注册开发者异常页中间件
    public static IApplicationBuilder UseDeveloperExceptionPage(this IApplicationBuilder app)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        app.Properties["analysis.NextMiddlewareName"] = "Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware";
        return app.UseMiddleware<DeveloperExceptionPageMiddlewareImpl>();
    }
    
    // 注册开发者异常页中间件
    // 提供 DeveloperExceptionPageOptions 选项
    public static IApplicationBuilder UseDeveloperExceptionPage(
        this IApplicationBuilder app,
        DeveloperExceptionPageOptions options)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(options);
 
        // 利用 Options.Create<> 静态方法得到 OptionsWrapper<>（实现 IOptions<>）
        app.Properties["analysis.NextMiddlewareName"] = "Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware";
        return app.UseMiddleware<DeveloperExceptionPageMiddlewareImpl>(Options.Create(options));
    }
}
```

## 异常处理器

- IExceptionHandler

```C#
// 异常处理器接口
public interface IExceptionHandler
{
    // 尝试处理异常
    // 可以使用 CancellationToken 来取消异常处理
    // 返回的布尔值代表是否中断后续异常处理
    ValueTask<bool> TryHandleAsync(HttpContext httpContext, Exception exception, CancellationToken cancellationToken);
}
```

- ExceptionHandlerOptions

```C#
// 异常处理器选项
public class ExceptionHandlerOptions
{
    // 异常处理路径
    // 可以通过这个路径（路由模板）重新进入请求处理管道并利用 EndpointRoutingMiddleware 中间件匹配新的 Endpoint 来处理异常
    public PathString ExceptionHandlingPath { get; set; }
 
    // 是否需要利用 IServiceScopeFactory 创建一个新的服务范围
    // 由于会再次开始进入请求处理管道，所以可能需要创建一个新的服务范围
    public bool CreateScopeForErrors { get; set; }
 
    // 表示异常处理器
    public RequestDelegate? ExceptionHandler { get; set; }
 
    // 是否允许返回 HTTP 响应状态码为 404
    public bool AllowStatusCode404Response { get; set; }
}
```

- ExceptionHandlerMiddlewareImpl

```C#
// 异常处理器中间件
internal sealed class ExceptionHandlerMiddlewareImpl
{
    // 默认 HTTP 响应状态码为 500
    private const int DefaultStatusCode = StatusCodes.Status500InternalServerError;
 
    private readonly RequestDelegate _next;
    private readonly ExceptionHandlerOptions _options;
    private readonly ILogger _logger;
    private readonly Func<object, Task> _clearCacheHeadersDelegate;
    private readonly DiagnosticListener _diagnosticListener;
    private readonly IExceptionHandler[] _exceptionHandlers;
    private readonly DiagnosticsMetrics _metrics;
    private readonly IProblemDetailsService? _problemDetailsService;
 
    public ExceptionHandlerMiddlewareImpl(
        RequestDelegate next,
        ILoggerFactory loggerFactory,
        IOptions<ExceptionHandlerOptions> options,
        DiagnosticListener diagnosticListener,
        IEnumerable<IExceptionHandler> exceptionHandlers,
        IMeterFactory meterFactory,
        IProblemDetailsService? problemDetailsService = null)
    {
        _next = next;
        _options = options.Value;
        _logger = loggerFactory.CreateLogger<ExceptionHandlerMiddleware>();
        _clearCacheHeadersDelegate = ClearCacheHeaders;
        _diagnosticListener = diagnosticListener;
        _exceptionHandlers = exceptionHandlers as IExceptionHandler[] ?? new List<IExceptionHandler>(exceptionHandlers).ToArray();
        _metrics = new DiagnosticsMetrics(meterFactory);
        _problemDetailsService = problemDetailsService;
 
        // 如果没有通过 ExceptionHandlerOptions.ExceptionHandler 属性配置自定义的异常处理器
        if (_options.ExceptionHandler == null)
        {
            // 也没有通过 ExceptionHandlerOptions.ExceptionHandlingPath 属性配置异常处理路径
            // 则抛出 InvalidOperationException
            if (_options.ExceptionHandlingPath == null)
            {
                if (problemDetailsService == null)
                {
                    throw new InvalidOperationException(Resources.ExceptionHandlerOptions_NotConfiguredCorrectly);
                }
            }
            else
            {
                // 配置了异常处理路径则使用原有的后续请求处理器作为异常处理器
                // 利用 EndpointRoutingMiddleware 中间件匹配新的 Endpoint 来处理异常
                _options.ExceptionHandler = _next;
            }
        }
    }

    public Task Invoke(HttpContext context)
    {
        ExceptionDispatchInfo edi;
 
        // 尝试捕获后续请求处理器管道中发生的所有未处理异常
        try
        {
            var task = _next(context);
            // 后续管道的执行没有同步完成
            if (!task.IsCompletedSuccessfully)
            {
                // 转为异步执行
                // 返回一个 Task，用于等待后续请求处理管道的执行结果
                return Awaited(this, context, task);
            }
 
            return Task.CompletedTask;
        }
        catch (Exception exception)
        {
            // 利用 ExceptionDispatchInfo 捕获同步发生的异常
            edi = ExceptionDispatchInfo.Capture(exception);
        }

        // 同步方式开始处理异常
        return HandleException(context, edi);
 
        static async Task Awaited(ExceptionHandlerMiddlewareImpl middleware, HttpContext context, Task task)
        {
            ExceptionDispatchInfo? edi = null;
            try
            {
                await task;
            }
            catch (Exception exception)
            {
                // 利用 ExceptionDispatchInfo 捕获同步发生的异常
                edi = ExceptionDispatchInfo.Capture(exception);
            }
 
            if (edi != null)
            {
                // 异步方式开始处理异常
                await middleware.HandleException(context, edi);
            }
        }
    }

    // 异常处理方法
    private async Task HandleException(HttpContext context, ExceptionDispatchInfo edi)
    {
        // 从 ExceptionDispatchInfo 得到原始异常的类型全名
        var exceptionName = edi.SourceException.GetType().FullName!;

        // 如果异常是客户端主动发起的取消请求
        if ((edi.SourceException is OperationCanceledException || edi.SourceException is IOException) && context.RequestAborted.IsCancellationRequested)
        {
            _logger.RequestAbortedException();
            
            // 如果 HTTP 响应尚未开始则设置 HTTP 响应状态码为 499
            if (!context.Response.HasStarted)
            {
                context.Response.StatusCode = StatusCodes.Status499ClientClosedRequest;
            }
 
            _metrics.RequestException(exceptionName, ExceptionResult.Aborted, handler: null);
            // 直接返回，中断后续异常处理
            return;
        }

        // 记录日志类别为 "Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware" 的日志
        DiagnosticsTelemetry.ReportUnhandledException(_logger, context, edi.SourceException);
 
        // 如果 HTTP 响应已经开始则重新抛出异常，中断后续处理
        if (context.Response.HasStarted)
        {
            _logger.ResponseStartedErrorHandler();
 
            _metrics.RequestException(exceptionName, ExceptionResult.Skipped, handler: null);
            // 重新抛出异常
            edi.Throw();
        }

        // 保存原始请求路径
        var originalPath = context.Request.Path;
        // 如果配置了异常处理路径，则将请求路径改为异常处理路径
        if (_options.ExceptionHandlingPath.HasValue)
        {
            context.Request.Path = _options.ExceptionHandlingPath;
        }
        // 保存原始的 IServiceProvider
        var oldScope = _options.CreateScopeForErrors ? context.RequestServices : null;
        // 确定是否需要利用 IServiceScopeFactory 创建一个新的服务范围
        using var scope = _options.CreateScopeForErrors ? context.RequestServices.GetRequiredService<IServiceScopeFactory>().CreateScope() : null;
 
        try
        {
            if (scope != null)
            {
                // 利用新的 IServiceProvider 替换 HttpContext 中的原始的 IServiceProvider
                context.RequestServices = scope.ServiceProvider;
            }

            // 创建 ExceptionHandlerFeature（实现 IExceptionHandlerPathFeature 和 IExceptionHandlerFeature）
            // 保存原始异常、原始请求路径、原始匹配到的 Endpoint 和原始路由值字典
            var exceptionHandlerFeature = new ExceptionHandlerFeature()
            {
                Error = edi.SourceException,
                Path = originalPath.Value!,
                Endpoint = context.GetEndpoint(),
                RouteValues = context.Features.Get<IRouteValuesFeature>()?.RouteValues
            };

            // 清除响应缓冲区和匹配到的 Endpoint
            ClearHttpContext(context);

            // 利用 IExceptionHandlerFeature 将 ExceptionHandlerFeature 添加到 HttpContext 的特性集合中
            // 利用 IExceptionHandlerPathFeature 将 ExceptionHandlerFeature 添加到 HttpContext 的特性集合中
            // 提供给后续异常处理管道的中间件
            context.Features.Set<IExceptionHandlerFeature>(exceptionHandlerFeature);
            context.Features.Set<IExceptionHandlerPathFeature>(exceptionHandlerFeature);
            // 设置 HTTP 响应状态码为 500
            context.Response.StatusCode = DefaultStatusCode;
            // 清除 HTTP 响应中的缓存报头
            context.Response.OnStarting(_clearCacheHeadersDelegate, context.Response);
 
            string? handler = null;
            // 异常已处理标记
            var handled = false;
            // 优先使用 IExceptionHandler 集合中的异常处理器处理异常
            foreach (var exceptionHandler in _exceptionHandlers)
            {
                handled = await exceptionHandler.TryHandleAsync(context, edi.SourceException, context.RequestAborted);
                // 只要有 IExceptionHandler 异常处理器表示处理了异常，则停止遍历
                if (handled)
                {
                    handler = exceptionHandler.GetType().FullName;
                    break;
                }
            }
 
            // 如果 IExceptionHandler 集合中的异常处理器都没有处理异常
            if (!handled)
            {
                // 使用 ExceptionHandlerOptions.ExceptionHandler 属性配置的异常处理器处理异常
                if (_options.ExceptionHandler is not null)
                {
                    await _options.ExceptionHandler!(context);
                }
                else
                {
                    handled = await _problemDetailsService!.TryWriteAsync(new()
                    {
                        HttpContext = context,
                        AdditionalMetadata = exceptionHandlerFeature.Endpoint?.Metadata,
                        ProblemDetails = { Status = DefaultStatusCode },
                        Exception = edi.SourceException,
                    });
                    if (handled)
                    {
                        handler = _problemDetailsService.GetType().FullName;
                    }
                }
            }
            // 如果在异常处理阶段没有发生异常，则以下情况正常退出异常处理器中间件
            // 1. HTTP 响应已经正常开始
            // 2. 标记异常已处理
            // 3. HTTP 响应状态码不是 404
            // 4. 允许返回 404 状态码的响应
            if (context.Response.HasStarted || handled || context.Response.StatusCode != StatusCodes.Status404NotFound || _options.AllowStatusCode404Response)
            {
                const string eventName = "Microsoft.AspNetCore.Diagnostics.HandledException";
                if (_diagnosticListener.IsEnabled() && _diagnosticListener.IsEnabled(eventName))
                {
                    WriteDiagnosticEvent(_diagnosticListener, eventName, new { httpContext = context, exception = edi.SourceException });
                }
 
                _metrics.RequestException(exceptionName, ExceptionResult.Handled, handler);
                return;
            }
 
            edi = ExceptionDispatchInfo.Capture(new InvalidOperationException($"The exception handler configured on {nameof(ExceptionHandlerOptions)} produced a 404 status response. " +
                $"This {nameof(InvalidOperationException)} containing the original exception was thrown since this is often due to a misconfigured {nameof(ExceptionHandlerOptions.ExceptionHandlingPath)}. " +
                $"If the exception handler is expected to return 404 status responses then set {nameof(ExceptionHandlerOptions.AllowStatusCode404Response)} to true.", edi.SourceException));
        }
        catch (Exception ex2)
        {
            // 在异常处理阶段发生异常则不再处理
            _logger.ErrorHandlerException(ex2);
        }
        finally
        {
            // 恢复原始请求路径
            context.Request.Path = originalPath;
            // 恢复原始的 IServiceProvider
            // 因为创建原始 IServiceProvider 的 IServiceScope 依赖注册的 HttpResponse.RegisterForDisposeAsync 方法释放
            if (oldScope != null)
            {
                context.RequestServices = oldScope;
            }
        }
 
        _metrics.RequestException(exceptionName, ExceptionResult.Unhandled, handler: null);
        // 如果在异常处理阶段发生异常则会运行到这里
        // 利用 ExceptionDispatchInfo 重新抛出原始异常
        edi.Throw();
 
        [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026",
            Justification = "The values being passed into Write have the commonly used properties being preserved with DynamicDependency.")]
        static void WriteDiagnosticEvent<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] TValue>(DiagnosticSource diagnosticSource, string name, TValue value)
            => diagnosticSource.Write(name, value);
    }

    // 清除响应缓冲区、匹配到的 Endpoint、路由值字典
    private static void ClearHttpContext(HttpContext context)
    {
        context.Response.Clear();
 
        HttpExtensions.ClearEndpoint(context);
    }
    
    // 清除 HTTP 响应中的缓存报头
    private static Task ClearCacheHeaders(object state)
    {
        var headers = ((HttpResponse)state).Headers;
        headers.CacheControl = "no-cache,no-store";
        headers.Pragma = "no-cache";
        headers.Expires = "-1";
        headers.ETag = default;
        return Task.CompletedTask;
    }
}
```

## 注册异常处理器中间件

- ExceptionHandlerExtensions

```C#
// 用于提供注册异常处理器中间件的扩展方法
public static class ExceptionHandlerExtensions
{
    // 注册异常处理器中间件
    public static IApplicationBuilder UseExceptionHandler(this IApplicationBuilder app)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        return SetExceptionHandlerMiddleware(app, options: null);
    }
    
    // 注册异常处理器中间件
    // 提供异常处理路径
    public static IApplicationBuilder UseExceptionHandler(this IApplicationBuilder app, string errorHandlingPath)
    {
        ArgumentNullException.ThrowIfNull(app);

        // 提供 ExceptionHandlerOptions 选项
        return app.UseExceptionHandler(new ExceptionHandlerOptions
        {
            ExceptionHandlingPath = new PathString(errorHandlingPath)
        });
    }
    
    // 注册异常处理器中间件
    // 提供异常处理路径和是否需要利用 IServiceScopeFactory 创建一个新的服务范围处理异常
    public static IApplicationBuilder UseExceptionHandler(this IApplicationBuilder app, string errorHandlingPath, bool createScopeForErrors)
    {
        ArgumentNullException.ThrowIfNull(app);

        // 提供 ExceptionHandlerOptions 选项
        return app.UseExceptionHandler(new ExceptionHandlerOptions
        {
            ExceptionHandlingPath = new PathString(errorHandlingPath),
            CreateScopeForErrors = createScopeForErrors
        });
    }
    
    // 注册异常处理器中间件
    // 提供 Action<IApplicationBuilder> 配置注册中间件
    public static IApplicationBuilder UseExceptionHandler(this IApplicationBuilder app, Action<IApplicationBuilder> configure)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(configure);
 
        // 利用 IActionResultBuilder.New 方法创建一个新的 IApplicationBuilder
        var subAppBuilder = app.New();
        // 利用 Action<IApplicationBuilder> 配置注册中间件
        configure(subAppBuilder);
        // 构建 RequestDelegate 请求处理委托链作为异常处理管道
        var exceptionHandlerPipeline = subAppBuilder.Build();
 
        // 提供 ExceptionHandlerOptions 选项
        return app.UseExceptionHandler(new ExceptionHandlerOptions
        {
            ExceptionHandler = exceptionHandlerPipeline
        });
    }
    
    // 注册异常处理器中间件
    // 提供 ExceptionHandlerOptions 选项
    public static IApplicationBuilder UseExceptionHandler(this IApplicationBuilder app, ExceptionHandlerOptions options)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(options);

        // 利用 Options.Create<> 静态方法得到 OptionsWrapper<>（实现 IOptions<>）
        var iOptions = Options.Create(options);
        return SetExceptionHandlerMiddleware(app, iOptions);
    }
    
    // 注册异常处理器中间件
    private static IApplicationBuilder SetExceptionHandlerMiddleware(IApplicationBuilder app, IOptions<ExceptionHandlerOptions>? options)
    {
        var problemDetailsService = app.ApplicationServices.GetService<IProblemDetailsService>();
 
        app.Properties["analysis.NextMiddlewareName"] = "Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware";
 
        // 如果使用的是 Minimal API 编程模型，则此处判断为 true
        if (app.Properties.TryGetValue(RerouteHelper.GlobalRouteBuilderKey, out var routeBuilder) && routeBuilder is not null)
        {
            // 注册 Func<RequestDelegate, RequestDelegate> 形式的原始中间件
            return app.Use(next =>
            {
                var loggerFactory = app.ApplicationServices.GetRequiredService<ILoggerFactory>();
                var diagnosticListener = app.ApplicationServices.GetRequiredService<DiagnosticListener>();
                var exceptionHandlers = app.ApplicationServices.GetRequiredService<IEnumerable<IExceptionHandler>>();
                var meterFactory = app.ApplicationServices.GetRequiredService<IMeterFactory>();
 
                if (options is null)
                {
                    options = app.ApplicationServices.GetRequiredService<IOptions<ExceptionHandlerOptions>>();
                }

                // 如果配置了异常处理路径并且没有配置异常处理器
                // 则需要利用 EndpointRoutingMiddleware 中间件匹配新的 Endpoint 来处理异常
                // 在 Minimal API 编程模型中，EndpointRoutingMiddleware 中间件的注册可能早于 ExceptionHandlerMiddleware 中间件
                // 所以需要重新构建一条包含 EndpointRoutingMiddleware 中间件的请求处理管道用于处理异常
                if (!string.IsNullOrEmpty(options.Value.ExceptionHandlingPath) && options.Value.ExceptionHandler is null)
                {
                    // 注册新的 EndpointRoutingMiddleware 中间件，并以此作为头部处理器并连接后续中间件构建新的请求处理管道
                    var newNext = RerouteHelper.Reroute(app, routeBuilder, next);
                    // 将新的请求处理管道作为异常处理器
                    options.Value.ExceptionHandler = newNext;
                }
 
                return new ExceptionHandlerMiddlewareImpl(next, loggerFactory, options, diagnosticListener, exceptionHandlers, meterFactory, problemDetailsService).Invoke;
            });
        }

        if (options is null)
        {
            return app.UseMiddleware<ExceptionHandlerMiddlewareImpl>();
        }
 
        return app.UseMiddleware<ExceptionHandlerMiddlewareImpl>(options);
    }
}
```

- RerouteHelper

```C#
// 重建路由管道帮助类
internal static class RerouteHelper
{
    internal const string GlobalRouteBuilderKey = "__GlobalEndpointRouteBuilder";
    internal const string UseRoutingKey = "__UseRouting";
    
    // 重新构建包含 EndpointRoutingMiddleware 中间件的请求处理管道
    // 此处的 IApplicationBuilder 和 IEndpointRouteBuilder 其实就是 WebApplication
    internal static RequestDelegate Reroute(IApplicationBuilder app, object routeBuilder, RequestDelegate next)
    {
        if (app.Properties.TryGetValue(UseRoutingKey, out var useRouting) && useRouting is Func<IApplicationBuilder, IApplicationBuilder> useRoutingFunc)
        {
            // 创建一个新的 IApplicationBuilder
            var builder = app.New();
            // 需要以 "__GlobalEndpointRouteBuilder" 为键填充新建的 IApplicationBuilder 中的共享字典
            builder.Properties[GlobalRouteBuilderKey] = routeBuilder;
 
            // 调用 IApplicationBuilder.UseRouting 扩展方法注册 EndpointRoutingMiddleware 中间件
            useRoutingFunc(builder);
 
            // 使用 IApplicationBuilder.Run 扩展方法以短路方式（管道中不需要包含 404 请求处理器）注册后续中间件
            builder.Run(next);

            // 构建请求处理管道并返回
            return builder.Build();
        }
 
        return next;
    }
}
```

## 响应状态码页

- StatusCodeContext

```C#
// 响应状态码上下文
public class StatusCodeContext
{
    public StatusCodeContext(HttpContext context, StatusCodePagesOptions options, RequestDelegate next)
    {
        HttpContext = context;
        Options = options;
        Next = next;
    }
 
    public HttpContext HttpContext { get; private set; }

    public StatusCodePagesOptions Options { get; private set; }

    public RequestDelegate Next { get; private set; }
}
```

- StatusCodePageOptions

```C#
// 响应状态码页选项
// 主要用于配置响应状态码页处理器
public class StatusCodePagesOptions
{
    public StatusCodePagesOptions()
    {
        HandleAsync = async context =>
        {
            var statusCode = context.HttpContext.Response.StatusCode;
            var problemDetailsService = context.HttpContext.RequestServices.GetService<IProblemDetailsService>();

            // 如果没有注册 IProblemDetailsService 服务
            if (problemDetailsService == null ||
                !await problemDetailsService.TryWriteAsync(new() { HttpContext = context.HttpContext, ProblemDetails = { Status = statusCode } }))
            {
                // 渲染默认的 HTTP 响应主体内容
                var body = BuildResponseBody(statusCode);
 
                // 设置 HTTP 响应内容媒体类型为 text/plain
                context.HttpContext.Response.ContentType = "text/plain";
                await context.HttpContext.Response.WriteAsync(body);
            }
        };
    }
 
    private static string BuildResponseBody(int httpStatusCode)
    {
        var internetExplorerWorkaround = new string(' ', 500);

        // 得到响应状态码原因短语
        var reasonPhrase = ReasonPhrases.GetReasonPhrase(httpStatusCode);

        // 返回格式化字符串
        return string.Format(CultureInfo.InvariantCulture, "Status Code: {0}{1}{2}{3}",
                                                                httpStatusCode,
                                                                string.IsNullOrWhiteSpace(reasonPhrase) ? "" : "; ",
                                                                reasonPhrase,
                                                                internetExplorerWorkaround);
    }
 
    // 状态码页处理器
    // 因为 StatusCodeContext 是对 HttpContext 的封装
    // 所以状态码页处理器和请求处理器没有本质上的区别
    public Func<StatusCodeContext, Task> HandleAsync { get; set; }
}
```

- StatusCodePagesMiddlewareImpl

```C#
// 响应状态码页中间件
public class StatusCodePagesMiddleware
{
    private readonly RequestDelegate _next;
    private readonly StatusCodePagesOptions _options;
 
    public StatusCodePagesMiddleware(RequestDelegate next, IOptions<StatusCodePagesOptions> options)
    {
        _next = next;
        _options = options.Value;
        // 必须存在 StatusCodePagesOptions.HandleAsync 表示的状态码页处理器
        if (_options.HandleAsync == null)
        {
            throw new ArgumentException("Missing options.HandleAsync implementation.");
        }
    }
 
    public async Task Invoke(HttpContext context)
    {
        // 创建 StatusCodePagesFeature 以 IStatusCodePagesFeature 接口的形式保存到 HttpContext 的特性集合中
        var statusCodeFeature = new StatusCodePagesFeature();
        context.Features.Set<IStatusCodePagesFeature>(statusCodeFeature);
        // 尝试得到 Endpoint
        var endpoint = context.GetEndpoint();
        // 如果当前 HttpContext 中没有匹配到的 Endpoint
        // 可能还没有执行到 EndpointRoutingMiddleware 中间件，需要设置重新检查标志
        var shouldCheckEndpointAgain = endpoint is null;

        // 检查 Endpoint 的元数据集合中是否包含 ISkipStatusCodePagesMetadata 元数据
        if (HasSkipStatusCodePagesMetadata(endpoint))
        {
            // 将 IStatusCodePagesFeature.Enabled 属性设置为 false
            // 表示不需要执行响应状态码页中间件
            statusCodeFeature.Enabled = false;
        }

        // 执行后续请求处理管道
        // 后续中间件可以通过设置 IStatusCodePagesFeature.Enabled 属性来标记是否需要执行响应状态码页中间件 
        await _next(context);

        // 标记跳过响应状态码页中间件
        if (!statusCodeFeature.Enabled)
        {
            return;
        }

        // 重新检查 Endpoint 的元数据集合中是否包含 ISkipStatusCodePagesMetadata 元数据
        if (shouldCheckEndpointAgain && HasSkipStatusCodePagesMetadata(context.GetEndpoint()))
        {
            return;
        }
 
        // 以下情况也不执行响应状态码页中间件
        // 1. HTTP 响应已经开始
        // 2. 不在 400 - 599 响应状态码范围内
        // 3. 已经设置了 HTTP 响应内容长度
        // 4. 已经设置了 HTTP 响应内容媒体类型
        if (context.Response.HasStarted
            || context.Response.StatusCode < 400
            || context.Response.StatusCode >= 600
            || context.Response.ContentLength.HasValue
            || !string.IsNullOrEmpty(context.Response.ContentType))
        {
            return;
        }

        // 创建 StatusCodeContext
        var statusCodeContext = new StatusCodeContext(context, _options, _next);
        // 执行响应状态码页处理器
        await _options.HandleAsync(statusCodeContext);
    }
    
    // 检查 Endpoint 是的元数据集合中是否包含 ISkipStatusCodePagesMetadata 元数据
    private static bool HasSkipStatusCodePagesMetadata(Endpoint? endpoint)
    {
        var skipStatusCodePageMetadata = endpoint?.Metadata.GetMetadata<ISkipStatusCodePagesMetadata>();
 
        return skipStatusCodePageMetadata is not null;
    }
}
```

## 注册响应状态码页中间件

- StatusCodePagesExtensions

```C#
// 用于提供注册响应状态码页中间件的扩展方法
public static class StatusCodePagesExtensions
{
    // 注册响应状态码页中间件
    public static IApplicationBuilder UseStatusCodePages(this IApplicationBuilder app)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        return app.UseMiddleware<StatusCodePagesMiddleware>();
    }

    // 注册响应状态码页中间件
    // 提供 StatusCodePagesOptions 选项
    public static IApplicationBuilder UseStatusCodePages(this IApplicationBuilder app, StatusCodePagesOptions options)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(options);
 
        return app.UseMiddleware<StatusCodePagesMiddleware>(Options.Create(options));
    }
 
    // 注册响应状态码页中间件
    // 提供 Func<StatusCodeContext, Task> 响应状态码页处理器
    public static IApplicationBuilder UseStatusCodePages(this IApplicationBuilder app, Func<StatusCodeContext, Task> handler)
    {
        ArgumentNullException.ThrowIfNull(app);
        ArgumentNullException.ThrowIfNull(handler);
 
        return app.UseStatusCodePages(new StatusCodePagesOptions
        {
            HandleAsync = handler
        });
    }
 
    // 注册响应状态码页中间件
    // 提供响应内容媒体类型和格式化字符串用于 HTTP 响应主体内容的渲染
    public static IApplicationBuilder UseStatusCodePages(this IApplicationBuilder app, string contentType, string bodyFormat)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        return app.UseStatusCodePages(context =>
        {
            var body = string.Format(CultureInfo.InvariantCulture, bodyFormat, context.HttpContext.Response.StatusCode);
            context.HttpContext.Response.ContentType = contentType;
            return context.HttpContext.Response.WriteAsync(body);
        });
    }

    // 注册响应状态码页中间件
    // 提供 Action<IApplicationBuilder> 配置，用于注册中间件并构建响应状态码页处理器
    public static IApplicationBuilder UseStatusCodePages(this IApplicationBuilder app, Action<IApplicationBuilder> configuration)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        var builder = app.New();
        configuration(builder);
        var tangent = builder.Build();
        return app.UseStatusCodePages(context => tangent(context.HttpContext));
    }
 
    // 注册响应状态码页中间件
    // 提供用于客户端重定向路径的格式化字符串，可以包含一个 "{0}" 占位符，用于格式化字符串时替换为具体的 HTTP 响应状态码
    public static IApplicationBuilder UseStatusCodePagesWithRedirects(this IApplicationBuilder app, string locationFormat)
    {
        ArgumentNullException.ThrowIfNull(app);

        // 可以使用 "~" 开头的重定向路径（相对路径）格式化字符串
        // 最终会使用当前 HTTP 请求的基础路径（PathBase）拼接成完整的重定向路径
        if (locationFormat.StartsWith('~'))
        {
            locationFormat = locationFormat.Substring(1);
            return app.UseStatusCodePages(context =>
            {
                var location = string.Format(CultureInfo.InvariantCulture, locationFormat, context.HttpContext.Response.StatusCode);
                // 响应状态码为 302 的临时重定向
                context.HttpContext.Response.Redirect(context.HttpContext.Request.PathBase + location);
                return Task.CompletedTask;
            });
        }
        else
        {
            return app.UseStatusCodePages(context =>
            {
                var location = string.Format(CultureInfo.InvariantCulture, locationFormat, context.HttpContext.Response.StatusCode);
                // 响应状态码为 302 的临时重定向
                context.HttpContext.Response.Redirect(location);
                return Task.CompletedTask;
            });
        }
    }
 
    // 注册响应状态码页中间件
    // 提供用于服务端重定向路径的格式化字符串，可以包含一个 "{0}" 占位符，用于替换为具体的 HTTP 响应状态码
    // 可以额外提供一个查询字符串，可以包含一个 "{0}" 占位符，用于替换为具体的 HTTP 响应状态码
    public static IApplicationBuilder UseStatusCodePagesWithReExecute(
        this IApplicationBuilder app,
        string pathFormat,
        string? queryFormat = null)
    {
        ArgumentNullException.ThrowIfNull(app);
 
        // 如果使用的是 Minimal API 编程模型，则此处判断为 true
        if (app.Properties.TryGetValue(RerouteHelper.GlobalRouteBuilderKey, out var routeBuilder) && routeBuilder is not null)
        {
            // 注册 Func<RequestDelegate, RequestDelegate> 形式的原始中间件
            return app.Use(next =>
            {
                // 注册新的 EndpointRoutingMiddleware 中间件，并以此作为头部处理器连接后续中间件构建新的请求处理管道
                var newNext = RerouteHelper.Reroute(app, routeBuilder, next);
                return new StatusCodePagesMiddleware(next,
                    Options.Create(new StatusCodePagesOptions() { HandleAsync = CreateHandler(pathFormat, queryFormat, newNext) })).Invoke;
            });
        }
 
        return app.UseStatusCodePages(CreateHandler(pathFormat, queryFormat));
    }
 
    // 创建响应状态码页处理器
    private static Func<StatusCodeContext, Task> CreateHandler(string pathFormat, string? queryFormat, RequestDelegate? next = null)
    {
        var handler = async (StatusCodeContext context) =>
        {
            var originalStatusCode = context.HttpContext.Response.StatusCode;

            // 利用格式化字符串和具体的 HTTP 响应状态码构建新的请求路径和查询字符串
            var newPath = new PathString(
                string.Format(CultureInfo.InvariantCulture, pathFormat, originalStatusCode));
            var formatedQueryString = queryFormat == null ? null :
                string.Format(CultureInfo.InvariantCulture, queryFormat, originalStatusCode);
            var newQueryString = queryFormat == null ? QueryString.Empty : new QueryString(formatedQueryString);

            // 保存原始的请求路径和查询字符串
            var originalPath = context.HttpContext.Request.Path;
            var originalQueryString = context.HttpContext.Request.QueryString;
 
            // 保存原始的路由值字典
            var routeValuesFeature = context.HttpContext.Features.Get<IRouteValuesFeature>();
 
            // 创建 StatusCodeReExecuteFeature 以 IStatusCodeReExecuteFeature 接口的形式保存到 HttpContext 的特性集合中
            // 保存原始的请求路径、原始的查询字符串、原始的 HTTP 响应状态码、原始匹配到的 Endpoint 和原始路由值字典
            context.HttpContext.Features.Set<IStatusCodeReExecuteFeature>(new StatusCodeReExecuteFeature()
            {
                OriginalPathBase = context.HttpContext.Request.PathBase.Value!,
                OriginalPath = originalPath.Value!,
                OriginalQueryString = originalQueryString.HasValue ? originalQueryString.Value : null,
                OriginalStatusCode = originalStatusCode,
                Endpoint = context.HttpContext.GetEndpoint(),
                RouteValues = routeValuesFeature?.RouteValues
            });
 
            // 清除响应缓冲区、匹配到的 Endpoint、路由值字典
            HttpExtensions.ClearEndpoint(context.HttpContext);

            // 设置新的请求路径和查询字符串
            context.HttpContext.Request.Path = newPath;
            context.HttpContext.Request.QueryString = newQueryString;
            try
            {
                if (next is not null)
                {
                    // 执行请求处理管道
                    await next(context.HttpContext);
                }
                else
                {
                    await context.Next(context.HttpContext);
                }
            }
            finally
            {
                // 恢复原始的请求路径、原始的查询字符串
                context.HttpContext.Request.QueryString = originalQueryString;
                context.HttpContext.Request.Path = originalPath;
                // 从 HttpContext 的特性集合中移除 IStatusCodeReExecuteFeature 特性
                context.HttpContext.Features.Set<IStatusCodeReExecuteFeature?>(null);
            }
        };
 
        return handler;
    }
}
```
