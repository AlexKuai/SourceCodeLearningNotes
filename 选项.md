## 源码涉及的核心类型
- IOptions\<\>  
- IOptionsSnapshot\<\>  
- IOptionsMonitor\<\>  
- UnnamedOptionsManager\<\>  
- OptionsManager\<\>  
- OptionsMonitor\<\>  
- IOptionsMonitorCache\<\>  
- OptionsCache\<\>  
- IOptionsFactory\<\>  
- OptionsFactory\<\>  
- IConfigureOptions\<\>  
- IConfigureNamedOptions\<\>  
- IPostConfigureOptions\<\>  
- IValidateOptions\<\>  
- ConfigureOptions\<\>  
- ConfigureNamedOptions\<\>  
- ConfigureNamedOptions\<,\>  
- PostConfigureOptions\<\>  
- PostConfigureOptions\<,\>  
- ValidateOptions\<\>  
- ValidateOptions\<,\>  
- ConfigurationChangeTokenSource\<\>  
- NamedConfigureFromConfigurationOptions\<\>  
- OptionsServiceCollectionExtensions  
- OptionsBuilder\<\>  
- OptionsConfigurationServiceCollectionExtensions  

## Options 模型

- IOptions\<\>  
```C#
// 选项管理者的抽象表示
// 在注册服务时，IOptions<> 的服务注册生命周期为 Singlton
public interface IOptions<out TOptions> where TOptions : class
{
    // 得到选项实例
    // 采用未命名（空字符串命名）的配置来配置选项
    TOptions Value { get; }
}
```

- IOptionsSnapshot\<\>  
```C#
// 选项快照管理者的抽象表示
// 在注册服务时，IOptionsSnapshot<> 的服务注册生命周期为 Scoped
public interface IOptionsSnapshot<out TOptions> : IOptions<TOptions> where TOptions : class
{
    // 得到选项实例
    // 采用命名的配置来配置选项
    TOptions Get(string? name);
}
```

- IOptionsMonitor\<\>
```C#
// 选项监控管理者的抽象表示
// 在注册服务时，IOptionsMonitor<> 的服务注册生命周期为 Singlton
// 一般用来监控选项数据源属于文件类型配置的变动情况，并更新选项实例
public interface IOptionsMonitor<out TOptions>
{
    // 得到选项实例
    // 采用未命名（空字符串命名）的配置来配置选项
    TOptions CurrentValue { get; }

    // 采用命名的配置来配置选项
    TOptions Get(string? name);
    
    // 根据文件配置源的变动令牌发出回调
    IDisposable? OnChange(Action<TOptions, string?> listener);
}
```

- UnnamedOptionsManager\<\>  
```C#
// IOptions<> 的默认实现
internal sealed class UnnamedOptionsManager<TOptions> : IOptions<TOptions> where TOptions : class
{
    // 选项的配置工厂
    private readonly IOptionsFactory<TOptions> _factory;
    // 同步锁
    private volatile object? _syncObj;
    // 由于存在多个线程并发获取选项实例的可以
    // 在 _value 的读写前后插入内存屏障，阻止屏障两侧的指令重排
    // 并且读取一定是从内存中读取，写入一定是立即覆写内存中的值
    private volatile TOptions? _value;

    // 通过依赖注入的方式注入选项配置工厂
    public UnnamedOptionsManager(IOptionsFactory<TOptions> factory) => _factory = factory;

    // 通过属性得到选项实例
    public TOptions Value
    {
        get
        {
            // 如果选项实例已经创建（非 null），则直接返回
            if (_value is TOptions value)
            {
                return value;
            }

            // 利用选项配置工厂创建唯一的配置选项实例、
            // 使用 CAS 原子操作保证选项实例只被创建一次（可能出现多个线程并发访问的情况）
            lock (_syncObj ?? Interlocked.CompareExchange(ref _syncObj, new object(), null) ?? _syncObj)
            {
                // 使用未命名的配置来配置选项
                return _value ??= _factory.Create(Options.DefaultName);
            }
        }
    }
}
```

- OptionsManager\<\>  
```C#
// IOptionsSnapshot<> 默认实现，并且同时实现了 IOptions<>
public class OptionsManager<TOptions> :
        IOptions<TOptions>,
        IOptionsSnapshot<TOptions>
        where TOptions : class
{
    // 选项的配置工厂
    private readonly IOptionsFactory<TOptions> _factory;
    // 缓存选项实例
    // 基于快照的选项获取，一般都是通过传递命名的方式调用 IOptionsSnapshot<>.Get 方法得到选项实例
    // 所以可以针对不同名称缓存对应的选项实例
    private readonly OptionsCache<TOptions> _cache = new OptionsCache<TOptions>();

    // 通过依赖注入的方式注入选项配置工厂
    public OptionsManager(IOptionsFactory<TOptions> factory)
    {
        _factory = factory;
    }

    // 调用属性获取选项实例
    // 本质是传递未命名（空字符串命名）的方式调用 Get 方法
    public TOptions Value => Get(Options.DefaultName);

    // 传递命名的方式调用 Get 方法
    public virtual TOptions Get(string? name)
    {
        // 如果 name 为 null，则使用未命名（空字符串命名）方式
        name ??= Options.DefaultName;

        // 尝试从缓存中查找对应名称的选项实例，如果未找到，则通过选项配置工厂创建
        // 缓存内部只使用了 ConcurrentDictionary<,> 并发集合来解决可能发生的并发情况
        // 此处不使用更高效的同步方式的原因是，IOptionsSnapshot<> 的服务注册生命周期为 Scoped
        // 而在 ASP.NET Core 中 Scoped 生命周期代表单次请求的范围
        // 所以建立在单次请求的前提下，选项实例的创建使用简单的并发集合即可
        if (!_cache.TryGetValue(name, out TOptions? options))
        {
            IOptionsFactory<TOptions> localFactory = _factory;
            string localName = name;
            options = _cache.GetOrAdd(name, () => localFactory.Create(localName));
        }

        return options;
    }
}
```

- OptionsMonitor\<\>  
```C#
// IOptionsMonitor<> 的默认实现
public class OptionsMonitor<TOptions> :
        IOptionsMonitor<TOptions>,
        IDisposable
        where TOptions : class
{
    // 缓存选项实例
    // 基于选项监控的选项获取，一般都是通过传递命名的方式调用 IOptionsMonitor<>.Get 方法得到选项实例
    // 所以可以针对不同名称缓存对应的选项实例
    private readonly IOptionsMonitorCache<TOptions> _cache;
    // 选项的配置工厂
    private readonly IOptionsFactory<TOptions> _factory;
    // ChangeTokenRegistration<> 对象集合
    // 从 IConfiguration.GetReloadToken 方法得到 IChangeToken，并注册回调得到 ChangeTokenRegistration<>（实现 IDisposable）
    // 选项监控方式获取的选项实例一般都来源于文件配置源（FileConfigurationSource）
    // 每个文件配置源都可以利用 IFileProvider.Watch 方式所得到的 IChangeToken 来监控文件，并在文件发生变动的情况下发出回到
    private readonly List<IDisposable> _registrations = new List<IDisposable>();
    // 外部注册选项对应的配置源发生改变时的回调
    internal event Action<TOptions, string>? _onChange;

    // 通过依赖注入的方式注入选项配置工厂、选项变动令牌源、选项缓存
    public OptionsMonitor(IOptionsFactory<TOptions> factory, IEnumerable<IOptionsChangeTokenSource<TOptions>> sources, IOptionsMonitorCache<TOptions> cache)
    {
        _factory = factory;
        _cache = cache;

        void RegisterSource(IOptionsChangeTokenSource<TOptions> source)
        {
            // 通过调用 IOptionsChangeTokenSource<>.GetChangeToken 方法得到 IChangeToken，并注册回调得到 ChangeTokenRegistration<>
            // 利用命名作为回调的状态参数
            IDisposable registration = ChangeToken.OnChange(
                      source.GetChangeToken,
                      InvokeChanged,
                      source.Name);

            _registrations.Add(registration);
        }

        // 依赖注入方式解析 IEnumerable<> 服务类型时内部最终会分配一个数组对象
        // 这样可以在内部不用分配一个 Enumerator 对象
        if (sources is IOptionsChangeTokenSource<TOptions>[] sourcesArray)
        {
            foreach (IOptionsChangeTokenSource<TOptions> source in sourcesArray)
            {
                RegisterSource(source);
            }
        }
        else
        {
            foreach (IOptionsChangeTokenSource<TOptions> source in sources)
            {
                RegisterSource(source);
            }
        }
    }

    // 针对 IOptionsChangeTokenSource<>.GetChangeToken 方法返回的每个 IChangeToken
    // 注册配置源发生变动时候的回调
    private void InvokeChanged(string? name)
    {
        name ??= Options.DefaultName;
        _cache.TryRemove(name);
        TOptions options = Get(name);
        _onChange?.Invoke(options, name);
    }

    // 调用属性获取选项实例
    // 本质是传递未命名（空字符串命名）的方式调用 Get 方法
    public TOptions CurrentValue
    {
        get => Get(Options.DefaultName);
    }

    // 传递命名的方式调用 Get 方法
    public virtual TOptions Get(string? name)
    {
        // optionsCache 不是 OptionsCache<> 类型
        // 不能向前兼容 .NETStandard 2.1 的目标框架会采用闭包方式使用 localName 和 localFactory
        if (_cache is not OptionsCache<TOptions> optionsCache)
        {
            // 如果 name 为 null，则使用未命名（空字符串命名）方式
            string localName = name ?? Options.DefaultName;
            IOptionsFactory<TOptions> localFactory = _factory;
            return _cache.GetOrAdd(localName, () => localFactory.Create(localName));
        }

        // 能够向前兼容 .NETStandard 2.1 的目标框架都会执行此分支
        // OptionsCache<> 内部会根据 name 是否为 null 使用命名或未命名（空字符串命名）方式获取选项实例
        return optionsCache.GetOrAdd(name, static (name, factory) => factory.Create(name), _factory);
    }

    // 注册监听配置源发生变动后的回调
    // 可以注册多个回调（委托链）
    // 使用 ChangeTrackerDisposable 封装 Action 回调，便于外部通过保存 IDisposable 并可以通过调用 Dispose 方法取消 Action 回调
    public IDisposable OnChange(Action<TOptions, string> listener)
    {
        var disposable = new ChangeTrackerDisposable(this, listener);
        _onChange += disposable.OnChange;
        return disposable;
    }

    // 注销所有针对配置源发生变动的监听
    public void Dispose()
    {
        foreach (IDisposable registration in _registrations)
        {
            registration.Dispose();
        }

        _registrations.Clear();
    }

    // Action 回调的包装类型，实现 IDisposable
    // 可以利用 IDisposable.Dispose 方法取消 Action 回调
    internal sealed class ChangeTrackerDisposable : IDisposable
    {
        private readonly Action<TOptions, string> _listener;
        private readonly OptionsMonitor<TOptions> _monitor;

        public ChangeTrackerDisposable(OptionsMonitor<TOptions> monitor, Action<TOptions, string> listener)
        {
            _listener = listener;
            _monitor = monitor;
        }

        public void OnChange(TOptions options, string name) => _listener.Invoke(options, name);

        public void Dispose() => _monitor._onChange -= OnChange;
    }
}
```

- IOptionsMonitorCache\<\>  
```C#
// 选项缓存的抽象表示
public interface IOptionsMonitorCache<TOptions>
       where TOptions : class
{
    TOptions GetOrAdd(string? name, Func<TOptions> createOptions);

    bool TryAdd(string? name, TOptions options);

    bool TryRemove(string? name);

    void Clear();
}
```

- OptionsCache\<\>  
```C#
// IOptionsMonitorCache<> 的默认实现
public class OptionsCache<TOptions> :
        IOptionsMonitorCache<TOptions>
        where TOptions : class
{
    private readonly ConcurrentDictionary<string, Lazy<TOptions>> _cache = new ConcurrentDictionary<string, Lazy<TOptions>>(concurrencyLevel: 1, capacity: 31, StringComparer.Ordinal);

    public void Clear() => _cache.Clear();

    public virtual TOptions GetOrAdd(string? name, Func<TOptions> createOptions)
    {
        ThrowHelper.ThrowIfNull(createOptions);

        name ??= Options.DefaultName;
        Lazy<TOptions> value;

#if NET || NETSTANDARD2_1
        value = _cache.GetOrAdd(name, static (name, createOptions) => new Lazy<TOptions>(createOptions), createOptions);
#else
            if (!_cache.TryGetValue(name, out value))
            {
                // 创建 Lazy 传递的是工厂委托
                value = _cache.GetOrAdd(name, new Lazy<TOptions>(createOptions));
            }
#endif

        return value.Value;
    }

    internal TOptions GetOrAdd<TArg>(string? name, Func<string, TArg, TOptions> createOptions, TArg factoryArgument)
    {
#if NET || NETSTANDARD2_1
        if (GetType() != typeof(OptionsCache<TOptions>))
#endif
        {
            // 不能向前兼容 .NETStandard 2.1 的目标框架会采用闭包方式使用 localName、localCreateOptions、localFactoryArgument
            string? localName = name;
            Func<string, TArg, TOptions> localCreateOptions = createOptions;
            TArg localFactoryArgument = factoryArgument;
            return GetOrAdd(name, () => localCreateOptions(localName ?? Options.DefaultName, localFactoryArgument));
        }

#if NET || NETSTANDARD2_1
        // 创建 Lazy 传递的是已经由选项配置工厂创建的选项实例
        return _cache.GetOrAdd(
            name ?? Options.DefaultName,
            static (name, arg) => new Lazy<TOptions>(arg.createOptions(name, arg.factoryArgument)), (createOptions, factoryArgument)).Value;
#endif
    }

    internal bool TryGetValue(string? name, [MaybeNullWhen(false)] out TOptions options)
    {
        if (_cache.TryGetValue(name ?? Options.DefaultName, out Lazy<TOptions>? lazy))
        {
            options = lazy.Value;
            return true;
        }

        options = default;
        return false;
    }

    public virtual bool TryAdd(string? name, TOptions options)
    {
        ThrowHelper.ThrowIfNull(options);

        return _cache.TryAdd(name ?? Options.DefaultName, new Lazy<TOptions>(
#if !(NET || NETSTANDARD2_1)
                () =>
#endif
            options));
    }

    public virtual bool TryRemove(string? name) =>
        _cache.TryRemove(name ?? Options.DefaultName, out _);
}
```

- IOptionsFactory\<\>  
```C#
public interface IOptionsFactory<TOptions>
        where TOptions : class
{
    // 根据传递的命名创建选项实例
    TOptions Create(string name);
}
```

- OptionsFactory\<\>  
```C#
// 
public class OptionsFactory<TOptions> :
        IOptionsFactory<TOptions>
        where TOptions : class
{
    // 选项预配置数组
    // 可以理解为预配置
    private readonly IConfigureOptions<TOptions>[] _setups;
    // 选项后配置数组
    // 可以理解为预配置后的进一步配置
    private readonly IPostConfigureOptions<TOptions>[] _postConfigures;
    // 选项验证配置数组
    // 可以理解为配置后验证选项的处理
    private readonly IValidateOptions<TOptions>[] _validations;

    // 通过依赖注入方式注入 3 种选项配置集合
    // 不使用选项验证配置
    public OptionsFactory(IEnumerable<IConfigureOptions<TOptions>> setups, IEnumerable<IPostConfigureOptions<TOptions>> postConfigures) : this(setups, postConfigures, validations: Array.Empty<IValidateOptions<TOptions>>())
    { }

    // 通过依赖注入方式注入 3 种选项配置集合
    // 此构造函数会被依赖注入框架选为最优构造函数
    public OptionsFactory(IEnumerable<IConfigureOptions<TOptions>> setups, IEnumerable<IPostConfigureOptions<TOptions>> postConfigures, IEnumerable<IValidateOptions<TOptions>> validations)
    {
        _setups = setups as IConfigureOptions<TOptions>[] ?? new List<IConfigureOptions<TOptions>>(setups).ToArray();
        _postConfigures = postConfigures as IPostConfigureOptions<TOptions>[] ?? new List<IPostConfigureOptions<TOptions>>(postConfigures).ToArray();
        _validations = validations as IValidateOptions<TOptions>[] ?? new List<IValidateOptions<TOptions>>(validations).ToArray();
    }

    // 根据命名创建选项实例
    public TOptions Create(string name)
    {
        TOptions options = CreateInstance(name);
        // 遍历所有选项预配置
        foreach (IConfigureOptions<TOptions> setup in _setups)
        {
            // 优先使用命名的选项配置
            if (setup is IConfigureNamedOptions<TOptions> namedSetup)
            {
                namedSetup.Configure(name, options);
            }
            else if (name == Options.DefaultName)
            {
                setup.Configure(options);
            }
        }
        // 遍历所有选项后配置
        foreach (IPostConfigureOptions<TOptions> post in _postConfigures)
        {
            post.PostConfigure(name, options);
        }
        
        // 如果存在选项验证配置
        if (_validations.Length > 0)
        {
            var failures = new List<string>();
            foreach (IValidateOptions<TOptions> validate in _validations)
            {
                ValidateOptionsResult result = validate.Validate(name, options);
                // 收集验证过程中失败的结果
                if (result is not null && result.Failed)
                {
                    failures.AddRange(result.Failures);
                }
            }
            // 如果存在验证失败情况，则抛出 OptionsValidationException
            if (failures.Count > 0)
            {
                throw new OptionsValidationException(name, typeof(TOptions), failures);
            }
        }

        return options;
    }

    // 反射方式创建实例
    // TOptions 类型必须存在无参构造函数
    // 此处实现值得商榷？
    // 既然已经建立在 TOptions 类型必须存在无参构造函数这个前提，只要将泛型约束为 where TOptions : new()
    // 就可以直接使用使用 new TOptions() 方式创建实例
    protected virtual TOptions CreateInstance(string name)
    {
        return Activator.CreateInstance<TOptions>();
    }
}
```

- IConfigureOptions\<\>  
```C#
// 选项预配置的抽象表示
public interface IConfigureOptions<in TOptions> where TOptions : class
{
    // 配置选项
    void Configure(TOptions options);
}
```

- IConfigureNamedOptions\<\>  
```C#
// 选项预配置（命名）的抽象表示
public interface IConfigureNamedOptions<in TOptions> : IConfigureOptions<TOptions> where TOptions : class
{
    // 配置选项
    // 传递命名的方式
    void Configure(string? name, TOptions options);
}
```

- IPostConfigureOptions\<\>  
```C#
// 选项后配置（命名）的抽象表示
public interface IPostConfigureOptions<in TOptions> where TOptions : class
{
    // 配置选项
    // 传递命名的方式
    void PostConfigure(string? name, TOptions options);
}
```

- IValidateOptions\<\>  
```C#
// 选项验证配置（命名）的抽象表示
public interface IValidateOptions<TOptions> where TOptions : class
{
    // 验证选项
    // 传递命名的方式
    ValidateOptionsResult Validate(string? name, TOptions options);
}
```

- ConfigureOptions\<\>  
```C#
// IConfigureOptions<> 的默认实现
public class ConfigureOptions<TOptions> : IConfigureOptions<TOptions> where TOptions : class
{
    // 传递实际的配置委托
    public ConfigureOptions(Action<TOptions>? action)
    {
        Action = action;
    }

    public Action<TOptions>? Action { get; }

    // 配置选项
    // 通用配置，无关命名或未命名
    public virtual void Configure(TOptions options)
    {
        ThrowHelper.ThrowIfNull(options);

        Action?.Invoke(options);
    }
}
```

- ConfigureNamedOptions\<\>  
```C#
// IConfigureNamedOptions<> 的默认实现
public class ConfigureNamedOptions<TOptions> : IConfigureNamedOptions<TOptions> where TOptions : class
{
    // 传递实际的配置委托和命名
    public ConfigureNamedOptions(string? name, Action<TOptions>? action)
    {
        Name = name;
        Action = action;
    }

    public string? Name { get; }

    public Action<TOptions>? Action { get; }

    // 配置选项
    public virtual void Configure(string? name, TOptions options)
    {
        ThrowHelper.ThrowIfNull(options);

        // 使用配置的原则是传递的命名需要与当前配置的 Name 名称相同，或者配置的 Name 为 null
        if (Name == null || name == Name)
        {
            Action?.Invoke(options);
        }
    }

    // 传递未命名的方式（空字符串命名）
    public void Configure(TOptions options) => Configure(Options.DefaultName, options);
}
```

- ConfigureNamedOptions\<,\>  
```C#
// IConfigureNamedOptions<> 的实现
// 可以传递额外的依赖用于配置选项，以下是可以传递最多 5 个依赖的 ConfigureNamedOptions 定义
// ConfigureNamedOptions<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5>
public class ConfigureNamedOptions<TOptions, TDep> : IConfigureNamedOptions<TOptions>
        where TOptions : class
        where TDep : class
{
    // 传递实际的配置委托和命名以及相关的依赖
    public ConfigureNamedOptions(string? name, TDep dependency, Action<TOptions, TDep>? action)
    {
        Name = name;
        Action = action;
        Dependency = dependency;
    }

    public string? Name { get; }

    public Action<TOptions, TDep>? Action { get; }

    public TDep Dependency { get; }

    // 配置选项
    public virtual void Configure(string? name, TOptions options)
    {
        ThrowHelper.ThrowIfNull(options);

        // 使用配置的原则是传递的命名需要与当前配置的 Name 名称相同，或者配置的 Name 为 null
        if (Name == null || name == Name)
        {
            Action?.Invoke(options, Dependency);
        }
    }

    // 传递未命名的方式（空字符串命名）
    public void Configure(TOptions options) => Configure(Options.DefaultName, options);
}
```

- PostConfigureOptions\<\>  
```C#
// IPostConfigureOptions<> 的默认实现
// 实现方式与 ConfigureNamedOptions<> 相同
public class PostConfigureOptions<TOptions> : IPostConfigureOptions<TOptions> where TOptions : class
{
    public PostConfigureOptions(string? name, Action<TOptions>? action)
    {
        Name = name;
        Action = action;
    }

    public string? Name { get; }

    public Action<TOptions>? Action { get; }

    public virtual void PostConfigure(string? name, TOptions options)
    {
        ThrowHelper.ThrowIfNull(options);

        if (Name == null || name == Name)
        {
            Action?.Invoke(options);
        }
    }
}
```

- PostConfigureOptions\<,\>  
```C#
// IPostConfigureOptions<> 的实现
// 可以传递额外的依赖用于配置选项，以下是可以传递最多 5 个依赖的 PostConfigureOptions 定义
// PostConfigureOptions<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5>
// 实现方式与 ConfigureNamedOptions<> 相同
public class PostConfigureOptions<TOptions, TDep> : IPostConfigureOptions<TOptions>
        where TOptions : class
        where TDep : class
{
    public PostConfigureOptions(string? name, TDep dependency, Action<TOptions, TDep>? action)
    {
        Name = name;
        Action = action;
        Dependency = dependency;
    }

    public string? Name { get; }

    public Action<TOptions, TDep>? Action { get; }

    public TDep Dependency { get; }

    public virtual void PostConfigure(string? name, TOptions options)
    {
        ThrowHelper.ThrowIfNull(options);

        if (Name == null || name == Name)
        {
            Action?.Invoke(options, Dependency);
        }
    }

    public void PostConfigure(TOptions options) => PostConfigure(Options.DefaultName, options);
}
```

- ValidateOptions\<\>  
```C#
// IValidateOptions<> 的默认实现
public class ValidateOptions<TOptions> : IValidateOptions<TOptions> where TOptions : class
{
    // 传递实际的验证委托和命名以及失败时的消息内容
    public ValidateOptions(string? name, Func<TOptions, bool> validation, string failureMessage)
    {
        ThrowHelper.ThrowIfNull(validation);

        Name = name;
        Validation = validation;
        FailureMessage = failureMessage;
    }

    public string? Name { get; }

    public Func<TOptions, bool> Validation { get; }

    public string FailureMessage { get; }

    // 验证选项
    public ValidateOptionsResult Validate(string? name, TOptions options)
    {
        // 使用配置的原则是传递的命名需要与当前配置的 Name 名称相同，或者配置的 Name 为 null
        if (Name == null || name == Name)
        {
            if (Validation.Invoke(options))
            {
                return ValidateOptionsResult.Success;
            }
            return ValidateOptionsResult.Fail(FailureMessage);
        }

        // 返回没有匹配验证配置时的 ValidateOptionsResult
        return ValidateOptionsResult.Skip;
    }
}
```

- ValidateOptions\<,\>  
```C#
// IValidateOptions<> 的实现
// 可以传递额外的依赖用于验证选项，以下是可以传递最多 5 个依赖的 ValidateOptions 定义
// ValidateOptions<TOptions, TDep1, TDep2, TDep3, TDep4, TDep5>
public class ValidateOptions<TOptions, TDep> : IValidateOptions<TOptions> where TOptions : class
{
    // 传递实际的验证委托、命名、失败时的消息内容、相关的依赖
    public ValidateOptions(string? name, TDep dependency, Func<TOptions, TDep, bool> validation, string failureMessage)
    {
        ThrowHelper.ThrowIfNull(validation);

        Name = name;
        Validation = validation;
        FailureMessage = failureMessage;
        Dependency = dependency;
    }

    public string? Name { get; }

    public Func<TOptions, TDep, bool> Validation { get; }

    public string FailureMessage { get; }

    public TDep Dependency { get; }

    public ValidateOptionsResult Validate(string? name, TOptions options)
    {
        // 使用配置的原则是传递的命名需要与当前配置的 Name 名称相同，或者配置的 Name 为 null
        if (Name == null || name == Name)
        {
            if (Validation.Invoke(options, Dependency))
            {
                return ValidateOptionsResult.Success;
            }
            return ValidateOptionsResult.Fail(FailureMessage);
        }

        // 返回没有匹配验证配置时的 ValidateOptionsResult
        return ValidateOptionsResult.Skip;
    }
}
```

- ConfigurationChangeTokenSource\<\>  
```C#
// IOptionsChangeTokenSource<> 的默认实现
public class ConfigurationChangeTokenSource<TOptions> : IOptionsChangeTokenSource<TOptions>
{
    private IConfiguration _config;

    // 使用未命名方式（name 未空字符串）
    public ConfigurationChangeTokenSource(IConfiguration config) : this(Options.DefaultName, config)
    {
    }

    // 传递命名和配置
    public ConfigurationChangeTokenSource(string? name, IConfiguration config)
    {
        ThrowHelper.ThrowIfNull(config);

        _config = config;
        Name = name ?? Options.DefaultName;
    }

    public string Name { get; }

    // 利用 IConfiguration.GetReloadToken 方法获得 IChangeToken
    public IChangeToken GetChangeToken()
    {
        return _config.GetReloadToken();
    }
}
```

- NamedConfigureFromConfigurationOptions\<\>  
```C#
// 基于配置的选项配置
public class NamedConfigureFromConfigurationOptions<TOptions> : ConfigureNamedOptions<TOptions>
        where TOptions : class
{
    public NamedConfigureFromConfigurationOptions(string? name, IConfiguration config)
        : this(name, config, _ => { })
    { }

    // 利用 IConfiguration.Bind 扩展方法配置选项
    public NamedConfigureFromConfigurationOptions(string? name, IConfiguration config, Action<BinderOptions>? configureBinder)
        : base(name, options => config.Bind(options, configureBinder))
    {
        ThrowHelper.ThrowIfNull(config);
    }
}
```

## 依赖注入

- OptionsServiceCollectionExtensions  
```C#
// 服务注册扩展方法
public static class OptionsServiceCollectionExtensions
{
    // 注册 Options 模型相关的核心类型
    // IOptions<> 服务注册的实现类型为 UnnamedOptionsManager<>，生命周期为 Singleton
    // IOptionsSnapshot<> 服务注册的实现类型为 OptionsManager<>，生命周期为 Scoped
    // IOptionsMonitor<> 服务注册的实现类型为 OptionsMonitor<>，生命周期为 Singleton
    // IOptionsFactory<> 服务注册的实现类型为 OptionsFactory<>，生命周期为 Transient（目的是最终跟随上面三个服务的生命周期）
    // IOptionsMonitorCache<> 服务注册的实现类型为 OptionsCache<>，生命周期为 Singleton
    // 由于都是使用 TryAdd 方法注册服务，所以 AddOptions 可以重复调用
    public static IServiceCollection AddOptions(this IServiceCollection services)
    {
        ThrowHelper.ThrowIfNull(services);

        services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptions<>), typeof(UnnamedOptionsManager<>)));
        services.TryAdd(ServiceDescriptor.Scoped(typeof(IOptionsSnapshot<>), typeof(OptionsManager<>)));
        services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitor<>), typeof(OptionsMonitor<>)));
        services.TryAdd(ServiceDescriptor.Transient(typeof(IOptionsFactory<>), typeof(OptionsFactory<>)));
        services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitorCache<>), typeof(OptionsCache<>)));
        return services;
    }

    // 使用未命名方式注册预配置（最终会使用空字符串命名）
    public static IServiceCollection Configure<TOptions>(this IServiceCollection services, Action<TOptions> configureOptions) where TOptions : class
        => services.Configure(Options.Options.DefaultName, configureOptions);

    // 使用命名方式注册预配置
    public static IServiceCollection Configure<TOptions>(this IServiceCollection services, string? name, Action<TOptions> configureOptions)
        where TOptions : class
    {
        ThrowHelper.ThrowIfNull(services);
        ThrowHelper.ThrowIfNull(configureOptions);

        services.AddOptions();
        // 由于注册服务的实现方式使用的是实例，所以只能注册为 Singleton 生命周期
        services.AddSingleton<IConfigureOptions<TOptions>>(new ConfigureNamedOptions<TOptions>(name, configureOptions));
        return services;
    }

    // 注册成为通用预配置（name 为 null）
    public static IServiceCollection ConfigureAll<TOptions>(this IServiceCollection services, Action<TOptions> configureOptions) where TOptions : class
        => services.Configure(name: null, configureOptions: configureOptions);

    // 使用未命名方式注册后配置（最终会使用空字符串命名）
    public static IServiceCollection PostConfigure<TOptions>(this IServiceCollection services, Action<TOptions> configureOptions) where TOptions : class
        => services.PostConfigure(Options.Options.DefaultName, configureOptions);

    // 使用命名方式注册后配置
    public static IServiceCollection PostConfigure<TOptions>(this IServiceCollection services, string? name, Action<TOptions> configureOptions)
        where TOptions : class
    {
        ThrowHelper.ThrowIfNull(services);
        ThrowHelper.ThrowIfNull(configureOptions);

        services.AddOptions();
        // 由于注册服务的实现方式使用的是实例，所以只能注册为 Singleton 生命周期
        services.AddSingleton<IPostConfigureOptions<TOptions>>(new PostConfigureOptions<TOptions>(name, configureOptions));
        return services;
    }

    // 注册成为通用后配置（name 为 null）
    public static IServiceCollection PostConfigureAll<TOptions>(this IServiceCollection services, Action<TOptions> configureOptions) where TOptions : class
        => services.PostConfigure(name: null, configureOptions: configureOptions);

    // 注册自定义选项配置类型（不使用系统内建的）
    // 泛型参数为选项配置类型（非选项类型）
    public static IServiceCollection ConfigureOptions<TConfigureOptions>(
        this IServiceCollection services)
        where TConfigureOptions : class
            => services.ConfigureOptions(typeof(TConfigureOptions));

    // 查找选项配置类型实现的接口
    // 查找属于 IConfigureOptions<>、IPostConfigureOptions<>、IValidateOptions<> 的接口类型
    // 迭代返回被构造的泛型接口类型
    private static IEnumerable<Type> FindConfigurationServices(Type type)
    {
        foreach (Type t in GetInterfacesOnType(type))
        {
            if (t.IsGenericType)
            {
                Type gtd = t.GetGenericTypeDefinition();
                if (gtd == typeof(IConfigureOptions<>) ||
                    gtd == typeof(IPostConfigureOptions<>) ||
                    gtd == typeof(IValidateOptions<>))
                {
                    yield return t;
                }
            }
        }

        static Type[] GetInterfacesOnType(Type t)
            => t.GetInterfaces();
    }

    // 个人理解，这个方法的作用是提示在调用 ConfigureOptions 方法时
    // 应该传入的是选项配置类型，而不是选项类型
    // 从而错误的认为和调用 Configure 方法一样，传入了配置委托 Action<>
    private static void ThrowNoConfigServices(Type type) =>
        throw new InvalidOperationException(
            type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Action<>) ?
                SR.Error_NoConfigurationServicesAndAction :
                SR.Error_NoConfigurationServices);

    // 注册自定义选项配置类型（不使用系统内建的）
    // 泛型参数为选项配置类型（非选项类型）
    public static IServiceCollection ConfigureOptions(
        this IServiceCollection services,
        Type configureType)
    {
        services.AddOptions();

        bool added = false;
        foreach (Type serviceType in FindConfigurationServices(configureType))
        {
            // 以封闭泛型类型作为服务注册类型（非开发泛型类型）
            // 服务注册生命周期为 Transient
            services.AddTransient(serviceType, configureType);
            added = true;
        }

        if (!added)
        {
            ThrowNoConfigServices(configureType);
        }

        return services;
    }

    // 注册自定义选项配置实例
    public static IServiceCollection ConfigureOptions(this IServiceCollection services, object configureInstance)
    {
        services.AddOptions();
        Type configureType = configureInstance.GetType();

        bool added = false;
        foreach (Type serviceType in FindConfigurationServices(configureType))
        {
            services.AddSingleton(serviceType, configureInstance);
            added = true;
        }

        if (!added)
        {
            ThrowNoConfigServices(configureType);
        }

        return services;
    }

    // 创建 OptionsBuilder<>
    public static OptionsBuilder<TOptions> AddOptions<TOptions>(this IServiceCollection services) where TOptions : class
        => services.AddOptions<TOptions>(Options.Options.DefaultName);

    // 创建 OptionsBuilder<>
    public static OptionsBuilder<TOptions> AddOptions<TOptions>(this IServiceCollection services, string? name)
        where TOptions : class
    {
        ThrowHelper.ThrowIfNull(services);

        services.AddOptions();
        return new OptionsBuilder<TOptions>(services, name);
    }
}
```

- OptionsBuilder\<\>  
```C#
// 选项配置建造者
// 主要提供选项配置相关的注册方法，避免在 OptionsServiceCollectionExtensions 中定义过多的扩展方法
public class OptionsBuilder<TOptions> where TOptions : class
{
    private const string DefaultValidationFailureMessage = "A validation error has occurred.";

    // 选项配置的名称
    public string Name { get; }

    public IServiceCollection Services { get; }

    public OptionsBuilder(IServiceCollection services, string? name)
    {
        ThrowHelper.ThrowIfNull(services);

        Services = services;
        // name 为 null 则使用空字符串命名
        Name = name ?? Options.DefaultName;
    }

    // 注册预配置
    public virtual OptionsBuilder<TOptions> Configure(Action<TOptions> configureOptions)
    {
        ThrowHelper.ThrowIfNull(configureOptions);

        Services.AddSingleton<IConfigureOptions<TOptions>>(new ConfigureNamedOptions<TOptions>(Name, configureOptions));
        return this;
    }

    // 注册预配置
    // 重载支持最多 5 个依赖服务
    public virtual OptionsBuilder<TOptions> Configure<TDep>(Action<TOptions, TDep> configureOptions)
        where TDep : class
    {
        ThrowHelper.ThrowIfNull(configureOptions);

        // 所需相关的依赖服务由依赖注入容器提供
        // 选项配置的服务注册生命周期为 Transient
        Services.AddTransient<IConfigureOptions<TOptions>>(sp =>
            new ConfigureNamedOptions<TOptions, TDep>(Name, sp.GetRequiredService<TDep>(), configureOptions));
        return this;
    }

    // 注册后配置
    public virtual OptionsBuilder<TOptions> PostConfigure(Action<TOptions> configureOptions)
    {
        ThrowHelper.ThrowIfNull(configureOptions);

        Services.AddSingleton<IPostConfigureOptions<TOptions>>(new PostConfigureOptions<TOptions>(Name, configureOptions));
        return this;
    }

    // 注册后配置
    // 重载支持最多 5 个依赖服务
    public virtual OptionsBuilder<TOptions> PostConfigure<TDep>(Action<TOptions, TDep> configureOptions)
        where TDep : class
    {
        ThrowHelper.ThrowIfNull(configureOptions);

        // 所需相关的依赖服务由依赖注入容器提供
        // 选项配置的服务注册生命周期为 Transient
        Services.AddTransient<IPostConfigureOptions<TOptions>>(sp =>
            new PostConfigureOptions<TOptions, TDep>(Name, sp.GetRequiredService<TDep>(), configureOptions));
        return this;
    }

    // 注册验证配置
    public virtual OptionsBuilder<TOptions> Validate(Func<TOptions, bool> validation)
        => Validate(validation: validation, failureMessage: DefaultValidationFailureMessage);

    // 注册验证配置
    public virtual OptionsBuilder<TOptions> Validate(Func<TOptions, bool> validation, string failureMessage)
    {
        ThrowHelper.ThrowIfNull(validation);

        Services.AddSingleton<IValidateOptions<TOptions>>(new ValidateOptions<TOptions>(Name, validation, failureMessage));
        return this;
    }

    // 注册验证配置
    // 重载支持最多 5 个依赖服务
    public virtual OptionsBuilder<TOptions> Validate<TDep>(Func<TOptions, TDep, bool> validation) where TDep : notnull
        => Validate(validation: validation, failureMessage: DefaultValidationFailureMessage);

    // 注册验证配置
    // 重载支持最多 5 个依赖服务
    public virtual OptionsBuilder<TOptions> Validate<TDep>(Func<TOptions, TDep, bool> validation, string failureMessage) where TDep : notnull
    {
        ThrowHelper.ThrowIfNull(validation);

        // 所需相关的依赖服务由依赖注入容器提供
        // 验证配置的服务注册生命周期为 Transient
        Services.AddTransient<IValidateOptions<TOptions>>(sp =>
            new ValidateOptions<TOptions, TDep>(Name, sp.GetRequiredService<TDep>(), validation, failureMessage));
        return this;
    }
}
```

- OptionsConfigurationServiceCollectionExtensions  
```C#
// 提供基于配置系统的选项配置注册扩展方法
public static class OptionsConfigurationServiceCollectionExtensions
{
    // 注册基于 IConfiguration 的选项配置
    // 使用空字符串命名
    public static IServiceCollection Configure<TOptions>(this IServiceCollection services, IConfiguration config) where TOptions : class
        => services.Configure<TOptions>(Options.Options.DefaultName, config);

    // 注册基于 IConfiguration 的选项配置
    public static IServiceCollection Configure<TOptions>(
        this IServiceCollection services, 
        string? name, 
        IConfiguration config) 
            where TOptions : class
        => services.Configure<TOptions>(name, config, _ => { });

    // 注册基于 IConfiguration 的选项配置
    // 使用空字符串命名
    // 并使用 Action<BinderOptions> 绑定配置
    public static IServiceCollection Configure<TOptions>(
        this IServiceCollection services, 
        IConfiguration config, 
        Action<BinderOptions>? configureBinder)
            where TOptions : class
        => services.Configure<TOptions>(Options.Options.DefaultName, config, configureBinder);

    // 注册基于 IConfiguration 的选项配置
    // 并使用 Action<BinderOptions> 绑定配置
    public static IServiceCollection Configure<TOptions>(
        this IServiceCollection services, 
        string? name, 
        IConfiguration config, 
        Action<BinderOptions>? configureBinder)
            where TOptions : class
    {
        ThrowHelper.ThrowIfNull(services);
        ThrowHelper.ThrowIfNull(config);

        services.AddOptions();
        services.AddSingleton<IOptionsChangeTokenSource<TOptions>>(new ConfigurationChangeTokenSource<TOptions>(name, config));
        return services.AddSingleton<IConfigureOptions<TOptions>>(
            new NamedConfigureFromConfigurationOptions<TOptions>(name, config, configureBinder));
    }
}
```